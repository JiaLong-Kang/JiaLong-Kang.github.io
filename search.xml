<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++17/20新特性 支持初始化语句的if、switch、范围for</title>
    <url>/C-17-20%E6%96%B0%E7%89%B9%E6%80%A7-%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E7%9A%84if%E3%80%81switch%E3%80%81%E8%8C%83%E5%9B%B4for.html</url>
    <content><![CDATA[<p>在项目开发中我们会用到<code>STL</code>中各种容器，假设我们有一个 <code>map</code>，我们希望查找一个元素，并在找到时执行某些操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (it != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码虽然能够完成我们的要求，但有如下问题：</p>
<ul>
<li>作用域污染：<em>it</em>变量在<code>if</code>语句之后仍能被继续使用，会造成作用域污染。</li>
</ul>
<ul>
<li>简洁性与可维护性差：代码不够简洁，并且当<em>it</em>迭代器失效时继续使用会有未知风险。</li>
</ul>
<span id="more"></span>

<h1 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a>1. if</h1><p>在<code>C++ 17</code>中，<code>if</code> 可以在执行条件判断之前先执行一个初始化语句。在该语句中可以执行某个表达式语句、初始化变量等。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (init-statement; condition) </span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (init-statement; condition) </span><br><span class="line">  	...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	  ...  </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>init-statement与condition通过 <code>; </code>分隔，init-statement可以为空。</li>
<li>如果在init-statement中初始化变量，该变量生命周期（作用域）从当前init-statement开始，直到整个if结束。</li>
<li>可以在init-statement中初始化多个相同类型变量，它们通过 <code>, </code>分隔。</li>
</ol>
<p>当if支持初始化语句时，我们可以将上面代码改为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>); it != m.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在上文中我们说到，在 init-statement中初始的变量，该变量生命周期从当前开始，直到整个<code>if</code>结束。所以上面代码可以等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != m.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面举一个稍微复杂的例子，在map中存放用户名与对应角色，给定一个用户名，根据不同角色输出不同欢迎信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::map&lt;std::string, std::string&gt; user_roles = &#123; &#123;<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;admin&quot;</span>&#125;, &#123;<span class="string">&quot;bob&quot;</span>,   <span class="string">&quot;user&quot;</span>&#125;, &#123;<span class="string">&quot;eve&quot;</span>,   <span class="string">&quot;guest&quot;</span>&#125;&#125;;</span><br><span class="line">	std::string username = <span class="string">&quot;alice&quot;</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">auto</span> it = user_roles.<span class="built_in">find</span>(username); it == user_roles.<span class="built_in">end</span>()) <span class="comment">// it生命周期从当前位置开始直到整个if结束</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;User not found.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> role = it-&gt;second; <span class="string">&quot;admin&quot;</span> == role) <span class="comment">// role生命周期从当前位置开始直到整个if结束</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Welcome, admin &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;user&quot;</span> == role)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Hello, user &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Access limited for guest &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = user_roles.<span class="built_in">find</span>(username);</span><br><span class="line">		<span class="keyword">if</span> (it == user_roles.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;User not found.\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> role = it-&gt;second;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span> == role)</span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Welcome, admin &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;user&quot;</span> == role)</span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Hello, user &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;Access limited for guest &quot;</span> &lt;&lt; username &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-switch"><a href="#2-switch" class="headerlink" title="2. switch"></a>2. switch</h1><p>在<code>C++ 17</code>中，<code>switch</code>与<code>if</code>一样，可以在执行条件判断之前先执行一个初始化语句。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (init-statement; condition-expression) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果在init-statement中初始化变量，该变量生命周期（作用域）会贯穿整个<code>switch</code>结构。</p>
<p>下面这个例子模拟主线程检查一个后台任务是否在规定时间内完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::mutex mtx;</span><br><span class="line">	std::condition_variable cv;</span><br><span class="line">	<span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台线程在 500ms 后设置 ready = true 并通知</span></span><br><span class="line">	<span class="function">std::thread <span class="title">notifier</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// 任务处理</span></span></span></span><br><span class="line"><span class="params"><span class="function">			ready = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查一个任务100ms内是否完成</span></span><br><span class="line">	<span class="keyword">switch</span> (std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx); cv.<span class="built_in">wait_for</span>(lock, <span class="number">100</span>ms))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> std::cv_status::timeout:</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Timeout: did not get notification in 100ms.\n&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> std::cv_status::no_timeout:</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Got notification before timeout.\n&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	notifier.<span class="built_in">join</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-范围for"><a href="#3-范围for" class="headerlink" title="3. 范围for"></a>3. 范围for</h1><p>在<code>C++ 20</code>中，范围 for 引入了一个新特性：初始化语句。简单来说，就是你可以在范围 for 里像普通 for循环那样先写一个初始化语句，然后再写循环。</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-statement; item-declaration : range-initializer)</span><br><span class="line">     statement</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>init-statement与item-declaration通过 <code>; </code>分隔，init-statement可以为空。</p>
</li>
<li><p>如果在init-statement中初始化变量，该变量生命周期（作用域）直到整个范围for结束。</p>
</li>
<li><p>可以在init-statement中初始化多个相同类型变量，它们通过<code>,</code>分隔。</p>
</li>
</ol>
<p>在开发中我经常有个需求，需要打印容器中每个元素的值以及它的下标。</p>
<p>(1) 使用传统for循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;vec[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; vec[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>(2) 使用范围for</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// for循环结束后会存在命名空间污染问题</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e: vec)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;vec[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; vec[i] &lt;&lt; std::endl;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 使用迭代器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// while循环结束后会存在命名空间污染问题</span></span><br><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); <span class="comment">// 命名空间污染与迭代器失效后误使用问题 </span></span><br><span class="line"><span class="keyword">while</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;vec[&quot;</span> &lt;&lt; i++ &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; *it++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们发现不管使用哪种方式代码都不是很优雅，在<code>c++ 20</code>中我们可以这样写，代码是不是非常优雅了！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="keyword">auto</span> &amp;e: vec)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;vec[&quot;</span> &lt;&lt; i++ &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h1><p><code>goto</code>跳过局部变量的初始化会编译错误，所以下面代码不正确：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;  <span class="comment">// 跳过局部变量x初始化，编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">1</span>; x == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">label:</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结: 通过上面示例可以看出，在if、switch、范围for中所谓支持初始化语句的新特性其实就是语法糖而已，我们可以轻易地用等价代码代替。C++ 新标准之所以引入它们很重要原因是可以提高代码可读性以及避免作用域污染。</strong></p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
        <tag>C++ 20</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 一次栈区使用大数组引发的段错误</title>
    <url>/C-C-%E4%B8%80%E6%AC%A1%E6%A0%88%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%A4%A7%E6%95%B0%E7%BB%84%E5%BC%95%E5%8F%91%E7%9A%84%E6%AE%B5%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<p>&emsp; 最近在写一个功能的单元测试。写完第一个子模块相关的测试代码后运行没有问题，当写完第二个子模块的测试代码后运行直接<em>Segmentation fault</em>崩溃了。<em>gdb</em> 调试<em>core dump文件</em>发现在一行打印语句处崩溃的，我想难不成非法访问内存了。于是又重新检查了相关代码，发现用到的变量都是局部变量，而且都是静态开辟，没理由会<em>Segmentation fault</em>才对。于是想着使用<code>valgrind</code> 工具检查下程序内存，结果一下就定位到错误了，<strong>原来是在<em>main</em>函数内定义了一个大数组，造成栈溢出</strong>。由于没有在定义数组那行崩溃，而是在间隔很远的打印语句那行崩溃的，所以最开始没有排查出来。</p>
<span id="more"></span>



<img src="C-C-一次栈区使用大数组引发的段错误/Memory-Layout-of-C.png" >

<p>该图为C&#x2F;C++ 程序的内存布局，这里简单讲解下里面的栈区。栈区存储函数调用相关数据，由编译器分配和管理。栈区是向下增长的。</p>
<ul>
<li><strong>局部变量</strong>：在函数内部定义的非静态局部变量</li>
<li><strong>函数参数</strong>：传递给函数的参数。</li>
<li><strong>调用上下文</strong>：函数调用时的返回地址、寄存器状态等信息。</li>
</ul>
<p><strong>在<code>linux</code>中，栈区大小默认为8M，可以通过<code>ulimit -s</code>命令查看或设置。</strong></p>
<p>下面是3个几乎相同的代码，想一想它们运行起来会崩溃吗 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  <span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	  <span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  <span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>gcc 4.8.5</code> 中例1正常退出，例2与例3都<em>Segmentation fault</em></p>
<p> 对例2使用<code>valgrind</code> 内存检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user1@develop tmp]$ valgrind --tool=memcheck ./a.out </span><br><span class="line">==23183== Memcheck, a memory error detector</span><br><span class="line">==23183== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==23183== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==23183== Command: ./a.out</span><br><span class="line">==23183== </span><br><span class="line">==23183== Warning: client switching stacks?  SP change: 0x1fff000220 --&gt; 0x1ff8c00218</span><br><span class="line">==23183==          to suppress, use: --max-stackframe=104857608 or greater</span><br><span class="line">==23183== Invalid write of size 8</span><br><span class="line">==23183==    at 0x400885: main (test.cpp:5)</span><br><span class="line">==23183==  Address 0x1ff8c00218 is on thread 1&#x27;s stack</span><br><span class="line">==23183== </span><br><span class="line">==23183== </span><br><span class="line">==23183== Process terminating with default action of signal 11 (SIGSEGV): dumping core</span><br><span class="line">==23183==  Access not within mapped region at address 0x1FF8C00218</span><br><span class="line">==23183==    at 0x400885: main (test.cpp:5)</span><br><span class="line">==23183==  If you believe this happened as a result of a stack</span><br><span class="line">==23183==  overflow in your program&#x27;s main thread (unlikely but</span><br><span class="line">==23183==  possible), you can try to increase the size of the</span><br><span class="line">==23183==  main thread stack using the --main-stacksize= flag.</span><br><span class="line">==23183==  The main thread stack size used in this run was 8388608.</span><br><span class="line">==23183== Invalid write of size 8</span><br><span class="line">==23183==    at 0x4A24710: _vgnU_freeres (vg_preloaded.c:59)</span><br><span class="line">==23183==  Address 0x1ff8c00210 is on thread 1&#x27;s stack</span><br><span class="line">==23183== </span><br><span class="line">==23183== </span><br><span class="line">==23183== Process terminating with default action of signal 11 (SIGSEGV)</span><br><span class="line">==23183==  Access not within mapped region at address 0x1FF8C00210</span><br><span class="line">==23183==    at 0x4A24710: _vgnU_freeres (vg_preloaded.c:59)</span><br><span class="line">==23183==  If you believe this happened as a result of a stack</span><br><span class="line">==23183==  overflow in your program&#x27;s main thread (unlikely but</span><br><span class="line">==23183==  possible), you can try to increase the size of the</span><br><span class="line">==23183==  main thread stack using the --main-stacksize= flag.</span><br><span class="line">==23183==  The main thread stack size used in this run was 8388608.</span><br><span class="line">==23183== </span><br><span class="line">==23183== HEAP SUMMARY:</span><br><span class="line">==23183==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==23183==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</span><br><span class="line">==23183== </span><br><span class="line">==23183== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==23183== </span><br><span class="line">==23183== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==23183== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<p>对例3使用<code>valgrind</code> 内存检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user1@develop tmp]$ valgrind --tool=memcheck ./a.out </span><br><span class="line">==23334== Memcheck, a memory error detector</span><br><span class="line">==23334== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==23334== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==23334== Command: ./a.out</span><br><span class="line">==23334== </span><br><span class="line">==23334== Warning: client switching stacks?  SP change: 0x1fff000220 --&gt; 0x1ff8c00218</span><br><span class="line">==23334==          to suppress, use: --max-stackframe=104857608 or greater</span><br><span class="line">==23334== Invalid write of size 8</span><br><span class="line">==23334==    at 0x400885: main (test.cpp:6)</span><br><span class="line">==23334==  Address 0x1ff8c00218 is on thread 1&#x27;s stack</span><br><span class="line">==23334== </span><br><span class="line">==23334== </span><br><span class="line">==23334== Process terminating with default action of signal 11 (SIGSEGV): dumping core</span><br><span class="line">==23334==  Access not within mapped region at address 0x1FF8C00218</span><br><span class="line">==23334==    at 0x400885: main (test.cpp:6)</span><br><span class="line">==23334==  If you believe this happened as a result of a stack</span><br><span class="line">==23334==  overflow in your program&#x27;s main thread (unlikely but</span><br><span class="line">==23334==  possible), you can try to increase the size of the</span><br><span class="line">==23334==  main thread stack using the --main-stacksize= flag.</span><br><span class="line">==23334==  The main thread stack size used in this run was 8388608.</span><br><span class="line">==23334== Invalid write of size 8</span><br><span class="line">==23334==    at 0x4A24710: _vgnU_freeres (vg_preloaded.c:59)</span><br><span class="line">==23334==  Address 0x1ff8c00210 is on thread 1&#x27;s stack</span><br><span class="line">==23334== </span><br><span class="line">==23334== </span><br><span class="line">==23334== Process terminating with default action of signal 11 (SIGSEGV)</span><br><span class="line">==23334==  Access not within mapped region at address 0x1FF8C00210</span><br><span class="line">==23334==    at 0x4A24710: _vgnU_freeres (vg_preloaded.c:59)</span><br><span class="line">==23334==  If you believe this happened as a result of a stack</span><br><span class="line">==23334==  overflow in your program&#x27;s main thread (unlikely but</span><br><span class="line">==23334==  possible), you can try to increase the size of the</span><br><span class="line">==23334==  main thread stack using the --main-stacksize= flag.</span><br><span class="line">==23334==  The main thread stack size used in this run was 8388608.</span><br><span class="line">==23334== </span><br><span class="line">==23334== HEAP SUMMARY:</span><br><span class="line">==23334==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==23334==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</span><br><span class="line">==23334== </span><br><span class="line">==23334== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==23334== </span><br><span class="line">==23334== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==23334== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>



<p><strong>分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==23334== Warning: client switching stacks?  SP change: 0x1fff000220 --&gt; 0x1ff8c00218</span><br><span class="line">==23334==          to suppress, use: --max-stackframe=104857608 or greater</span><br></pre></td></tr></table></figure>

<p>这里 Valgrind检测到SP (栈顶寄存器)的值有了非常大的跳跃。<em>0x1fff000220</em> 是进入<em>main</em>函数之前的栈顶指针值，即*__libc_start_main* 函数(GCC 中是由它调用我们写的main函数)。而<em>0x1ff8c00218</em>是编译器尝试为 <em>main</em>函数内相关局部变量分配空间之后的栈顶指针位置。远超过默认的8M栈大小。当我们执行到打印语句时，访问了<em>0x1ff8c00218</em>这个地址，这是一个<strong>非法的、未映射的地址</strong>。它已经远远超出了操作系统为栈区分配的8MB空间边界。所以非法访问内存，操作系统向程序发送<code>SIGSEGV</code>导致崩溃。</p>
<p>说明：当使用<code>clang 17.0.0 </code> 测试时，例1也会段错误。</p>
<p>结论：以前只注意到函数递归过深很容易造成栈溢出，而忽略在栈区分配大数组场景。如果需要一个大数组还是动态申请内存或直接使用<code>std::vector</code>方式更靠谱。</p>
]]></content>
      <categories>
        <category>编程陷阱</category>
      </categories>
      <tags>
        <tag>Segmentation fault</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 对sizeof返回值类型不了解带来的陷阱</title>
    <url>/C-C-%E5%AF%B9sizeof%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%BA%86%E8%A7%A3%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%B7%E9%98%B1.html</url>
    <content><![CDATA[<p>&emsp;对C&#x2F;C++程序员来说，<code>sizeof</code>可以说再熟悉不过，<code>sizeof</code>是一个 C&#x2F;C++中的<strong>运算符</strong>，在<strong>编译阶段</strong>计算并返回一个对象或数据类型所占用的内存大小（单位: 字节）。<code>sizeof</code>看起来简单，但是对它不了解很容易在代码中留下陷阱。比如：当传入一个表达式给<code>sizeof</code>时，它只会返回表达式计算结果的类型大小，但它不会对表达式求值。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">2024</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(i++)=&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(i++) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// i的值仍然是2024</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sizeof</code>带来的陷阱还有许多，在此不做探讨，本文只举例最让人忽视的一种情况，下面这个程序的作者希望输出数组中的所有元素，运行后他却没有得到他想要的结果，程序没有输出任何内容，这是为什么呢?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">204</span>,<span class="number">99</span>,<span class="number">16</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">-1</span>;d &lt;= (TOTAL_ELEMENTS<span class="number">-2</span>);d++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">array</span>[d+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是<code>sizeof</code>的返回值类型是<code>size_t</code>，是一个<strong>无符号的整数</strong>。d为int类型，使用d与无符号整数比较时，d会被隐式类型转换为无符号整数。 这样就导致-1被转换成一个非常大的值，以至于for循环不满足条件。<span class="exturl" data-url="aHR0cDovL3d3dy5nb3dyaWt1bWFyLmNvbS9jL2luZGV4Lmh0bWw=">点击此处<i class="fa fa-external-link-alt"></i></span>可以访问该程序作者的博客，他还有许多这种类似的陷阱程序。</p>
<p>结论：一定要切记<code>sizeof</code>返回的是无符号整数类型，当与有符号整数或其他类型进行比较，且这个有符号数的值可能为负数时，会带来不可预料的后果。</p>
]]></content>
      <categories>
        <category>编程陷阱</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ auto与decltype及函数返回类型后置</title>
    <url>/C-auto%E4%B8%8Edecltype%E5%8F%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE.html</url>
    <content><![CDATA[<p>前言：在早期C&#x2F;C++中auto关键字的作用是：一个存储类型指示符，使用auto修饰的变量，存储类型为自动存储期，从变量声明处生命周期开始，出变量所在代码块生命周期结束，并且<strong>全局变量不能用auto修饰</strong>。但是局部变量的生命周期本来就是进入作用域生命周期开始，出作用域生命周期结束。<strong>导致用auto修饰局部变量和不使用auto修饰没有任何区别</strong>，处于一个尴尬地步。</p>
<span id="more"></span>

<h1 id="一、auto"><a href="#一、auto" class="headerlink" title="一、auto"></a>一、auto</h1><h2 id="1-1-C-11"><a href="#1-1-C-11" class="headerlink" title="1.1 C++11"></a>1.1 C++11</h2><p>&emsp;C++11中，标准委员会赋予了auto全新的作用：<strong>auto做为类型占位符</strong>，<strong>auto声明的变量数据类型由编译器在编译时推导而得，所以使用auto声明变量时必须对其进行初始化</strong>，在编译阶段编译器根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，<strong>编译器在编译阶段会将auto替换为变量实际的类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> y = x; <span class="comment">// 因为x为int类型，所以等同于 int y = x;</span></span><br><span class="line">	<span class="keyword">auto</span> a = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 因为a为char类型，所以等同于 char a = &#x27;a&#x27;;</span></span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">1</span>; <span class="comment">// 因为b为int类型，所以等同于 int b = 1;</span></span><br><span class="line">	<span class="keyword">auto</span> c = <span class="number">3.14</span>; <span class="comment">// 因为c为double类型，所以等同于 double c = 3.14;</span></span><br><span class="line">	<span class="comment">// auto d; 错误，无法推导d是什么类型，导致不能分配内存空间</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">y：<span class="type">int</span></span><br><span class="line">a：<span class="type">char</span></span><br><span class="line">b：<span class="type">int</span></span><br><span class="line">c：<span class="type">double</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:使用auto对多个变量推导时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器按第一个变量类型进行推导，然后用推导出来的类型定义其他变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>, b = <span class="number">20</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">3.14</span>; <span class="comment">// 错误，第一个变量x类型为int,但y为double</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-1-推导规则"><a href="#1-1-1-推导规则" class="headerlink" title="1.1.1 推导规则"></a>1.1.1 推导规则</h3><p><strong>规则1:</strong>  auto声明变量时没有使用引用或指针，则推导出来类型会忽略引用、const 限定符和 volatile 限定符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">2025</span>;</span><br><span class="line"><span class="keyword">auto</span> n1 = i;   <span class="comment">// auto声明变量时没有使用引用或指针，推导会忽略const限定符，auto推导类型为int，n1类型为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n2 = i;  <span class="comment">// auto声明变量时使用引用，auto推导类型为const int，n2类型为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> *n3 = &amp;i; <span class="comment">// auto声明变量时使用指针，auto推导类型为const int，n3类型为const int*</span></span><br><span class="line"><span class="keyword">auto</span> n4 = n2;  <span class="comment">// auto声明变量时没有使用引用或指针，推导会忽略n2类型的引用、const限定符，auto推导类型为int，n4类型为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n5 = n2; <span class="comment">// auto声明变量时使用引用，auto推导类型为const int，n5类型为const int&amp;</span></span><br></pre></td></tr></table></figure>
<p><strong>规则2:</strong> auto推导指针类型时，<code>auto</code>与<code>auto*</code>没有任何区别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = &amp;i; <span class="comment">// auto推导类型为const int*，a类型为const int*</span></span><br><span class="line"><span class="keyword">auto</span>* b = &amp;i; <span class="comment">// auto推导类型为const int，b类型为const int*</span></span><br></pre></td></tr></table></figure>
<p><strong>规则3:</strong> auto推导目标对象是数组或函数时，会被推导为对应指针类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = arr; <span class="comment">// auto推导类型为int * </span></span><br><span class="line"><span class="keyword">auto</span> b = fun; <span class="comment">// auto推导类型为void (*)()</span></span><br></pre></td></tr></table></figure>
<p><strong>规则4:</strong> auto推导列表表达式</p>
<p><font color=red >注意：下面规则适用于C++ 17</font></p>
<ul>
<li>直接使用列表初始化，列表中必须为单元素，否则编译错误，auto推导类型为该元素类型</li>
<li>用等号加列表初始化，列表中可以包含多个类型相同的元素，auto推导类型为<code>std::initializer_list&lt;T&gt;</code>，其中T为元素类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a1&#123;<span class="number">3</span>&#125;; <span class="comment">// auto推导类型为int</span></span><br><span class="line"><span class="keyword">auto</span> a2&#123;<span class="number">1</span>, <span class="number">3</span>&#125;; <span class="comment">// 编译错误,不是单个元素</span></span><br><span class="line"><span class="keyword">auto</span> a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// auto推导类型为std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> a4 = &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;; <span class="comment">// 编译错误，列表内元素类型不同</span></span><br></pre></td></tr></table></figure>
<p><strong>规则5:</strong> auto结合万能引用推导<br>如果推导对象是一个左值，将被推导为引用类型。如果推导对象是一个右值，将被推导为右值引用类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2025</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;x = a; 	  <span class="comment">// a为左值，x推导为左值引用，即int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y = <span class="number">2024</span>; <span class="comment">// 2024为右值，y推导为右值引用，即int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-auto不能使用的场景"><a href="#1-1-2-auto不能使用的场景" class="headerlink" title="1.1.2 auto不能使用的场景"></a>1.1.2 auto不能使用的场景</h3><h4 id="1-1-2-1-auto-不能做为函数形参"><a href="#1-1-2-1-auto-不能做为函数形参" class="headerlink" title="1.1.2.1 auto 不能做为函数形参"></a>1.1.2.1 auto 不能做为函数形参</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">// 错误，auto不能做函数形参，编译器不知道如何为形参分配空间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-2-auto-不能声明数组"><a href="#1-1-2-2-auto-不能声明数组" class="headerlink" title="1.1.2.2 auto 不能声明数组"></a>1.1.2.2 auto 不能声明数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-C-14"><a href="#1-2-C-14" class="headerlink" title="1.2 C++ 14"></a>1.2 C++ 14</h2><h3 id="1-2-1-函数返回值类型推导"><a href="#1-2-1-函数返回值类型推导" class="headerlink" title="1.2.1 函数返回值类型推导"></a>1.2.1 函数返回值类型推导</h3><p>C++ 14支持使用auto对函数返回值类型进行推导，但要确保所有的返回值类型是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> <span class="comment">// 正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">double</span> i,<span class="type">double</span> j)</span> <span class="comment">// 错误，0为int类型，i+j为double类型，返回值类型不相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0.0</span> || j &lt; <span class="number">0.0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-lambda"><a href="#1-2-2-lambda" class="headerlink" title="1.2.2 lambda"></a>1.2.2 lambda</h3><p>C++14支持在lambda中使用auto作为形参以及返回值类型推导。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) <span class="comment">// lambda中使用auto对函数形参类型推导</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret1 = <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// ret1 = 3</span></span><br><span class="line"><span class="keyword">auto</span> ret2 = <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">// ret2 = 3.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> &amp;x) -&gt;<span class="keyword">auto</span>&amp; <span class="comment">// lambda可以使用auto推导返回值类型，或者auto&amp;返回引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;x:&quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span>&amp; ref = <span class="built_in">f</span>(x);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref:&quot;</span> &lt;&lt; &amp;ref &lt;&lt; endl; <span class="comment">// &amp;x 与 &amp;ref有相同地址</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-C-17"><a href="#1-3-C-17" class="headerlink" title="1.3 C++ 17"></a>1.3 C++ 17</h2><h3 id="1-3-1-非类型模版参数"><a href="#1-3-1-非类型模版参数" class="headerlink" title="1.3.1 非类型模版参数"></a>1.3.1 非类型模版参数</h3><p>C++ 17支持auto作为非类型模版参数的占位符，但推导出来的类型必须是符合非类型模版参数类型要求的，否则编译会错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="number">1</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="number">3.14</span>&gt;(); <span class="comment">// 错误，浮点类型不能作为非类型模版参数</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：对于类型复杂的容器、迭代器、lambda等，auto 可以简化代码，使其更加简洁易读。如果滥用auto，可能会导致类型不明确，使代码失去可读性。</strong></p>
<h1 id="二、decltype"><a href="#二、decltype" class="headerlink" title="二、decltype"></a>二、decltype</h1><h2 id="2-1-C-11"><a href="#2-1-C-11" class="headerlink" title="2.1 C++11"></a>2.1 C++11</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在C++11以前，C++标准提供<code>typeid</code>运算符来查询变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个<code>type_info</code>的对象，typeid查询变量对应type_info。RTTI会导致运行时效率降低，且在泛型编程中，我们更需要编译时就确定类型，RTTI无法满足这样的要求。编译时类型推导的出现正是为了泛型编程，在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导。C++11提供<code>decltype</code>关键字，它在<strong>编译时</strong>推导表达式的类型，而无需计算该表达式。这对于泛型编程、模板编程以及复杂类型的推导特别有用。</p>
<p>语法：<strong>decltype( expression )</strong><br>作用：返回expression参数类型</p>
<h3 id="2-1-1-推导规则"><a href="#2-1-1-推导规则" class="headerlink" title="2.1.1 推导规则"></a>2.1.1 推导规则</h3><ol>
<li>如果 expression 参数是未加括号到标识符或类成员访问，则 decltype(expression) 推导是 <code>T</code>。如果不存在此类实体或 expression 参数命名一组重载函数，则编译器将生成错误消息。</li>
<li>如果 expression 参数是对一个函数或一个重载运算符函数的调用，则 decltype(expression) 推导是函数的返回类型</li>
<li>如果 expression 参数是将亡值，则 decltype(expression) 推导是<code>T&amp;&amp;</code>类型。 如果 expression 参数是左值，则 decltype(expression) 推导是<code>T&amp;</code></li>
<li>除去上面情况，则 decltype(expression) 推导是<code>T</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var; </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">fx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">double</span> x; &#125;;</span><br><span class="line"><span class="type">const</span> A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fx</span>());	<span class="comment">// 匹配规则2，推导为 const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(var);	<span class="comment">// 匹配规则1，推导为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x);	<span class="comment">// 匹配规则1	推导为 double</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)); <span class="comment">// 内部括号导致语句作为表达式而不是成员访问计算。匹配规则3，a-&gt;x是左值，并且a被const修饰，推导为const double&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *j;</span><br><span class="line"><span class="type">int</span> n[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i=<span class="number">0</span>); <span class="comment">// i=0不是标识符，不匹配规则1，i=0后返回i，i为左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">0</span>,i); <span class="comment">// 逗号表达式返回最右边参数，i为左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(n[<span class="number">5</span>]);<span class="comment">// 返回数组第六个元素（左值），左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(i)); <span class="comment">// 将i转化为将亡值，匹配规则3，推导为int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(i++); <span class="comment">// i++为右值，匹配规则4，推导为int</span></span><br><span class="line"><span class="keyword">decltype</span>(++i); <span class="comment">// ++i为左值，匹配规则3，推导为int&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-CV限定符推导"><a href="#2-1-2-CV限定符推导" class="headerlink" title="2.1.2 CV限定符推导"></a>2.1.2 CV限定符推导</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; CV 限定符（CV-qualifiers）指的是 const 和 volatile 关键字。它们用于限定变量、对象、类型，使得编译器对这些对象的处理方式有所不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通常情况下decltype( expression )推导的类型会同步expression的CV限定符。</span></span><br><span class="line"><span class="comment">   但如果expression是未加括号的成员变量时，父对象表达式的CV限定符会被忽略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i); <span class="comment">// 推导为const int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> A* obj= <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// 使用const修饰</span></span><br><span class="line"><span class="keyword">decltype</span>(obj-&gt;x); <span class="comment">// 匹配规则1，推导为int,const属性会忽略</span></span><br><span class="line"><span class="keyword">decltype</span>((obj-&gt;x)); <span class="comment">// 匹配规则3,推导为const int&amp;, const属性不会被忽略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-示例"><a href="#2-1-3-示例" class="headerlink" title="2.1.3 示例"></a>2.1.3 示例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在日常中我们经常会用求和函数，如果指定了函数形参类型则不够通用，下面使用模版实现一个通用求和函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11并不支持auto占位的函数返回类型进行推导，需要结合后置返回类型上的decltype说明符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14支持auto占位的函数返回类型进行推导，代码可简写为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个示例又会让人产生疑问，C++14中decltype的作用似乎又被auto取代了，但并不是，使用auto占位的函数返回类型推导时，如果期望返回类型是引用，但auto占位只能返回值类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下列代码在C++14 中测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">return_ref</span><span class="params">(T&amp; x)</span> <span class="comment">// 根据上文auto推导规则1，auto会删除引用限定符，推导为T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; -&gt; <span class="keyword">decltype</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">return_ref</span><span class="params">(T&amp; x)</span> <span class="comment">// 根据decltype推导规则3，x为左值，推导为T&amp;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-C-14"><a href="#2-2-C-14" class="headerlink" title="2.2 C++ 14"></a>2.2 C++ 14</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在C++14中，支持使用<code>decltype(auto)</code> 来进行类型推导，它实质是将表达式代入到<code>auto</code>然后再用<code>decltype</code>规则进行推导。注意<code>decltype(auto)</code>必须单独声明，不能结合指针、引用以及CV限定符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a1 = i;           <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a2 = i; <span class="comment">// 即decltype(i),推导类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a3 = (i);           <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a4 = (i); <span class="comment">// 即decltype((i)),推导类型为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a5 = <span class="built_in">f</span>();           <span class="comment">// auto会删除引用，推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a6 = <span class="built_in">f</span>(); <span class="comment">// 即decltype(f()),根据decltype推导规则2和3，推导类型为int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a7 = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 推导类型为 initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a8=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;; <span class="comment">// 编译错误，&#123;1,2&#125;不是表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *a9 = &amp;i; <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) *a10 = &amp;i; <span class="comment">// 编译错误,decltype(auto)必须单独声明</span></span><br></pre></td></tr></table></figure>
<p>在2.1.3示例中如果使用auto占位函数返回类型进行推导，如果期望返回值是引用需要结合后置返回类型上的decltype说明符，有了<code>decltype(auto)</code>后代码可简写为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">return_ref</span><span class="params">(T &amp;x)</span> <span class="comment">// 返回类型为T&amp;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-C-17"><a href="#2-3-C-17" class="headerlink" title="2.3 C++ 17"></a>2.3 C++ 17</h2><p>C++ 17支持<code>decltype(auto)</code>作为非类型模版参数的占位符，但推导出来的类型必须是符合非类型模版参数类型要求的，否则编译会错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>) N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>&lt;x&gt;(); <span class="comment">// 编译错误，x不是常量</span></span><br><span class="line"><span class="built_in">f</span>&lt;y&gt;(); <span class="comment">// 正确，使用const修饰，y具有常属性</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;(); <span class="comment">// 正确, &#x27;a&#x27;为常量</span></span><br></pre></td></tr></table></figure>
<h1 id="三、函数返回类型后置-C-11"><a href="#三、函数返回类型后置-C-11" class="headerlink" title="三、函数返回类型后置(C++ 11)"></a>三、函数返回类型后置(C++ 11)</h1><p><strong>C++ 11</strong>支持函数返回类型后置，使用<code>auto</code>在返回类型位置进行占位，表示“返回类型将会稍后引出或指定”，<code>-&gt;</code>后才是真正返回类型。</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun</span><span class="params">(arg...)</span> -&gt; ret_type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-配合函数模版"><a href="#3-1-配合函数模版" class="headerlink" title="3.1 配合函数模版"></a>3.1 配合函数模版</h2><p>在C++ 11以前，如果有下面这个函数模版，那么函数返回类型应该写什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">??? <span class="built_in">sum</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能一开始就想到使用<code>decltype</code>去推导x+y的类型，写出下面代码，但是会编译错误。因为编译器在解析返回类型时还没有解析到参数部分，对x和y类型一无所知。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x+y)</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码则可以编译通过，先将<code>nullptr</code>转换为T1和T2类型指针，然后解引用求和，<code>decltype</code>类型推导时不会真正计算表达式，所以这里求和不会有问题。不过这种写法不易懂且代码不美观。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">decltype</span>(*<span class="built_in">static_cast</span>&lt;T1 *&gt;(<span class="literal">nullptr</span>) + *<span class="built_in">static_cast</span>&lt;T2 *&gt;(<span class="literal">nullptr</span>)) <span class="built_in">sum</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++11中我们可以使用下面代码解决上面问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-返回复杂类型"><a href="#3-2-返回复杂类型" class="headerlink" title="3.2 返回复杂类型"></a>3.2 返回复杂类型</h2><p>当要返回复杂类型，例如返回函数指针类型时，使用函数返回类型后置写法比较简洁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1，编译错误</span></span><br><span class="line"><span class="built_in">int</span>(*)(<span class="type">int</span>) <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2，正确</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*ft)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ft <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f1;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3，正确</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">()</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考了谢丙堃 &lt;&lt;现代C++语言核心特性解析&gt;&gt;，在此先表示感谢，如涉及版权问题，版权所有为原作者。</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
        <tag>C++ 11</tag>
        <tag>C++ 14</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 =default与=delete</title>
    <url>/C-default%E4%B8%8E-delete.html</url>
    <content><![CDATA[<h1 id="1-缺乏控制的特殊成员函数"><a href="#1-缺乏控制的特殊成员函数" class="headerlink" title="1. 缺乏控制的特殊成员函数"></a>1. 缺乏控制的特殊成员函数</h1><p>&emsp;C++中，如果没有显式定义某些特殊成员函数时，编译器会自动为类生成这些成员函数。例如：默认构造函数、析构函数、拷贝构造函数、赋值运算符重载函数等，这个特性让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1; <span class="comment">// 调用编译器自动生成的构造函数</span></span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用编译器自动生成的拷贝构造函数</span></span><br><span class="line">	p2 = p1; <span class="comment">//  调用编译器自动生成的赋值运算符重载函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; <span class="comment">// 调用编译器自动生成的析构函数</span></span><br></pre></td></tr></table></figure>
<p>当显式定义这些成员函数时，编译器不会自动生成，但这会在某些场景下带来问题。例如：我们想在定义Point对象时对_x、_y初始化，于是我们自己写一个构造函数，但代码中如有使用之前编译器生成默认构造函数则会编译失败。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1; <span class="comment">// 错误，显式定义了形参数量为2的构造函数，编译器不会生成默认构造函数</span></span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果想编写一个禁止复制操作的类，在C++11之前只能将拷贝构造函数与赋值运算符重载函数声明为<br><code>private</code>并且不实现该函数。但是这种方式并不完美。如果某个类或函数是这个类的友元，那么可以访问该类私有的拷贝构造（赋值）函数，但是我们并没有实现这个函数，程序最后会在链接阶段报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p);</span><br><span class="line"></span><br><span class="line">	Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在C++11之前程序员不能显式控制这些特殊成员函数的生成，而编译器对是否生成这些特殊成员函数有一套比较复杂的规则，所以造成了很大的不便</strong>。</p>
<h1 id="2-显式默认和显式删除"><a href="#2-显式默认和显式删除" class="headerlink" title="2. 显式默认和显式删除"></a>2. 显式默认和显式删除</h1><p>&emsp;<strong>C++11</strong>标准提供了一种方法告诉编译器是否生成或删除对应的默认成员函数。，我们将这种方法叫作显式默认和显式删除。显式默认和显式删除的语法非常简单，只需要在声明函数的尾部添加<code>=default</code>和<code>=delete</code>。</p>
<p>说明： <code>=default</code>只能适用于类的特殊成员函数，<code>=delete</code>可以适用于任何函数。因为类的特殊成员函数是明确做某事的，所以编译器能够帮你实现。但是对于普通函数来说，编译器不知道你这个函数要干嘛，所以不能够帮你实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>() = <span class="keyword">default</span>; <span class="comment">// 生成默认构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) = <span class="keyword">delete</span>; <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;p) = <span class="keyword">delete</span>; <span class="comment">// 删除赋值运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point p1; <span class="comment">// 正确，调用编译器生成的默认构造函数</span></span><br><span class="line">	<span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 正确，调用Point(int x, int y)构造函数</span></span><br><span class="line">	<span class="function">Point <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，拷贝构造函数已被删除</span></span><br><span class="line">	p1 = p2; <span class="comment">// 错误，赋值运算符重载函数已被删除</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-特殊类设计"><a href="#3-特殊类设计" class="headerlink" title="3. 特殊类设计"></a>3. 特殊类设计</h1><h2 id="3-1-禁止类对象在堆上分配"><a href="#3-1-禁止类对象在堆上分配" class="headerlink" title="3.1 禁止类对象在堆上分配"></a>3.1 禁止类对象在堆上分配</h2><p>如果想一个类的使用者只能通过局部变量、静态变量或者全局变量的方式创建对象，而不允许使用<code>new</code>运算符或<code>new [ ]</code>运算符在堆上开辟空间，可以将下列成员函数显式删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-限制类对象在堆上分配"><a href="#3-2-限制类对象在堆上分配" class="headerlink" title="3.2 限制类对象在堆上分配"></a>3.2 限制类对象在堆上分配</h2><p>如果想一个类的使用者只能通过<code>new</code>运算符或<code>new [ ]</code>运算符在堆上开辟空间，可以将类的析构函数显式删除，但通过<code>new</code>运算符或<code>new [ ]</code>运算符创建的对象也不能调用<code>delete</code>或<code> delete[]</code>销毁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Point</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ lambda</title>
    <url>/C-lambda.html</url>
    <content><![CDATA[<h1 id="一、lambda是什么"><a href="#一、lambda是什么" class="headerlink" title="一、lambda是什么"></a>一、lambda是什么</h1><p>在 C++ 11 及更高版本中，Lambda 表达式（通常称为 Lambda）用来定义匿名函数对象，用来作为参数传递给算法或者作为匿名函数进行调用，使得代码更加灵活简洁。</p>
<span id="more"></span>

<h1 id="二、lambda语法"><a href="#二、lambda语法" class="headerlink" title="二、lambda语法"></a>二、lambda语法</h1><p>lambda语法组成：</p>
<p><code>[capture-list] (parameters) mutable -&gt; return-type &#123; statement &#125;</code></p>
<img src="C-lambda/lambda语法.png" alt="lambda语法"/>

<h2 id="2-1-capture-list"><a href="#2-1-capture-list" class="headerlink" title="2.1 capture-list"></a>2.1 capture-list</h2><p><strong>capture-list</strong>可以把上下文变量以值或引用的方式捕获，在<strong>statement</strong>中直接使用，若<strong>capture-list</strong>为空，则不捕获任何变量。</p>
<ul>
<li><p>[var] :   表示值传递方式捕捉变量</p>
</li>
<li><p>[&#x3D;]  :    表示值传递方式捕获所有父作用域中的变量，包括this </p>
</li>
<li><p>[&amp;var] : 表示引用传递捕捉变量var</p>
</li>
<li><p>[&amp;] :      表示引用传递捕捉所有父作用域中的变量，包括this</p>
</li>
<li><p>[this] :  表示值传递方式捕捉当前的this指针</p>
</li>
</ul>
<p>说明:<br> a. 父作用域指包含lambda函数的语句块<br> b. 语法上捕捉列表可由多个捕捉项组成，并以逗号分割<br> c. 捕捉列表不允许变量重复捕获<br> d. 引用捕获可用于修改外部变量，而值捕获却不能实现此操作（<strong>mutable</strong> 允许修改副本，而不能修改原始变量）<br> e. 在块作用域以外的lambda捕捉列表必须为空<br> f. 引用捕获引入生存期依赖项，而值捕获却没有生存期依赖项<br> g. lambda表达式之间不能相互赋值，哪怕看起来类型一样，因为生成的lambda类名不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> fun = [x]&#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，块作用域以外的lambda捕捉列表必须为空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值来捕获某个变量</span></span><br><span class="line">  <span class="keyword">auto</span> func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值来捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按引用来捕获某个变量</span></span><br><span class="line">  <span class="keyword">auto</span> func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func3</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按引用来捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func4</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 混合捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func5 = [&amp;,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func5</span>();</span><br><span class="line">  <span class="keyword">auto</span> func6 = [=,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func6</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> func6 = [&amp;,&amp;b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，&amp;已经引用捕捉作用域所有变量，不能重复对b变量进行引用捕捉</span></span><br><span class="line">  <span class="keyword">auto</span> func7 = [=,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，与上类似</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> func8 = [=] &#123; </span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 错误，按值捕获不能修改</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> func8 = [=] <span class="keyword">mutable</span>&#123; </span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 正确，但是a只是外部a的值拷贝，对a对修改并不影响外部a变量</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-parameters"><a href="#2-2-parameters" class="headerlink" title="2.2 parameters"></a>2.2 parameters</h2><p>参数列表是可选的，它在大多数方面类似于函数的参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun1 = [] (<span class="type">int</span> first, <span class="type">int</span> second)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = []&#123; std::cout &lt;&lt; <span class="string">&quot;Hello Worl&quot;</span> &lt;&lt; std::endl;&#125;;</span><br></pre></td></tr></table></figure>

<p>在 C++14 中，如果参数类型是泛型，则可以使用 <strong><code>auto</code></strong> 关键字作为类型说明符。 此关键字将告知编译器将函数调用运算符创建为模板。 参数列表中的每个 <strong><code>auto</code></strong> 实例等效于一个不同的类型参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;</span><br><span class="line">  <span class="keyword">auto</span> ret = x + y;</span><br><span class="line">  std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">func1</span>(a,b);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-mutable"><a href="#2-3-mutable" class="headerlink" title="2.3 mutable"></a>2.3 mutable</h2><p><strong>mutable</strong>为可选</p>
<p>通常Lambda 的函数调用运算符是 const-by-value，但对 <strong><code>mutable</code></strong> 关键字的使用可将其取消。它不产生 mutable 数据成员。 利用 <strong><code>mutable</code></strong> 规范，Lambda 表达式的主体可以修改通过<strong>值捕获的变量</strong>。</p>
<h2 id="2-4-return-type"><a href="#2-4-return-type" class="headerlink" title="2.4 return-type"></a>2.4 return-type</h2><p><strong>return-type</strong>为可选的情况</p>
<ul>
<li><strong>statement</strong>仅一个返回语句，编译器将从返回表达式的类型推导返回类型</li>
<li><strong>statement</strong>没有返回值，编译器会将返回类型推导为 <strong>void</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i; &#125;; <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []&#123; <span class="keyword">return</span>&#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// ERROR: return type is void, deducing</span></span><br><span class="line">                                  <span class="comment">// return type from braced-init-list isn&#x27;t valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = []-&gt;vector&lt;<span class="type">int</span>&gt;&#123; <span class="keyword">return</span>&#123; <span class="number">1</span>, <span class="number">2</span>&#125;; &#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-statement"><a href="#2-5-statement" class="headerlink" title="2.5 statement"></a>2.5 statement</h2><p><strong>statement</strong>是一个复合语句。 它可以包含普通函数或成员函数体中允许的任何内容。 普通函数和 lambda 表达式的<strong>statement</strong>均可访问以下变量类型：</p>
<ul>
<li>从封闭范围捕获变量，如前所述</li>
<li>参数</li>
<li>本地声明变量</li>
<li>类数据成员（在类内部声明并且捕获 <strong><code>this</code></strong> 时）</li>
<li>具有静态存储持续时间的任何变量（例如，全局变量）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  			<span class="comment">/* 可以在lambda 表达式体中使用具有静态持续存储时间的变量 */</span></span><br><span class="line">        <span class="keyword">auto</span> f = []&#123;</span><br><span class="line">                i = <span class="number">3</span>; <span class="comment">// 访问的就是全局变量i</span></span><br><span class="line">                j = <span class="number">4</span>; <span class="comment">// 访问的就是静态全局变量j</span></span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::cout &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">  			std::cout &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line">  			std::cout &lt;&lt; j &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line">        </span><br><span class="line">  			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、lambda与函数对象"><a href="#三、lambda与函数对象" class="headerlink" title="三、lambda与函数对象"></a>三、lambda与函数对象</h1><p>​		在<strong>lambda</strong>出现之前，编写代码有时候需要用到函数指针或函数对象。它们各有利弊，例如：函数指针具有最低的语法开销，但不保持范围内的状态，函数对象可保持状态，但需要类定义的语法开销。</p>
<p>​		lambda 结合了函数指针和函数对象的优点并避免其缺点。 与函数对象一样，lambda 是灵活的并且可以保持状态，但与函数对象不同之处在于其简洁的语法不需要显式类定义。 使用 lambda，可以编写出比等效的函数对象代码更简洁、更不容易出错的代码。</p>
<h1 id="四、lambda表达式示例"><a href="#四、lambda表达式示例" class="headerlink" title="四、lambda表达式示例"></a>四、lambda表达式示例</h1><h2 id="4-1-编译器对lambda处理"><a href="#4-1-编译器对lambda处理" class="headerlink" title="4.1 编译器对lambda处理"></a>4.1 编译器对lambda处理</h2><p>C++ 编译器将在声明而非调用 lambda 表达式时，将表达式绑定到捕获的变量。 以下示例显示一个通过值捕获局部变量 <code>i</code> 并通过引用捕获局部变量 <code>j</code> 的 lambda 表达式。 由于 lambda 表达式通过值捕获 <code>i</code>，因此在程序后面部分中重新指派 <code>i</code> 不影响该表达式的结果。 但是，由于 lambda 表达式通过引用捕获 <code>j</code>，因此重新指派 <code>j</code> 会影响该表达式的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> f = [i, &amp;j] &#123; <span class="keyword">return</span> i + j; &#125;;</span><br><span class="line"></span><br><span class="line">   i = <span class="number">22</span>;</span><br><span class="line">   j = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 输出 47</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-lambda调用"><a href="#4-2-lambda调用" class="headerlink" title="4.2 lambda调用"></a>4.2 lambda调用</h2><p>可以立即调用 lambda 表达式，也可以将lambda作为参数传递给函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = [] (<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;(<span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 立即调用</span></span><br><span class="line">   cout &lt;&lt; n &lt;&lt; endl; <span class="comment">// 输出: 9</span></span><br><span class="line">  </span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; numbers&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line">   <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::const_iterator result = <span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), </span><br><span class="line">                                                      numbers.<span class="built_in">end</span>(),</span><br><span class="line">                                                      [](<span class="type">int</span> n) &#123; </span><br><span class="line">                                                      <span class="built_in">return</span> (n % <span class="number">2</span>) == <span class="number">0</span>; &#125;); <span class="comment">// 作为函数参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出: The first even number in the list is 8.</span></span><br><span class="line">    <span class="keyword">if</span> (result != numbers.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The first even number in the list is &quot;</span> &lt;&lt; *result &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The list contains no even numbers.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-嵌套lambda"><a href="#4-3-嵌套lambda" class="headerlink" title="4.3 嵌套lambda"></a>4.3 嵌套lambda</h2><p>可以将 lambda 表达式嵌套在另一个中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> timestwoplusthree = [](<span class="type">int</span> x) &#123; </span><br><span class="line">    		<span class="keyword">return</span> [](<span class="type">int</span> y) &#123; </span><br><span class="line">          	<span class="keyword">return</span> y * <span class="number">2</span>; </span><br><span class="line">        &#125;(x) + <span class="number">3</span>; </span><br><span class="line">    &#125;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; timestwoplusthree &lt;&lt; endl;  <span class="comment">// 输出: 13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、lambda底层实现"><a href="#五、lambda底层实现" class="headerlink" title="五、lambda底层实现"></a>五、lambda底层实现</h1><p>lambda表达式本质是编译器将其翻译成一个类，并重载 operator()来实现。</p>
<p>lambda的各个部分和类的各个部分对应关系:</p>
<ul>
<li>capture-list &lt;-&gt;  类中private成员</li>
<li>parameters &lt;-&gt; 类中operator()成员函数的形参列表</li>
<li>mutable &lt;-&gt; 类成员函数 operator() 的const属性 (只有在捕获列表捕获的参数不含有引用捕获的情况下才会生效)</li>
<li>return-type &lt;-&gt; 类成员函数 operator() 的返回类型</li>
<li>statement &lt;-&gt; 类成员函数 operator() 的函数体</li>
</ul>
<p>说明：编译器生成的lambda类型一般为<code>lambda_ + uuid</code> ，确保类名是唯一的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Date = std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  Date birthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Person&gt; peoples&#123;&#123;<span class="string">&quot;Marie Curie&quot;</span>, <span class="string">&quot;1867-11-7&quot;</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;Albert Einstein&quot;</span>, <span class="string">&quot;1879-3-14&quot;</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;Johann Carl Friedrich Gauß&quot;</span>, <span class="string">&quot;1777-4-30&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPeopleNoLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 按照姓名排序</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ByName</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::<span class="built_in">sort</span>(peoples.<span class="built_in">begin</span>(), peoples.<span class="built_in">end</span>(), ByName&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPeopleWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(peoples.<span class="built_in">begin</span>(), peoples.<span class="built_in">end</span>(), [](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译器会将lambda转化为 */</span></span><br><span class="line">[](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_1</span> <span class="comment">/* 不要在意名字 */</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    a.name &lt; b.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __lambda_1() = <span class="keyword">delete</span>; <span class="comment">// 没有默认构造函数</span></span><br><span class="line">  __lambda_1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __lambda_1&amp;) = <span class="keyword">delete</span>; <span class="comment">// 不能赋值</span></span><br><span class="line">&#125;;</span><br><span class="line">__lambda_1(); <span class="comment">// 对象实例编译器自动创建的，所以不会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="5-1-变量捕获"><a href="#5-1-变量捕获" class="headerlink" title="5.1 变量捕获"></a>5.1 变量捕获</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传值捕获</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [=] &#123;</span><br><span class="line">  <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译器会把上面的lambda表达式代码转为：*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span> i, <span class="type">int</span> j): __i(i), __j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> __i;</span><br><span class="line">  <span class="type">int</span> __j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">__lambda2 <span class="title">f</span><span class="params">(i,j)</span></span>;</span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;] &#123;</span><br><span class="line">  <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br><span class="line">lambda 表达式会转为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span>&amp; i, <span class="type">int</span>&amp; j): __i(i), __j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="comment">// 没有const修饰</span></span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>&amp; __i;</span><br><span class="line">  <span class="type">int</span>&amp; __j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">__lambda2 <span class="title">f</span><span class="params">(i,j)</span></span>;</span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 捕获：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callAsync</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="comment">// 可以使用 X 类里的成员</span></span><br><span class="line">      std::<span class="built_in">print</span>(<span class="string">&quot;X::i=&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">编译器把 lambda 转为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__lambda_3</span> &#123;</span><br><span class="line">      __lambda_3(X* _this): __this(_this) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">print</span>(<span class="string">&quot;X::i=&#123;&#125;&quot;</span>, __this-&gt;i);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      X* __this;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">callAsync</span>(__lambda_3(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ namespace</title>
    <url>/C-namespace.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、什么是-namespace"><a href="#一、什么是-namespace" class="headerlink" title="一、什么是 namespace"></a>一、什么是 namespace</h1><h2 id="1-1-C语言标识符作用域的缺陷"><a href="#1-1-C语言标识符作用域的缺陷" class="headerlink" title="1.1 C语言标识符作用域的缺陷"></a>1.1 C语言标识符作用域的缺陷</h2><p>&emsp;在C语言中因为项目需要会定义各种全局变量、函数等，我们也会调用C语言标准库提供给我们的各种函数，这将会导致我们变量名、函数名与标准库中的发生命名冲突。</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rand = <span class="number">10</span>; <span class="comment">// 错误，与库函数rand命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f42b4dc204ff120665793c2b06796979.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-2-namespace作用"><a href="#1-2-namespace作用" class="headerlink" title="1.2 namespace作用"></a>1.2 namespace作用</h2><p>&emsp;在C++中通过<code>namespace</code>来防止命名冲突，<code>namespace</code>相当一件隐身衣，在<code>namespace</code>中的变量、函数、类在<code>namespace</code>外面是看不到，访问不到的，相当于不存在，所以也就不会发生命名冲突。<strong>即一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</strong></p>
<h1 id="二、namespace的定义"><a href="#二、namespace的定义" class="headerlink" title="二、namespace的定义"></a>二、namespace的定义</h1><p>定义命名空间使用到<code>namespace</code>关键字，后面跟命名空间的名字，然后接一对{ }即可，{ }中即为命名<br>空间的成员。空间名字可自定义命名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-命名空间可以嵌套定义"><a href="#2-1-命名空间可以嵌套定义" class="headerlink" title="2.1 命名空间可以嵌套定义"></a>2.1 命名空间可以嵌套定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">namespace</span> kdl</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> rand = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-可定义重复的命名空间"><a href="#2-2-可定义重复的命名空间" class="headerlink" title="2.2 可定义重复的命名空间"></a>2.2 可定义重复的命名空间</h2><p>在一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间，<strong>但相同命名空间中的变量、函数、类不能重复定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// int rand = 20;  错误，相同命名空间变量名相同，编译器不知道合并哪一个rand</span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终编译器合并为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、namespace使用"><a href="#三、namespace使用" class="headerlink" title="三、namespace使用"></a>三、namespace使用</h1><h2 id="3-1-命名空间名称-作用域限定符使用"><a href="#3-1-命名空间名称-作用域限定符使用" class="headerlink" title="3.1 命名空间名称+作用域限定符使用"></a>3.1 命名空间名称+作用域限定符使用</h2><p>语法： <code>空间名称::标识符名</code><br>相当于告诉编译器去哪一个命名空间中找哪一个对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">namespace</span> kdl</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">20</span>; </span><br><span class="line">		<span class="type">int</span> z = <span class="number">100</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kxl::rand); <span class="comment">// kxl 为命名空间名称，:: 为作用域限定符， rand 为变量名</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kxl::kdl::x); <span class="comment">// 访问kxl命名空间中的kdl里面的x变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-using将命名空间中成员引入"><a href="#3-2-using将命名空间中成员引入" class="headerlink" title="3.2 using将命名空间中成员引入"></a>3.2 using将命名空间中成员引入</h2><p>如果空间中某个对象经常使用，用3.1的方法比较繁琐，可以使用<code>using</code>关键字将空间中某个对象引入，即这个对象不隐身了，作用域为全局作用域<br>语法： <code>using    空间名称::标识符名;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> kxl::x;</span><br><span class="line"><span class="comment">// using kxl::rand;  不要将rand这样引入，否则rand和库函数rand发生命名冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-使用using-namespace将整个空间成员引入"><a href="#3-3-使用using-namespace将整个空间成员引入" class="headerlink" title="3.3 使用using namespace将整个空间成员引入"></a>3.3 使用using namespace将整个空间成员引入</h2><p> 使用using namespace将整个空间成员引入，<strong>即隐身衣失效了，空间中所有对象的作用域都是全局作用域，可以直接访问</strong>，但是与C++中引入命名空间初衷相矛盾，一般不建议这样用</p>
<p>语法：<code>using namespce 空间名称;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl <span class="comment">// kxl 为空间名字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> kxl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">// x 相当于正常定义的全局变量，可以直接访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-命名空间别名"><a href="#3-4-命名空间别名" class="headerlink" title="3.4 命名空间别名"></a>3.4 命名空间别名</h2><p>命名空间别名允许为现有的命名空间指定更短或更易记的名称。这样可以简化代码，特别是在使用长命名空间名字时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my_namespace &#123;</span><br><span class="line">    <span class="keyword">namespace</span> sub_namespace &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Hello from SubNamespace!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建别名</span></span><br><span class="line"><span class="keyword">namespace</span> alias = my_namespace::sub_namespace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用别名调用函数</span></span><br><span class="line">    alias::<span class="built_in">hello</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="四、C-11-C-20"><a href="#四、C-11-C-20" class="headerlink" title="四、C++ 11 ~ C++ 20"></a>四、C++ 11 ~ C++ 20</h1><h2 id="4-1-C-11-内联命名空间"><a href="#4-1-C-11-内联命名空间" class="headerlink" title="4.1 C++ 11 内联命名空间"></a>4.1 C++ 11 内联命名空间</h2><p>  内联命名空间（Inline Namespace）是 C++11 中的一个特性，它允许在命名空间中嵌套另一个命名空间，并且将其内容直接导出到外部命名空间中，即内联命名空间的成员会被视为父命名空间的成员。</p>
<p>语法： <code>inline 空间名</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以将内联命名空间用作版本控制机制，以管理对库的公共接口的更改。 例如，可以创建单个父命名空间，并将接口的每个版本封装到嵌套在父命名空间内的其自己的命名空间中。 保留最新或首选的版本的命名空间限定为内联，并因此以父命名空间的直接成员的形式公开。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> v1</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;v1 version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> v2 <span class="comment">// v2 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;v2 version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test::v1::<span class="built_in">Func</span>(); <span class="comment">// 输出: v1 version </span></span><br><span class="line">Test::<span class="built_in">Func</span>(); <span class="comment">// 输出: v2 version </span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-C-17-嵌套命名空间简洁写法"><a href="#4-2-C-17-嵌套命名空间简洁写法" class="headerlink" title="4.2 C++ 17 嵌套命名空间简洁写法"></a>4.2 C++ 17 嵌套命名空间简洁写法</h2><p>C++17 允许使用简洁写法描述嵌套的命名空间，可以更清晰地表示出命名空间之间的逻辑关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::B::C <span class="comment">// C++ 17</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码等同于:</span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> B</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-C-20"><a href="#4-3-C-20" class="headerlink" title="4.3 C++ 20"></a>4.3 C++ 20</h2><p>C++ 20支持简洁定义内联命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A::<span class="keyword">inline</span> B::C <span class="comment">// C++ 20支持，C++ 17不支持</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面代码等同于:</span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> B</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
        <tag>C++ 20</tag>
        <tag>C++ 11</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 函数重载</title>
    <url>/C-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
前言：自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被重载了。

<h1 id="一、函数重载"><a href="#一、函数重载" class="headerlink" title="一、函数重载"></a>一、函数重载</h1><h2 id="1-1-函数重载是什么"><a href="#1-1-函数重载是什么" class="headerlink" title="1.1 函数重载是什么"></a>1.1 函数重载是什么</h2><p>&emsp;C++允许在<strong>同一作用域</strong>中声明几个功能类似的<strong>同名函数</strong>，这些同名函数的<strong>形参列表必须不同(参数个数 或 参数类型 或 参数顺序)</strong>，常用来处理功能类似数据类型不同的问题。C++编译器会根据传入函数参数类型、参数个数、参数顺序调用相对应的重载函数。</p>
<span id="more"></span>

<h2 id="1-2-函数重载条件"><a href="#1-2-函数重载条件" class="headerlink" title="1.2 函数重载条件"></a>1.2 函数重载条件</h2><p><strong>满足下面条件之一都可以构成函数重载，注意：函数返回值类型不同不构成函数重载</strong></p>
<h3 id="1-2-1-函数形参个数不同"><a href="#1-2-1-函数形参个数不同" class="headerlink" title="1.2.1 函数形参个数不同"></a>1.2.1 函数形参个数不同</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-函数形参类型不同"><a href="#1-2-2-函数形参类型不同" class="headerlink" title="1.2.2 函数形参类型不同"></a>1.2.2 函数形参类型不同</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于类的非静态成员函数，使用<code>const</code>修饰也构成函数重载，因为函数隐藏的<code>this</code>参数类型不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="comment">// this类型 A* const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">// // this类型 const A* const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show() const&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-函数形参顺序不同"><a href="#1-2-3-函数形参顺序不同" class="headerlink" title="1.2.3 函数形参顺序不同"></a>1.2.3 函数形参顺序不同</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >下面这种不算形参顺序不同</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、函数重载原理"><a href="#二、函数重载原理" class="headerlink" title="二、函数重载原理"></a>二、函数重载原理</h1><p>C语言或C++编译器在编译过程中使用<code>Name Mangling</code>即名字修饰技术对函数名进行修饰后生成<strong>新的内部函数名</strong>，<strong>C&#x2F;C++标准没有统一名字修饰规则，因此经过不同编译器对函数名修饰后会产生不同风格的内部函数名</strong></p>
<p>在编译阶段：将预编译后的文件编译为汇编代码 ，并会会进行<strong>符号汇总</strong>（汇总全局符号，如全局变量、函数名)，<strong>对函数名会用<code>Name Mangling</code>进行修饰</strong></p>
<p>汇编阶段：把汇编代码转换为机器指令（二进制指令）的目标文件，形成符号表，<strong>符号表中函数名为修饰后新的内部函数名</strong></p>
<p>链接阶段：将多个目标文件和函数库链接为可执行程序，若一个目标文件调用一个函数，该函数不是在此文件中定义，将会去其他目标文件的<strong>符号表中查找函数名对应函数地址并调用</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tqbDE2Ny9hcnRpY2xlL2RldGFpbHMvMTI0MTU3MDc3">详细细节可参考本博客<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e848652a7c56a4c871fa5a7c9c3dc36.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-1-C语言不支持函数重载原因"><a href="#2-1-C语言不支持函数重载原因" class="headerlink" title="2.1 C语言不支持函数重载原因"></a>2.1 C语言不支持函数重载原因</h2><p>由于不同C语言编译器名字修饰规则不同，这里采用gcc编译器测试<br><img src="https://i-blog.csdnimg.cn/blog_migrate/231fe64000c795eca760f69d29d75bc6.png#pic_center" alt="在这里插入图片描述"><br><strong>使用gcc编译器编译提醒函数add重复定义发生了冲突，编译失败</strong></p>
<p><font color=#0000FF >gcc编译器的名字修饰规则：修饰后内部新函数名与原来函数名一样</font></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/32a2af6efce0561e3ce13cbe3f5a2128.png#pic_center" alt="在这里插入图片描述"><br><strong>1.由于修饰后函数名与原来函数名一样，所以在编译阶段进行符号汇总的时候两个函数都叫<code>add</code>，发生了冲突，无法继续进行下去</strong></p>
<p><strong>2.就算编译阶段强行符号汇总过去，那么链接阶段生成的符号表里面会有两个<code>add</code>函数，并且每个函数对应函数地址不同，当其他目标文件需要用到add函数时不知道填充哪个函数地址</strong></p>
<h2 id="2-1-C-支持函数重载原因"><a href="#2-1-C-支持函数重载原因" class="headerlink" title="2.1 C++支持函数重载原因"></a>2.1 C++支持函数重载原因</h2><p><strong>由于不同C++编译器名字修饰规则不同，这里采用g++编译器测试</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/5946394648e65f2382ae231f4737fb28.png#pic_center" alt="在这里插入图片描述"><br><font color=#0000FF >g++编译器的名字修饰规则：_Z+函数名长度+函数名+形参类型的首字母 </font><br><img src="https://i-blog.csdnimg.cn/blog_migrate/c1b06ac0ded43677100735d1bfee645f.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/617d2c2e58ceac33ff78b73188547cd3.png#pic_center" alt="在这里插入图片描述"><br><strong>1. 根据名字修饰规则，虽然多个函数的名字相同，但是它们的形参个数、形参类型、形参顺序不一样，修饰后的内部函数名也就不相同，在编译阶段的符号汇总及汇编阶段的符号表中，内部函数名不相同，不会发生冲突</strong></p>
<p><strong>2. 当某个目标文件需要调用对应函数时，只需要到对应函数所在目标文件的符号表中查找内部函数名对应函数地址即可</strong></p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 列表初始化</title>
    <url>/C-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content><![CDATA[<h1 id="一、列表初始化"><a href="#一、列表初始化" class="headerlink" title="一、列表初始化"></a>一、列表初始化</h1><h2 id="1-1-出现原因"><a href="#1-1-出现原因" class="headerlink" title="1.1 出现原因"></a>1.1 出现原因</h2><p>在<strong>C++98&#x2F;03</strong> 中的对象初始化方法有很多种方法，这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于数组的初始化</span></span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	基于POD(plain old data)类型,这里的先调用构造函数传入参数1构造一个A类型匿名对象，然后调用拷贝构造函数传入匿名对象参数构造对象a1,不过编译器会进行优化，实际只调用一次构造函数。</span></span><br><span class="line"><span class="comment">	说明：当构造函数被explicit修饰，或者拷贝构造函数为private时，a1会失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; a1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于STL中容器不能想数组那样进行初始化，只能一个一个插入</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-统一的初始化"><a href="#1-2-统一的初始化" class="headerlink" title="1.2 统一的初始化"></a>1.2 统一的初始化</h2><p>C++11标准引入了<strong>列表初始化</strong>，它使用大括号{}对任意类型对象进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置类型初始化</span></span><br><span class="line"><span class="type">int</span> i1&#123;<span class="number">10</span>&#125;  &lt;=&gt; <span class="type">int</span> i0 = &#123;<span class="number">10</span>&#125; &lt;=&gt; <span class="type">int</span> i2 =&#123;<span class="number">10</span>&#125; &lt;=&gt; <span class="type">int</span> i3 =(<span class="number">10</span>) &lt;=&gt; <span class="type">int</span> i4 = <span class="built_in">int</span>(<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt;=&gt; <span class="type">int</span> arr2[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="type">int</span> arr3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态数组，在C++98/03中不支持</span></span><br><span class="line"><span class="type">int</span>* arr4 = <span class="keyword">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL容器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt;=&gt;  vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-自定义类型初始化"><a href="#1-2-1-自定义类型初始化" class="headerlink" title="1.2.1 自定义类型初始化"></a>1.2.1 自定义类型初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Point</span>(Point &amp;obj) : _x(obj._x), _y(obj._y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p1&#123;<span class="number">1</span>,<span class="number">2</span>&#125; &lt;=&gt; Point <span class="built_in">p2</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 直接调用构造函数</span></span><br><span class="line">Point p2 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">// 先调用构造函数，再调用拷贝构造，编译器可能会优化为只调用一次构造函数  </span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-initializer-list"><a href="#1-3-initializer-list" class="headerlink" title="1.3 initializer-list"></a>1.3 initializer-list</h2><p><code>std::initialzer-list</code>是C++11引入的轻量级类模板，只提供begin、end以及size成员函数。编译器将{ }内的数据存放到<code>std::array</code>中，并构建<code>initializer_list</code> 对象引用这个<code>array</code>对象中的元素，但并不包含它们，拷贝一个 <code>initializer_list</code> 对象会生成另一个引用相同底层元素的对象，而不是创建它们的新副本，即浅拷贝。</p>
<p>C++11起，STL容器之所以能够支持列表初始化原因在于每个容器都提供了一个形参为<code>initializer_list</code>的构造函数。编译器会先构造一个<code>initializer_list</code>对象，然后调用对应容器中形参为<code>initializer_list</code>的构造函数。这个构造函数的逻辑非常简单，它们只需要调用<code>initializer_list</code>对象的begin和end 函数，循环对本对象进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;Point&gt; v2&#123;p1,p2&#125; &lt;=&gt; vector&lt;Point&gt; v3&#123;<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：自定义数据类型如果需要实现该功能，需要自己实现参数为<code>initializer-list</code> 的构造函数</strong></p>
<h3 id="1-3-1-initializer-list其它用途"><a href="#1-3-1-initializer-list其它用途" class="headerlink" title="1.3.1 initializer-list其它用途"></a>1.3.1 initializer-list其它用途</h3><p><code>initializer-list</code>不仅可以用于自定义类型的列表初始化，也可以用于传递相同类型数据的集合，例如作为函数的形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(&#123;&#125;);<span class="comment">//传递一个空集</span></span><br><span class="line">	<span class="built_in">print</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);<span class="comment">//传递int类型的集合</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><h3 id="1-4-1-Narrowing-conversions-缩窄转换"><a href="#1-4-1-Narrowing-conversions-缩窄转换" class="headerlink" title="1.4.1 Narrowing conversions(缩窄转换)"></a>1.4.1 Narrowing conversions(缩窄转换)</h3><p>在 C++ 中，缩窄转换是一种不安全的类型转换，因为目标类型可能无法保存源类型的所有值。缩窄转换是在编写代码中稍不留意就会出现，而且它的出现并不一定会引发错误，甚至有可能连警告都没有，所以有时候容易被人们忽略，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2025</span>;</span><br><span class="line"><span class="type">char</span> c = x; <span class="comment">// 2015 超过了char类型范围，会导致溢出，c的值不可预测</span></span><br></pre></td></tr></table></figure>

<p>C++标准规定下列情况属于缩窄转换：</p>
<ul>
<li>从浮点类型转换整数类型</li>
<li>从long double转换到double或float，或从double转换 到float，除非转换的值是<code>constexpr</code>并且在目标类型的范围内</li>
<li>从整数类型转换到浮点类型，除非转换的值是<code>constexpr</code>并且在目标类型的范围内</li>
<li>从整数类型转换为另一种整数类型，该整数类型不能表示原始类型的所有值，除非转换的值是 constexpr 并且其值可以精确存储在目标类型中</li>
</ul>
<p><strong>使用列表初始化，编译器对于缩窄转换会报编译错误(MSVC、clang)或警告(GCC)。</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i&#123;<span class="number">3.14</span>&#125;; <span class="comment">// 存在缩窄转换</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-列表初始化的优先级"><a href="#1-4-2-列表初始化的优先级" class="headerlink" title="1.4.2 列表初始化的优先级"></a>1.4.2 列表初始化的优先级</h3><p>列表初始化既可以支持普通的构造函数，也能够支持以<code>initializer_list</code>为形参的构造函数。如果这两种构造函数同时出现在同一个类里，<strong>以<code>initializer_list</code>为形参的构造函数优先级更高</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y) &#123; cout &lt;&lt; <span class="string">&quot;Point(int x = 0, int y = 0)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Point</span>(initializer_list&lt;<span class="type">int</span>&gt; l) &#123; cout &lt;&lt; <span class="string">&quot;Point(initializer_list&lt;int&gt; l)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 Point(int x = 0, int y = 0) 构造函数</span></span><br><span class="line">Point p2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 使用列表初始化，调用Point(initializer_list&lt;int&gt; l)构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 动态内存分配</title>
    <url>/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、new-delete"><a href="#一、new-delete" class="headerlink" title="一、new&#x2F;delete"></a>一、new&#x2F;delete</h1><h2 id="1-1-为什么需要new-delete"><a href="#1-1-为什么需要new-delete" class="headerlink" title="1.1 为什么需要new&#x2F;delete"></a>1.1 为什么需要new&#x2F;delete</h2><p>&emsp;C语言中通过<code>malloc/free</code>等函数实现动态内存管理，为什么C++中还引入<code>new/delete</code>对动态内存管理？原因在于：<code>malloc/free</code>等函数不能满足对自定义类型的对象管理要求，对象在创建时要自动调用构造函数，对象在销毁前要自动调用析构函数，由于<code>malloc/free</code>是库函数而不是运算符，编译器不能把调用构造函数和析构函数的任务强加给它们。因为C++需要一个能够完成动态内存分配和初始化工作的运算符<code>new</code>，以及一个能够完成资源释放和释放内存工作的运算符<code>delete</code>。</p>
<p><strong>注意：<code>new/delete</code>是运算符，而不是函数</strong></p>
<span id="more"></span>

<h2 id="1-2-new-delete对内置类型处理"><a href="#1-2-new-delete对内置类型处理" class="headerlink" title="1.2 new&#x2F;delete对内置类型处理"></a>1.2 new&#x2F;delete对内置类型处理</h2><p>&emsp;new&#x2F;delete对内置类型处理与malloc&#x2F;free对内置类型处理没有本质区别，只是用法不一样。new直接返回目标类型的指针，不需要显式类型转换，而malloc返回void*，必须显式地转换为目标类型后使用</p>
<p>用法：<br><code>类型名* 指针变量名 = new 类型名;    delete 指针变量名;</code><br><code>类型名* 指针变量名 = new 类型名[元素个数];    delete[] 指针变量名;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态开辟1个大小为int的内存空间</span></span><br><span class="line">	<span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">5</span>); <span class="comment">// 动态开辟5个大小为int的连续内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* p3 = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 动态开辟1个大小为int的内存空间</span></span><br><span class="line">	<span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态开辟5个大小为int的连续内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// 释放起始地址为p1的动态开辟内存空间</span></span><br><span class="line">	<span class="built_in">free</span>(p2);  <span class="comment">// 释放起始地址为p2的动态开辟内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p3; <span class="comment">// 释放单个元素内存空间</span></span><br><span class="line">	<span class="keyword">delete</span>[] p4; <span class="comment">// 释放连续的申请的动态内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc与new对内置类型都没有初始化，但可以<code>int* p3 = new int(1); </code>将对应空间值初始化为1</p>
<h2 id="1-3-new-delete对自定义类型处理"><a href="#1-3-new-delete对自定义类型处理" class="headerlink" title="1.3 new&#x2F;delete对自定义类型处理"></a>1.3 new&#x2F;delete对自定义类型处理</h2><p>&emsp; malloc&#x2F;free对自定义类型只会开辟&#x2F;销毁空间，并不会调用构造函数&#x2F;析构函数。new先开辟空间然后调用构造函数初始化，delete先调用析构函数释放资源然后销毁空间<br><img src="https://i-blog.csdnimg.cn/blog_migrate/db7bbb57bb33950dbded1e17f4383c96.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line">	<span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line">	<span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SeqList</span>(<span class="type">int</span> capacity = <span class="number">5</span>)</span><br><span class="line">		:_size(<span class="number">0</span>)</span><br><span class="line">		,_capacity(capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		_data = <span class="keyword">new</span>	<span class="built_in">ElemType</span>(capacity);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SeqList</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _data;</span><br><span class="line">		_data = <span class="literal">nullptr</span>;</span><br><span class="line">		_size = _capacity = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">InitSeq</span><span class="params">(<span class="type">int</span> capacity = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_data = <span class="keyword">new</span>	<span class="built_in">ElemType</span>(capacity);</span><br><span class="line">		_size = <span class="number">0</span>;</span><br><span class="line">		_capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DestorySeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> _data;</span><br><span class="line">		_data = <span class="literal">nullptr</span>;</span><br><span class="line">		_size = _capacity = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SeqList* s1 = (SeqList*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SeqList));</span><br><span class="line">	s1-&gt;<span class="built_in">InitSeq</span>(); </span><br><span class="line">	<span class="comment">// 业务处理</span></span><br><span class="line">	s1-&gt;<span class="built_in">DestorySeq</span>();</span><br><span class="line">	<span class="built_in">free</span>(s1);</span><br><span class="line"></span><br><span class="line">	SeqList* s2 = <span class="keyword">new</span> SeqList; <span class="comment">// SeqList* s2 = new SeqList(10); 调用有参构造函数</span></span><br><span class="line">	<span class="comment">// 业务处理</span></span><br><span class="line">	<span class="keyword">delete</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure>

<p>&emsp;使用malloc为自定义类型分配空间需要手动调用InitSeq函数初始化，业务处理后需要调用DestorySeq函数进行资源释放然后free释放空间，比较麻烦且容易忘记初始化及释放资源。使用new&#x2F;delete会自动调用构造函数&#x2F;析构函数帮我们进行处理</p>
<h1 id="二、new-delete-实现原理"><a href="#二、new-delete-实现原理" class="headerlink" title="二、new&#x2F;delete 实现原理"></a>二、new&#x2F;delete 实现原理</h1><p>&emsp; <code>new</code>运算符底层是调用<code> operator new</code>函数与<code>构造函数</code>实现的，<code>delete</code>运算符底层是调用<code>析构函数</code>与<code> operator delete</code>函数实现的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/de3cebb1291984fae5026806ccacc15d.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-1-operator-new函数"><a href="#2-1-operator-new函数" class="headerlink" title="2.1 operator new函数"></a>2.1 operator new函数</h2><p>operator new为库函数，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try to allocate size bytes</span></span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line">	<span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">// report no memory</span></span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">		_RAISE(nomem);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现operator new函数申请空间还是调用malloc函数实现的，申请成功返回地址，申请空间失败会抛出异常。<strong>可以发现之所以用operator new而不是直接用malloc主要是对于申请失败时抛出异常</strong></p>
<h2 id="2-2-operator-delete函数"><a href="#2-2-operator-delete函数" class="headerlink" title="2.2 operator delete函数"></a>2.2 operator delete函数</h2><p>operator delete为库函数，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_CrtMemBlockHeader* pHead;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pUserData == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	_mlock(_HEAP_LOCK); <span class="comment">/* block other threads */</span></span><br><span class="line">	__TRY</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* get a pointer to memory block header */</span></span><br><span class="line">		pHead = <span class="built_in">pHdr</span>(pUserData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* verify block type */</span></span><br><span class="line">		_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line"></span><br><span class="line">		_free_dbg(pUserData, pHead-&gt;nBlockUse);</span><br><span class="line">	</span><br><span class="line">	__FINALLY</span><br><span class="line">		_munlock(_HEAP_LOCK); <span class="comment">/* release other threads */</span></span><br><span class="line">	__END_TRY_FINALLY</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operator delete 通过调用free来释放空间的。</p>
<h2 id="2-3-new-delete对内置类型实现原理"><a href="#2-3-new-delete对内置类型实现原理" class="headerlink" title="2.3 new&#x2F;delete对内置类型实现原理"></a>2.3 new&#x2F;delete对内置类型实现原理</h2><p>&emsp;如果申请的是内置类型的空间，new和malloc，delete和free基本类似。<strong>只是new在申请空间失败时会抛异常，malloc会返回NULL</strong></p>
<h2 id="2-4-new-delete对自定义类型实现原理"><a href="#2-4-new-delete对自定义类型实现原理" class="headerlink" title="2.4 new&#x2F;delete对自定义类型实现原理"></a>2.4 new&#x2F;delete对自定义类型实现原理</h2><p>new:<br>● 先调用operator new函数为对象动态内存分配空间<br>● 然后调用构造函数对对象初始化</p>
<p>delete:<br>●  先调用析构函数释放资源<br>●  然后调用operator delete函数释放对象的空间</p>
<p>new [N]:<br>● 先调用operator new[ ]函数对对象动态内存分配空间 (operator new[ ]函数内调用operator new函数实现对N个对象空间分配)<br>●  然后调用N次构造函数对对象初始化</p>
<p>delete[ ]：<br>●  先调用N次析构函数，对N个对象释放资源<br>●  然后调用operator delete[ ]函数释放空间(operator delete[ ]函数内调用operator delete函数实现对N个对象空间释放)</p>
<h2 id="2-5-operator-new与operator-delete-函数重载"><a href="#2-5-operator-new与operator-delete-函数重载" class="headerlink" title="2.5 operator new与operator delete 函数重载"></a>2.5 operator new与operator delete 函数重载</h2><p>&emsp;有些情况下希望动态内存空间不是来源于堆而是来源内存池，以提高效率。可以在类中对operator new与operator delete函数重载。类中对象申请&#x2F;释放的是内存池空间，类外还是从堆中申请&#x2F;释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	 ListNode* _next;</span><br><span class="line">	 ListNode* _prev;</span><br><span class="line">	 <span class="type">int</span> _data;</span><br><span class="line">	 </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="type">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">		 p = <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;memory pool allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">		 <span class="keyword">return</span> p;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function">	 </span>&#123;</span><br><span class="line">		 <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">deallocate</span>((ListNode*)p, <span class="number">1</span>);</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;memory pool deallocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="三、placement-new"><a href="#三、placement-new" class="headerlink" title="三、placement-new"></a>三、placement-new</h1><p>&emsp; <strong>placement-new：在一块已分配的内存空间上调用构造函数初始化对象或对象数组</strong></p>
<p>用法：<br><code>new (place_address) type</code><br><code>new (place_address) type(initializer-list)</code><br><code>new (place_address) type[元素个数]</code></p>
<p>placement-new主要应用场景是配合内存池使用：使用一块较大的动态内存分配空间，用来构造不同类型的对象或对象数组。</p>
<p><strong>注意：placement-new构造的对象或对象数组要显式调用它们的析构函数进行资源释放，不要使用delete。因为构造起来的对象或对象数组大小并不一定等于原来申请空间大小，使用delete会造成内存泄漏或在之后释放原来申请空间出现运行时错误</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line">	<span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line">	<span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SeqList</span>(<span class="type">int</span> capacity = <span class="number">5</span>)</span><br><span class="line">		:_size(<span class="number">0</span>)</span><br><span class="line">		,_capacity(capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		_data = <span class="keyword">new</span>	<span class="built_in">ElemType</span>(capacity);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SeqList</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> _data;</span><br><span class="line">		_data = <span class="literal">nullptr</span>;</span><br><span class="line">		_size = _capacity = <span class="number">0</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	SeqList* s1 = (SeqList*)<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(SeqList)); <span class="comment">// 动态内存申请大小为SeqList的空间</span></span><br><span class="line">	<span class="keyword">new</span>(s1)SeqList; <span class="comment">// 调用SeqList的默认构造函数对起始地址为s1的对象初始化</span></span><br><span class="line">	</span><br><span class="line">	s1-&gt;~<span class="built_in">SeqList</span>(); <span class="comment">// 调用析构函数资源释放</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(s1)</span></span>; <span class="comment">// 释放动态内存分配空间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、C-C-动态内存分配对比"><a href="#四、C-C-动态内存分配对比" class="headerlink" title="四、C&#x2F;C++ 动态内存分配对比"></a>四、C&#x2F;C++ 动态内存分配对比</h1><p>&emsp;C语言中使用<code>malloc/free</code>等函数进行动态内存分配，C++中使用<code>new/delete</code>运算符进行动态内存分配.</p>
<p>相同点：<br>● 都是从堆上分配空间，需要手动释放空间</p>
<p>不同点：<br>● malloc和free是函数，new和delete是运算符<br>● 对于自定义类型，malloc&#x2F;free不会调用构造函数&#x2F;析构函数，new会调用构造函数&#x2F;析构函数<br>● malloc申请空间时，需要手动计算空间大小，new只需给类型名<br>● malloc的返回值为void*, 在使用时必须强转，new返回的是类型指针<br>● malloc申请空间失败返回NULL，new申请抛出异常</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 多态</title>
    <url>/C-%E5%A4%9A%E6%80%81.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、多态基础"><a href="#一、多态基础" class="headerlink" title="一、多态基础"></a>一、多态基础</h1><h2 id="1-1-静态编联与动态编联"><a href="#1-1-静态编联与动态编联" class="headerlink" title="1.1 静态编联与动态编联"></a>1.1 静态编联与动态编联</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area: &quot;</span> &lt;&lt; <span class="built_in">get_area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h)</span><br><span class="line">            : _width(w), _height(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _width * _height; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _width;</span><br><span class="line">    <span class="type">float</span> _height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r) : _radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _radius * _radius * <span class="number">3.14</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape &amp;sp1 = rect;</span><br><span class="line">    Shape &amp;sp2 = cir;</span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">show</span>(); <span class="comment">// 输出0</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">show</span>(); <span class="comment">// 输出0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码发现，矩形和圆求出的面积都为0，与我们预期不符合，这是为什么呢，原因在于使用静态编联。</p>
<span id="more"></span>

<p><strong>静态编联(早绑定，静态绑定) ：编译期间就决定了具体调用哪个函数体，即使没有主程序，也知道程序中各个函数体之间的调用关系。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这段代码采用的是静态编联，使用sp1调用show函数，show函数体内调用了get_area成员函数，</span></span><br><span class="line"><span class="comment">	调用非静态成员函数时编译器会传入隐藏this指针，因为this是指向Shape，</span></span><br><span class="line"><span class="comment">	所以调用Shape::get_area函数而不是Rectangle::get_area函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Shape &amp;sp1 = rect;</span><br><span class="line">sp<span class="number">1.</span><span class="built_in">show</span>();】</span><br></pre></td></tr></table></figure>

<p><strong>动态编联（晚绑定，动态绑定）：在运行期间决定具体调用哪个函数体。动态编联有多种实现方式，大多数编译器使用(虚函数和虚函数表）。</strong></p>
<h2 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h2><p>使用基类的指针或引用调用同一方法时，产生不同的行为，这是一种动态多态，大多数C++编译器通过虚函数实现。<font color=red >下文中提到的多态如没有单独说明，则都是指通过虚函数实现的动态多态。</font></p>
<p><strong>多态构成必须满足下面两个条件</strong>：</p>
<ol>
<li>必须通过基类的指针或者引用调用虚函数</li>
<li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写(override)</li>
</ol>
<h2 id="1-3-虚函数"><a href="#1-3-虚函数" class="headerlink" title="1.3 虚函数"></a>1.3 虚函数</h2><p>被<code>virtual</code>修饰的类非静态成员函数就是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//这是一个虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚函数说明:<br>• 静态成员函数、构造函数、拷贝构造函数不能是虚函数<br>• 析构函数可以是虚函数<br>• 赋值函数通常不定义为虚函数<br>• 访问控制可以任意（public、protected、private ）</p>
<h2 id="1-4-虚函数重写-override"><a href="#1-4-虚函数重写-override" class="headerlink" title="1.4 虚函数重写(override)"></a>1.4 虚函数重写(override)</h2><p>虚函数重写(override)：派生类中有一个跟基类完全相同的虚函数(函数名、返回值类、参数列表相同)。</p>
<p>说明：派生类中<code>virtual</code>关键字可以不写，但不推荐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area: &quot;</span> &lt;&lt; <span class="built_in">get_area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h)</span><br><span class="line">            : _width(w), _height(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _width * _height; &#125; <span class="comment">// 没写virtual</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _width;</span><br><span class="line">    <span class="type">float</span> _height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r) : _radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _radius * _radius * <span class="number">3.14</span>; &#125; <span class="comment">// 没写virtual</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape &amp;sp1 = rect;</span><br><span class="line">    Shape &amp;sp2 = cir;</span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">show</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">show</span>(); <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发过程中，基类与派生类可能不是同一个人写的，如果基类是虚函数，而派生类忘记写<code>virtual</code>关键字没构成多态可能带来一些不可预料问题。因此，基类是虚函数的情况下,派生类不强制需要写<code>virtual</code>关键字，具有一定安全作用。</p>
<h3 id="1-4-1-虚函数重写两个例外"><a href="#1-4-1-虚函数重写两个例外" class="headerlink" title="1.4.1 虚函数重写两个例外"></a>1.4.1 虚函数重写两个例外</h3><p><strong>虚函数重写有两个例外，一个是协变，一个是析构函数的重写，这两种也构成虚函数重写。</strong></p>
<p>协变：派生类中重写（override）基类方法时，返回类型可以是基类方法返回类型(类型必须为指针或引用)的派生类。协变可以使代码更加灵活。</p>
<p>实现协变需满足以下条件：</p>
<ul>
<li>基类中的函数必须是虚函数</li>
<li>派生类中重写的函数必须具有相同的函数签名（函数名、参数列表和常量性）。</li>
<li>派生类中重写的函数的返回类型必须是基类函数返回类型的派生类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base &amp;<span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived &amp;<span class="title">test</span><span class="params">()</span> <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived b;</span><br><span class="line">    Base &amp;ref = b;</span><br><span class="line">    ref.<span class="built_in">test</span>(); <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文中提到析构函数是可以为虚函数的，尤其是存在继承关系的时候，建议将基类析构函数定义为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Base()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Derived()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Base</span>()</span><br></pre></td></tr></table></figure>

<p>调用<code>delete p</code>时，我们本意根据指针(引用)指向的对象类型来选择对应的析构函数，但结果是根据指针(引用)的类型的来选择对应的析构函数，导致对象没有正确的析构，存在资源泄漏。有人立马想到可以将基类析构函数定义为虚函数解决这个问题，但是重写条件之一是函数名要相同。基类析构函数与派生类析构函数名明显不相同，编译器为了支持析构函数能为虚函数，对析构函数名做了特殊处理，编译后析构函数的名统一处理成destructor。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Derived()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">Derived</span>()</span><br><span class="line">~<span class="built_in">Base</span>()</span><br></pre></td></tr></table></figure>
<p>通过将基类析构函数定义为虚函数，解决继承体系中析构问题。</p>
<h2 id="1-5-override和final说明符"><a href="#1-5-override和final说明符" class="headerlink" title="1.5 override和final说明符"></a>1.5 override和final说明符</h2><p>为了兼容性，增加关键字需要十分谨慎，C++11中，新增的override与final只是特定场景下生效的说明符，并不是关键字。</p>
<h3 id="1-5-1-override"><a href="#1-5-1-override" class="headerlink" title="1.5.1 override"></a>1.5.1 override</h3><p>override说明符用于显式地声明一个派生类中的虚函数重写了基类中的虚函数。它的主要作用是提高代码的可读性和安全性，确保派生类的函数确实覆盖了基类中的虚函数。</p>
<p>使用override的好处：</p>
<p>避免拼写错误：如果你在派生类中希望重写基类的一个虚函数，但不小心拼写错误或者参数列表不匹配，编译器会报错，提示你并没有成功重写基类的函数。</p>
<p>明确意图：通过在派生类的函数后面加上 override，明确表示你的意图是要重写基类中的虚函数，这有助于代码的可读性。</p>
<p>class Base<br>{<br>public:<br>    virtual void display() const<br>    {<br>        std::cout &lt;&lt; “Base display” &lt;&lt; std::endl;<br>    }<br>};</p>
<p>class Derived : public Base<br>{<br>public:<br>    void display(int) const override &#x2F;&#x2F; 使用override关键字<br>    {<br>        std::cout &lt;&lt; “Derived display” &lt;&lt; std::endl;<br>    }<br>};</p>
<p>int main()<br>{<br>    Base *basePtr &#x3D; new Derived();<br>    basePtr-&gt;display();  &#x2F;&#x2F; 调用的是 Derived 类中的 display() 方法<br>    delete basePtr;</p>
<pre><code>return 0;
</code></pre>
<p>}<br>编译时报错：non-virtual member function marked ‘override’ hides virtual member function</p>
<h3 id="1-5-2-final"><a href="#1-5-2-final" class="headerlink" title="1.5.2 final"></a>1.5.2 final</h3><p>final说明符用于两种场景：1. 防止类被继承，如果在类声明中使用 final，则表示该类不能被进一步继承。2. 防止虚函数被重写，如果在类的虚函数声明后使用 final，则表示该虚函数不能在派生类中被重写。</p>
<p>class Base final {};</p>
<p>class Derived : public Base {}; &#x2F;&#x2F; 编译报错，Base类不能被继承</p>
<p>class Base<br>{<br>public:<br>    virtual void display() const final<br>    {<br>        std::cout &lt;&lt; “Base display” &lt;&lt; std::endl;<br>    }<br>};</p>
<p>class Derived : public Base {<br>public:<br>    &#x2F;&#x2F; 下面这段代码将会导致编译错误，因为 display() 函数是 final<br>    void display() const override<br>    {<br>        std::cout &lt;&lt; “Derived display” &lt;&lt; std::endl;<br>    }<br>};</p>
<h1 id="二、多态原理"><a href="#二、多态原理" class="headerlink" title="二、多态原理"></a>二、多态原理</h1><h2 id="2-1-虚函数表指针与虚函数表"><a href="#2-1-虚函数表指针与虚函数表" class="headerlink" title="2.1 虚函数表指针与虚函数表"></a>2.1 虚函数表指针与虚函数表</h2><p><strong>虚函数表指针(虚表指针，vfptr)</strong>：如果一个类有虚函数，这个类创建的对象中会增加一个指针，指向该对象所属类的虚函数表。在调用虚函数时，程序通过该虚函数表指针（vfptr）找到对应的虚函数表（vtable），再根据虚函数表中的条目找到并调用具体的虚函数实现。</p>
<p>说明：</p>
<ul>
<li>C++的编译器为了性能会将虚表指针存在于对象最前面的位置，通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的虚函数，在多层继承或是多重继承的情况下， 具有极高性能。</li>
<li>单一继承下对象只有一个虚表指针，多重继承&#x2F;虚拟继承情况下对象会有多个虚表指针。</li>
</ul>
<p><strong>虚函数表(虚表，vtable)</strong>：一个指针数组，存放对应虚函数地址。当一个类定义了虚函数时，编译器为该类生成一个虚表，其中每个条目对应一个虚函数地址。</p>
<p>说明：</p>
<ul>
<li>虚表在编译期间生成，编译期间虚函数的地址已经存在。</li>
<li>对象中虚表指针是在构造函数的初始化列表中完成赋值的。</li>
<li>同一类所有对象共享一个虚表。</li>
<li>继承中派生类会拷贝一份基类的虚表，如果派生类重写了某个虚函数，则用派生类虚函数地址覆盖虚表中基类函数地址。</li>
<li>派生类新增的虚函数按声明顺序尾插在虚表中。</li>
<li>派生类对象赋值给基类对象时不会拷贝虚表指针，赋值后基类对象虚表指针还是指向基类。 </li>
<li>MSVC编译器会存放<code>nullptr</code>作为虚表中最后一个元素，方便虚表遍历，其它编译器不一定存放。 </li>
<li>单一继承下一个类只有一个虚表，多重继承&#x2F;虚拟继承情况下一个类会有多个虚表。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">K</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/ec227b59e23d48ef97e96eacb33faf94.png" alt="在这里插入图片描述"></p>
<h2 id="2-2-函数调用的编译"><a href="#2-2-函数调用的编译" class="headerlink" title="2.2 函数调用的编译"></a>2.2 函数调用的编译</h2><p><strong>一个对象（变量）的静态类型就是其声明类型，在编译期间就可以确定。一个对象（变量）动态类型就是指程序执行过程中对象（指针或引用）实际所指对象的类型，只有在运行时才能确定。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">Derived derived; <span class="comment">// derived的静态与动态类型都为Derived</span></span><br><span class="line">Base * p = &amp;derived；<span class="comment">// p的静态类型为Base*，动态类型Derived*</span></span><br><span class="line">Base &amp; ref = derived；<span class="comment">// p的静态类型为Base&amp;，动态类型Derived&amp;</span></span><br></pre></td></tr></table></figure>

<p>以编译<code>p-&gt;f()</code>为例子</p>
<ol>
<li>确定p的静态类型<code>Base*</code></li>
<li>在Base类中，寻找名字为f，且参数可以匹配的函数</li>
<li>若找不到，编译错误</li>
<li>若找到，判断函数是否为virtual函数<br>a) 不是虚函数，编译为<code>Base::f(p)</code><br>b) 是虚函数，编译为<code>(*p-&gt;vfptr)[index]((void*)p, ...)</code></li>
</ol>
<p>从上面步骤可以看到，若希望<code>p-&gt;f()或 ref.f()</code>合法，<code>p/ref</code>的静态类型中必须有匹配的函数f，即使匹配的f永远不被调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base与Derived类定义参考2.1章节</span></span><br><span class="line"></span><br><span class="line">Base* p1 = <span class="keyword">new</span> Base;</span><br><span class="line">p1-&gt;<span class="built_in">F</span>(); <span class="comment">// 编译为 Base::F(p1)</span></span><br><span class="line">p1-&gt;<span class="built_in">G</span>(); <span class="comment">// 编译为 (*p1-&gt;vfptr)[1]((void*)p1)</span></span><br><span class="line">p1-&gt;<span class="built_in">K</span>(); <span class="comment">// 编译错误，K为protected，不能在类外调用</span></span><br><span class="line">p1-&gt;<span class="built_in">H</span>(); <span class="comment">// 编译错误，p1的静态类型为Base*，Base类中没有H函数</span></span><br><span class="line"></span><br><span class="line">Base* p2 = <span class="keyword">new</span> Derived;</span><br><span class="line">p2-&gt;<span class="built_in">G</span>();  <span class="comment">// 编译为 (*p2-&gt;vfptr)[1]((void*)p2)</span></span><br><span class="line">p2-&gt;<span class="built_in">K</span>(); <span class="comment">// 编译错误，K为protected，不能在类外调用</span></span><br><span class="line">p2-&gt;<span class="built_in">H</span>(); <span class="comment">// 编译错误，p1的静态类型为Base*，Base类中没有H函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// 编译为 (*p2-&gt;vfptr)[0]((void*)p2)</span></span><br><span class="line"><span class="keyword">delete</span> p1; <span class="comment">// 编译为 (*p1-&gt;vfptr)[0]((void*)p1)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-虚函数的访问"><a href="#2-3-虚函数的访问" class="headerlink" title="2.3 虚函数的访问"></a>2.3 虚函数的访问</h2><p>在某个函数中调用另外一个函数规则如下：</p>
<ul>
<li>虚函数中访问的非虚函数：静态编联，使用本地版本</li>
<li>非虚函数中访问的虚函数：动态编联</li>
<li>虚函数中访问的虚函数：动态编联</li>
<li>构造函数不能为虚函数，在构造中调用虚函数采用静态编联，使用本地版本</li>
<li>析构函数可以为虚函数，在析构中调用虚函数采用静态编联，使用本地版本</li>
</ul>
<p>构造函数不能为虚函数原因：虚函数是为了根据不同的对象来产生不同的状态，但是前提是得有这个对象，而对象的产生必须依靠构造函数；其次，对象中虚表指针的初始化是在构造函数的初始化列表阶段，二者矛盾了。</p>
<p>在构造中调用虚函数采用静态编联原因：对象的构造顺序是先基类，后派生类。假设在基类的构造中调用一个虚函数使用动态编联，派生类重写了该虚函数，这个虚函数使用了派生类的数据。此时派生类还没有构造，结果将是不可预料的。</p>
<p>在析构中调用虚函数采用静态编联原因：对象的析构顺序是先派生类，后基类。假设在基类的析构中调用一个虚函数使用动态编联，派生类重写了该虚函数，这个虚函数使用了派生类的数据。此时派生类资源已经析构，结果将是不可预料的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; <span class="built_in">vf</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; <span class="built_in">vf</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::vf()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::vg()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">        <span class="built_in">nvh</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nvh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::nvh()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; <span class="built_in">vf</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123; <span class="built_in">vf</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::vf()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nvh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::nvh()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">nj</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::vn()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    p-&gt;<span class="built_in">vf</span>();</span><br><span class="line">    p-&gt;<span class="built_in">vg</span>();</span><br><span class="line"><span class="comment">//  p-&gt;nj(); 取消注释会编译错误，p的静态类型为Base*,Base类中没有nj函数</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">vg</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">nvh</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">vf</span>()</span><br></pre></td></tr></table></figure>
<p><code>Base *p = new Derived;</code><br>调用派生类的构造函数，派生类构造函数初始化列表阶段会调用基类的构造函数。基类构造函数调用vf虚函数，在构造中调用虚函数采用静态编联，即调用的基类的vf虚函数，输出<code>Base::vf()</code>。基类构造完后继续派生类构造，派生类构造调用vf虚函数采用静态编联，即调用的派生类的vf虚函数，输出<code>Derived::vf()</code>。</p>
<p><code>p-&gt;vf();</code><br>p的静态类型为Base*，Base类中有vf函数，vf为虚函数采用动态编联，p的动态类型为Derived*。调用派生类的vf虚函数，输出<code>Derived::vf()</code>。</p>
<p><code>p-&gt;vg();</code><br>p的静态类型为Base*，Base类中有vg函数，vg为虚函数采用动态编联，但是派生类没有重写vg， 调用基类的vg函数，先输出<code>&quot;Base::vg()&quot;</code>。vg虚函数中继续调用vf虚函数采用动态编联，即调用派生类vf虚函数，输出<code>&quot;Derived::vf()&quot;</code>。vg虚函数中继续调用nvh函数，nvh不是虚函数采用静态编联，因为vg为基类函数，所以调用基类的nvh函数，先输出<code>Base::nvh()</code>，nvh函数调用vf虚函数采用动态编联，即调用派生类vf虚函数，输出<code>&quot;Derived::vf()&quot;</code>。</p>
<p><code>delete p;</code><br>p的静态类型为Base*，Base类中析构函数为虚函数采用动态编联，调用派生类的析构函数，派生类析构函数调用vf虚函数，在析构中调用虚函数采用静态编联，所以调用的派生类的vf虚函数，输出<code>Derived::vf()</code>。派生类析构函数运行结束前编译器自动会调用基类析构函数，基类析构函数调用vf虚函数，在析构中调用虚函数采用静态编联，所以调用的基类的vf虚函数，输出<code>Base::vf()</code>。</p>
<h2 id="2-4-对象内存布局"><a href="#2-4-对象内存布局" class="headerlink" title="2.4 对象内存布局"></a>2.4 对象内存布局</h2><p>在含有虚函数的继承中对象内存布局较为复杂，我水平有限不能将其讲解的很清楚。推荐<code>陈皓</code>大佬两篇文章，相信看完后会对多态有更深的理解，也是对<code>陈皓</code>大佬最好的缅怀。<br><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTIxNjUuaHRtbA==">C++ 虚函数表解析<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTIxNzYuaHRtbA==">C++ 对象的内存布局<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="三、多态进阶"><a href="#三、多态进阶" class="headerlink" title="三、多态进阶"></a>三、多态进阶</h1><h2 id="3-1-静态多态和动态多态"><a href="#3-1-静态多态和动态多态" class="headerlink" title="3.1 静态多态和动态多态"></a>3.1 静态多态和动态多态</h2><p><font color=red >上文中提到的多态是指通过虚函数实现的动态多态，多态分为静态多态和动态多态。</font><br><strong>多态性：相同的函数调用，执行不同的代码体，从而有不同的行为后果。</strong> </p>
<h3 id="3-1-1-静态多态"><a href="#3-1-1-静态多态" class="headerlink" title="3.1.1 静态多态"></a>3.1.1 静态多态</h3><p>静态多态：在编译时根据目标对象的静态类型和参数列表中参数的静态类型确定目标代码体，通过<strong>模版</strong>与<strong>函数重载</strong>实现。</p>
<p>模板：允许函数或类根据不同的类型进行实例化，从而在编译时确定具体的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 编译时模板类A会根据模版参数T的类型生成不同的类</span></span><br><span class="line">    A&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    A&lt;<span class="type">float</span>&gt; obj2;</span><br><span class="line">    </span><br><span class="line">    obj<span class="number">1.f</span>(); <span class="comment">// 输出i</span></span><br><span class="line">    obj<span class="number">2.f</span>(); <span class="comment">// 输出f</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数重载：允许多个同名函数具有不同的参数列表，编译器在编译时根据函数调用的参数类型选择适当的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;char&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 输出 int</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 输出 char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-动态多态"><a href="#3-1-2-动态多态" class="headerlink" title="3.1.2 动态多态"></a>3.1.2 动态多态</h3><p>动态多态：在运行时决定函数调用的具体实现。<br>• 根据目标对象的动态类型和参数表中参数的静态类型确定目标代码体。<br>（虚函数和虚函数表）<br>• 根据目标对象的动态类型和参数表中参数的动态类型确定目标代码体。<br>（C++不支持）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(A *)</span> </span>&#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B *)</span> </span>&#123; cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(A *)</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B *)</span> </span>&#123; cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A* pa = &amp;b;</span><br><span class="line">    b.<span class="built_in">f</span>(pa); <span class="comment">// b的静态类型为B，参数pa静态类型为A*，B类中有f(A*)虚函数，采用动态编联，调用派生类的f(A *)函数，输出 3</span></span><br><span class="line">    pa-&gt;<span class="built_in">f</span>(pa); <span class="comment">// pa的静态类型为A*，参数pa的静态类型为A*，A类中有f(A*)虚函数，采用动态编联，调用派生类的f(A *)函数，输出 3</span></span><br><span class="line">    pa-&gt;<span class="built_in">f</span>(&amp;b); <span class="comment">// pa的静态类型为A*，参数&amp;b的静态类型为B*，A类中有f(B*)虚函数，采用动态编联，调用派生类的f(B *)函数，输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-虚拟的“拷贝构造函数”"><a href="#3-2-虚拟的“拷贝构造函数”" class="headerlink" title="3.2 虚拟的“拷贝构造函数”"></a>3.2 虚拟的“拷贝构造函数”</h2><p><img src="https://i-blog.csdnimg.cn/direct/d3b8737f432f427e9c46dffb58487306.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>问题：如果有个位于A类继承树下的对象（可能为A&#x2F;B&#x2F;C…），现在希望提供一个统一接口，能拷贝出一个跟它一摸一样的对象。</p>
<p>因为需要根据对象类型拷贝出一个相同的对象，我们立马想到了拷贝构造函数，但是有两个问题，第一，拷贝构造函数不能为虚函数。第二，拷贝构造即便能为虚函数，各类中拷贝构造函数名也不一样，所以这个思路不行。我们想到可以在最顶层基类A中给一个函数，这个函数接受一个A*的参数，并根据实际指向类型调用对应类型拷贝构造函数，于是写出如下代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A* <span class="title">A::copy</span><span class="params">(<span class="type">const</span> A &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">typeid</span>(A) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(a);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(B) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(<span class="built_in">static_cast</span>&lt;B &amp;&gt;(a));</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(C) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">C</span>(<span class="built_in">static_cast</span>&lt;C &amp;&gt;(a));</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码逻辑上没有问题，但难以适应变化，假设后续有派生类D、E…，需要不断在copy函数中增加新的类型判断。且对象具体类型识别需要RTTI，会有性能消耗。可以采用<strong>原型模式</strong>，在顶层基类A中提供一个名为clone虚函数，派生类中重写该虚函数解决前面的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;b); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> C *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">C</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C &amp;c); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-使用继承和虚函数的不足"><a href="#3-3-使用继承和虚函数的不足" class="headerlink" title="3.3 使用继承和虚函数的不足"></a>3.3 使用继承和虚函数的不足</h2><p><strong>只使用继承与虚函数，难以适应多个方向的变化。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设F()有两种不同的变化，G()有三种不同的变化，H()有四种不同的变化，那么需要<code>2*3*4=24</code>个派生类才能适应上面要求，如果后续某个函数有更多变化或新增虚函数，代码将难以维护。所以通常使用<code>水平（关联、依赖）+ 继承</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImpF</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpF</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImpG</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpG</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImpH</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpH</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>(ImpF *pf, ImpG *pg, ImpH *ph)</span><br><span class="line">            : _pf(pf), _pg(pg), _ph(ph) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123; _pf-&gt;<span class="built_in">F</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123; _pg-&gt;<span class="built_in">G</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123; _ph-&gt;<span class="built_in">H</span>(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ImpF *_pf;</span><br><span class="line">    ImpG *_pg;</span><br><span class="line">    ImpH *_ph;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们定义ImpF、ImpG、ImpH三个基类，对于F()函数的两种变化只需要定义两个类继承ImpF类并重写F()函数即可，G()和H()依此类推，所以只需要定义<code>2+3+4=9</code>个派生类即可。Parent类中存放ImpF、ImpG、ImpH三个基类的指针。</p>
<h1 id="四、扩展知识"><a href="#四、扩展知识" class="headerlink" title="四、扩展知识"></a>四、扩展知识</h1><h2 id="4-1-具体类和抽象类"><a href="#4-1-具体类和抽象类" class="headerlink" title="4.1 具体类和抽象类"></a>4.1 具体类和抽象类</h2><p><strong>具体类：可以实例化对象的类</strong><br><strong>抽象类：为派生类提供更高层次的抽象，本身不能被实例化</strong></p>
<p>抽象类说明：<br>• 含有一个或多个纯虚函数。<br>• 抽象类的派生类如果不重写纯虚函数,则还是抽象类<br>• 纯抽象类（接口类）：除静态、构造等函数均为纯虚函数，且没有任何非静态成员变量</p>
<p><strong>纯虚函数：虚函数后面写上&#x3D;0</strong><br>语法：<br><code>virtual ReturnType Func（...） ［const］ = 0；</code> </p>
<p>纯虚函数说明：</p>
<ul>
<li>必须为类的非静态成员函数。</li>
<li>纯虚函数通常是用来定义接口的，基类不会给出实现，而是要求派生类提供具体的实现。在提供一些默认行为或者进行一些公共操作时，<strong>纯虚函数是可以有定义的，但是必须在类外实现。</strong></li>
</ul>
<p><code>Shape.h</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;面积：&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Rectangle</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> w * h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若Shape:area有纯虚定义，则下边可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Shape.cpp</code>文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给出纯虚定义</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Shape::area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-运行时类型识别-RTTI"><a href="#4-2-运行时类型识别-RTTI" class="headerlink" title="4.2 运行时类型识别(RTTI)"></a>4.2 运行时类型识别(RTTI)</h2><p>运行时类型识别 (Runtime Type Identification，RTTI)： 是是C++中的一种机制，它允许在程序运行过程中确定对象的类型。</p>
<h3 id="4-2-1-type-info"><a href="#4-2-1-type-info" class="headerlink" title="4.2.1 type_info"></a>4.2.1 type_info</h3><p><strong>type_info类</strong>：一个与类型信息相关类，在标准头文件typeinfo定义，主要用于在运行时提供有关对象类型的信息。它通常与<code>typeid运算符</code>结合使用，<code>typeid运算符</code>结果是一个与之关联的 type_info 对象的引用，以便在程序运行时确定对象的类型。</p>
<p>不能直接实例化type_info 类的对象，因为该类只有一个private拷贝构造函数和一个protected构造函数，获取type_info 对象的唯一方式是使用 typeid 运算符。</p>
<p>type_info 类提供了一个查看类型名称的方法<code>type_info::name()</code>，以及与其他 type_info对象之间比较的函数（<code>operator==</code> 和 <code>operator!=</code>）。</p>
<p><strong>说明：如果一个类有虚函数，则编译器在运行时会为这个类创建一个<code>type_info</code>对象，并将这个对象的地址存到该类虚表所在内存空间的前一个位置。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">K</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/353a877aa1fa4361bc830258d6eb9051.png" alt="在这里插入图片描述"></p>
<h3 id="4-2-2-typeid"><a href="#4-2-2-typeid" class="headerlink" title="4.2.2 typeid"></a>4.2.2 typeid</h3><p>用法：<br><code>typeid(type_name)</code><br><code>typeid(expr)</code></p>
<p>typeid 运算符允许在运行时确定对象的类，typeid 的结果是<code>const type_info&amp;</code>。 该值是对type_name或expr 的类型的 type_info 对象的引用。</p>
<p>说明：</p>
<ul>
<li>type_name&#x2F;expr是指针，则返回对应的静态类型</li>
<li>type_name&#x2F;expr是对象或引用，且含有虚函数，则返回对应的动态类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">typeid</span>(p) == <span class="built_in">typeid</span>(Base *); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">typeid</span>(p) == <span class="built_in">typeid</span>(Derived *); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">typeid</span>(*p) == <span class="built_in">typeid</span>(Base); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">typeid</span>(*p) == <span class="built_in">typeid</span>(Derived); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-dynamic-cast"><a href="#4-2-3-dynamic-cast" class="headerlink" title="4.2.3 dynamic_cast"></a>4.2.3 dynamic_cast</h3><p><strong>dynamic_cast运算符一般用于包含继承关系且含有虚函数的向下类型转换。</strong></p>
<p>转换过程（假设p为指向基类的指针）：</p>
<ol>
<li>计算指针所指的对象的虚表地址，存放对象类型信息的<code>type_info *</code>指针在虚表前面,  然后解引用获取type_info信息，即 <code>*(type_info*)p-&gt;vfptr[-1]</code></li>
<li>静态推导向下转型的目标类型的type_info信息，即获取类XX的type_info信息</li>
<li>比较两个type_info信息，若2）中的类型信息与1）中的类型信息相等或是其基类类型，则返回相应的对象或子对象的地址，否则返回nullptr</li>
</ol>
<h3 id="4-2-4-RTTI缺点"><a href="#4-2-4-RTTI缺点" class="headerlink" title="4.2.4 RTTI缺点"></a>4.2.4 RTTI缺点</h3><ul>
<li>内存开销：RTTI 会为每个启用的类添加额外的元数据（如 type_info 对象），这会增加内存使用量。</li>
<li>运行时开销：使用 dynamic_cast 和 typeid 时，程序需要在运行时进行类型检查和比较，这会导致额外的运行时开销，特别是在类型层次复杂或转换频繁时，性能影响可能较大。</li>
<li>可移植性问题：尽管 RTTI 是 C++ 标准的一部分，但不同编译器对 RTTI 的实现可能有所不同。这意味着在跨平台开发时，可能会遇到与 RTTI 相关的可移植性问题。</li>
</ul>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 引用</title>
    <url>/C-%E5%BC%95%E7%94%A8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、引用"><a href="#一、引用" class="headerlink" title="一、引用"></a>一、引用</h1><h2 id="1-1-引用是什么"><a href="#1-1-引用是什么" class="headerlink" title="1.1 引用是什么"></a>1.1 引用是什么</h2><p>&emsp;想必大家都读过四大名著之一的《水浒传》，小说中每个英雄除了有自己本身的名字以外，根据人物外表性格还有许多绰号。比如：宋江又叫：及时雨、呼保义、孝义黑三郎、宋公明、宋押司。李逵又叫铁牛、黑旋风。C++引入了引用这个概念，引用不是新定义一个变量，而是给已存在变量取了一个别名。<strong>在语法层面：编译器不会为引用变量开辟内存空间，它和引用的变量共用同一块内存空间</strong>。</p>
<span id="more"></span>

<h2 id="1-2-引用的用法"><a href="#1-2-引用的用法" class="headerlink" title="1.2 引用的用法"></a>1.2 引用的用法</h2><p>用法：<code>引用对象类型&amp; 别名 = 引用对象;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; alias_x = x; <span class="comment">// 引用对象x为int类型，所以引用类型也为int</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;x = &quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;alias_x = &quot;</span> &lt;&lt; &amp;alias_x &lt;&lt; endl;</span><br><span class="line">	alias_x = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x= &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;alias_x= &quot;</span> &lt;&lt; alias_x &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp;x = <span class="number">00</span>9BFBBC</span><br><span class="line">&amp;alias_x = <span class="number">00</span>9BFBBC</span><br><span class="line">x= <span class="number">20</span></span><br><span class="line">alias_x= <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>x</code>与<code>alias_x</code>的内存地址相同，修改<code>x</code>就是修改<code>alias_x</code>,修改<code>alias_x</code>就是修改<code>x</code></p>
<h2 id="1-3-引用的特性"><a href="#1-3-引用的特性" class="headerlink" title="1.3 引用的特性"></a>1.3 引用的特性</h2><h3 id="1-3-1-引用在定义时必须初始化"><a href="#1-3-1-引用在定义时必须初始化" class="headerlink" title="1.3.1 引用在定义时必须初始化"></a>1.3.1 引用在定义时必须初始化</h3><p><strong>引用语法层面是某个对象的别名，所以在定义时必须初始化，不能引用一个未知的对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; alias_x; <span class="comment">// 错误，引用在定义时必须初始化，不能引用未知对象</span></span><br><span class="line"><span class="type">int</span>&amp; alias_x = <span class="literal">nullptr</span>; <span class="comment">// 错误，不能引用一个空对象</span></span><br><span class="line"><span class="type">int</span>&amp; alias_x = x; <span class="comment">// 正确 </span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-一个对象可以有多个引用"><a href="#1-3-2-一个对象可以有多个引用" class="headerlink" title="1.3.2 一个对象可以有多个引用"></a>1.3.2 一个对象可以有多个引用</h3><p><strong>水浒传中好汉可以有多个绰号，一个对象可以有多个引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; alias_x1 = x;</span><br><span class="line"><span class="type">int</span>&amp; alias_x2 = x;</span><br><span class="line"><span class="type">int</span>&amp; alias_x3 = x;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-一旦引用一个对象，再不能改为引用其他对象"><a href="#1-3-3-一旦引用一个对象，再不能改为引用其他对象" class="headerlink" title="1.3.3 一旦引用一个对象，再不能改为引用其他对象"></a>1.3.3 一旦引用一个对象，再不能改为引用其他对象</h3><p><strong>引用是一个非常专一的“人”，一旦引用了某个对象，就不能在改为引用其他对象了</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span>&amp; alias_x = x;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;x = &quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;y = &quot;</span> &lt;&lt; &amp;y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;alias_x = &quot;</span> &lt;&lt; &amp;alias_x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;alias = &quot;</span> &lt;&lt; alias_x &lt;&lt; endl;</span><br><span class="line">	alias_x = y; <span class="comment">// 一旦引用一个对象，在不能引用其他对象，这里是将y的值赋值给alias_x,而不是引用y</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;x = &quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;y = &quot;</span> &lt;&lt; &amp;y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;alias_x = &quot;</span> &lt;&lt; &amp;alias_x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;alias = &quot;</span> &lt;&lt; alias_x &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp;x = <span class="number">005</span>8FA08</span><br><span class="line">&amp;y = <span class="number">005</span>8F9FC</span><br><span class="line">&amp;alias_x = <span class="number">005</span>8FA08</span><br><span class="line">alias = <span class="number">10</span></span><br><span class="line">&amp;x = <span class="number">005</span>8FA08</span><br><span class="line">&amp;y = <span class="number">005</span>8F9FC</span><br><span class="line">&amp;alias_x = <span class="number">005</span>8FA08</span><br><span class="line">alias = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>可以发现alias_x地址并未发生改变，只是alias_x值变为20</p>
<h3 id="1-3-4-引用类型必须和引用对象的类型相同"><a href="#1-3-4-引用类型必须和引用对象的类型相同" class="headerlink" title="1.3.4 引用类型必须和引用对象的类型相同"></a>1.3.4 引用类型必须和引用对象的类型相同</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/211241d6ecadb46de46ec483b72f7428.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-4-引用的权限"><a href="#1-4-引用的权限" class="headerlink" title="1.4 引用的权限"></a>1.4 引用的权限</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//int&amp; alias_x = x; 权限放大，编译错误,x 为常变量,而alias_x 为变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; alias_x = x; <span class="comment">//权限不变可以，alias_x与y都为常变量 正确</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; alias_y = y; <span class="comment">// 权限缩小，y为变量，而alias_y为常变量 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-引用的本质"><a href="#1-5-引用的本质" class="headerlink" title="1.5 引用的本质"></a>1.5 引用的本质</h2><p><strong>引用的本质就是指针</strong>，引用一个对象其实就是存储这个对象的内存地址，当要使用时编译器自动对指针解引用访问对应对象，所以使用引用会开辟内存空间存放对象地址，32位系统下占4字节，64位系统下占8字节<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4c173f6850a795f604ce652af9d8b639.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、引用的应用场景"><a href="#二、引用的应用场景" class="headerlink" title="二、引用的应用场景"></a>二、引用的应用场景</h1><h2 id="2-1-引用做函数形参"><a href="#2-1-引用做函数形参" class="headerlink" title="2.1 引用做函数形参"></a>2.1 引用做函数形参</h2><h3 id="2-1-1-形参可以改变实参"><a href="#2-1-1-形参可以改变实参" class="headerlink" title="2.1.1 形参可以改变实参"></a>2.1.1 形参可以改变实参</h3><p><strong>当函数内形参的改变实参也改变时，可以用引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap3</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swap1中函数内x与y交换，函数外的实参并没有发生改变，因为形参只是实参一份临时拷贝</p>
<p>swap2中形参px、py存放的是实参的地址，对形参修改会改变外面的实参</p>
<p>swap3中使用了引用，引用的本质就是指针，等同于swap2</p>
<h3 id="2-1-2-提高效率"><a href="#2-1-2-提高效率" class="headerlink" title="2.1.2 提高效率"></a>2.1.2 提高效率</h3><p><strong>当函数的形参变量类型很大时，直接传值调用，形参是实参的临时拷贝，效率很低。可以使用引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000 <span class="comment">//数组大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度（已存放元素个数）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">(SeqList s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s.data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">(SeqList&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s.data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数Print1时，需要将SeqList类型的实参拷贝给形参，而SeqList类型大小为40004字节，开销很大，效率很低</p>
<p>调用函数Print2时，形参本质是指针</p>
<h2 id="2-2-引用做函数返回值"><a href="#2-2-引用做函数返回值" class="headerlink" title="2.2 引用做函数返回值"></a>2.2 引用做函数返回值</h2><p><strong>当函数的返回值类型很大时，直接传值返回，实际返回的是返回值的临时拷贝，效率很低。可以使用引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000 <span class="comment">//数组大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度（已存放元素个数）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">SeqList s; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">SeqList <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList&amp; <span class="title">Test2</span><span class="params">(SeqList&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数Test1返回时，先将返回值拷贝给临时变量，再将临时变量返回，而SeqList类型大小为40004字节，开销很大，效率很低</p>
<p>函数Test2返回时，返回引用，引用本质是指针，只需要将指针拷贝给临时变量，再将临时变量返回</p>
<h1 id="三、引用的陷阱"><a href="#三、引用的陷阱" class="headerlink" title="三、引用的陷阱"></a>三、引用的陷阱</h1><p>&emsp;<strong>引用做为函数返回值时，不要返回函数内的局部变量</strong>。局部变量出了函数作用域<strong>生命周期就结束了</strong>，虽然有的编译器不会将这部分空间清0，但是这部分空间已经不属于我们了，<strong>在尝试访问或修改这部分空间属于非法访问内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result = x + y;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>&amp; ret = <span class="built_in">Add</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret = <span class="number">10</span></span><br><span class="line">ret = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>add函数内的result是局部变量，出了函数作用域生命周期结束，返回result并保存在ret中已经属于非法访问内存了。测试环境中编译器并没有将这部分空间清0，所以再次调用函数后，ret值变为了2</p>
<h1 id="四、引用与指针对比"><a href="#四、引用与指针对比" class="headerlink" title="四、引用与指针对比"></a>四、引用与指针对比</h1><h2 id="4-1-相同点"><a href="#4-1-相同点" class="headerlink" title="4.1 相同点"></a>4.1 相同点</h2><p>●<strong>引用的本质就是指针，只是编译器对引用做了封装而已</strong><br>● <strong>引用与指针所占空间大小一样</strong></p>
<h2 id="4-2-不同点"><a href="#4-2-不同点" class="headerlink" title="4.2 不同点"></a>4.2 不同点</h2><p><strong>●引用在定义时必须初始化，指针没有要求<br>●一旦引用一个对象，再不能改为引用其他对象，而指针可以随时指向一个同类型对象<br>●不能引用NULL，但有NULL指针<br>● 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数<br>● 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小<br>● 有多级指针，但是没有多级引用<br>●访问对象方式不同，指针需要显式解引用，引用编译器替我们解引用处理</strong></p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 强制转换运算符</title>
    <url>/C-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content><![CDATA[<h1 id="一、static-cast"><a href="#一、static-cast" class="headerlink" title="一、static_cast"></a>一、static_cast</h1><p><code>static_cast</code> 在编译时进行类型转换，在转换时会进行一些类型检查以确保转换是相对安全的，<strong>但不包括运行时类型检查</strong>。<code>static_cast</code> 无法强制转换掉 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 或 <strong><code>__unaligned</code></strong> 特性。 </p>
<p>语法：仅根据表达式中存在的类型，将 expression 转换为 type 类型。</p>
<p><code>static_cast &lt;type&gt; ( expression )</code></p>
<span id="more"></span>

<p><strong>应用场景</strong></p>
<ul>
<li>可用于执行任何隐式转换，包括标准转换和用户定义的转换。</li>
<li>整数值与枚举类型之间转换， 如果整型值不在枚举值的范围内，生成的枚举值是不确定的。</li>
<li>将任何指针类型显式转换为 <code>void*</code>类型 ，将<code>void*</code>转换为目标类型指针，0转换为任何指针类型。</li>
<li>类继承情况下的向上类型转换和向下类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 隐式转换：例如数值类型转换，但程序员需要确保目标类型不会越界 */</span>  </span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i = <span class="number">65</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">int</span> x = <span class="number">650</span>;</span><br><span class="line">ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i);    <span class="comment">// int to char, ch -&gt; &#x27;A&#x27;</span></span><br><span class="line">j = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(f);  <span class="comment">// float to int, j -&gt; 2</span></span><br><span class="line">ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);   <span class="comment">// char范围为 -128-127,x为650,越界，ch存的是错误的值 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">integer</span> &#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">integer</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">            : _x(x)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;integer()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> 	  <span class="comment">// 用户定义的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator string()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(_x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">integer <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>;   <span class="comment">// integer()</span></span><br><span class="line">string str = obj; <span class="comment">// operator string()</span></span><br><span class="line">obj = <span class="number">20</span>;         <span class="comment">// integer()</span></span><br><span class="line">string str2 = <span class="built_in">static_cast</span>&lt;string&gt;(obj); <span class="comment">// operator string()</span></span><br><span class="line">obj = <span class="built_in">static_cast</span>&lt;integer&gt;(<span class="number">30</span>); <span class="comment">// integer()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数与枚举类型转换 */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color color = Color::GREEN;</span><br><span class="line"><span class="type">int</span> colorValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color); <span class="comment">// 将枚举类型转换为整数，colorValue=1</span></span><br><span class="line"><span class="type">int</span> intValue = <span class="number">2</span>; </span><br><span class="line">Color enumColor = <span class="built_in">static_cast</span>&lt;Color&gt;(intValue); <span class="comment">// 将整数转换为枚举类型, enumColor=Color::BLUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将任何指针类型显式转换为 `void*`类型 ，将`void*`转换为目标类型指针 */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">65</span>;</span><br><span class="line"><span class="type">void</span> *pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span> *&gt;(&amp;i);</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(pv); <span class="comment">// *pc为 &#x27;A&#x27;</span></span><br><span class="line"><span class="type">int</span>* pi = <span class="built_in">static_cast</span>(<span class="type">int</span> *)(<span class="literal">nullptr</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	向上与向下类型转换,向下类型转换是不安全的，它在编译时进行类型检查，而不会进行运行时的安全性检查。</span></span><br><span class="line"><span class="comment">	如果基类指针并非完整指向派生类对象，向下类型转换可能带来灾难。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// Upcasting</span></span><br><span class="line">basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// Accessing Base class member</span></span><br><span class="line"><span class="comment">// basePtr-&gt;show();  // Error: Base class pointer cannot access Derived class member</span></span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* DerivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr); <span class="comment">// Downcasting</span></span><br></pre></td></tr></table></figure>

<h1 id="二、dynamic-cast"><a href="#二、dynamic-cast" class="headerlink" title="二、dynamic_cast"></a>二、dynamic_cast</h1><p><code>dynamic_cast</code> 用于<strong>具有虚函数的基类</strong>与派生类之间指针与引用的转换。编译器会运行时进行类型检查，如果转换是合法的，则转换成功并返回指向目标类型的指针或引用；如果转换不合法，则返回空指针（对指针类型）或抛出 <code>std::bad_cast</code> 异常（对引用类型）。</p>
<p>语法：将 expression 转换为 type 类型。</p>
<p><code>dynamic_cast &lt;type&gt; ( expression )</code></p>
<p><strong>应用场景</strong></p>
<ul>
<li>向上类型转换（更推荐使用static_cast）</li>
<li>向下类型转换</li>
<li>横向类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 向下类型转换 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived *derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    derivedPtr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出：Derived class</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed to cast&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base &amp;baseRef = derivedObj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived &amp;derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived &amp;&gt;(baseRef);</span><br><span class="line">    derivedRef.<span class="built_in">show</span>(); <span class="comment">// 输出：Derived class</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_cast) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can&#x27;t cast to Derived&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align=left><img src="C-强制转换运算符/向上类型转换1.png" style="zoom:50%;" /></div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	多继承向上类型转换,指向 D 类型对象的指针可以安全地强制转换为 B 或 C。 但是，如果 D 强制转换为指向 A 对象的指针，会产生 A 	的哪个实例？ 这将导致不明确的强制转换错误。 若要解决此问题，可以执行两个明确的强制转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D *pd = <span class="keyword">new</span> D;</span><br><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pd);   <span class="comment">// C4540, ambiguous cast fails at runtime</span></span><br><span class="line">B *pb = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(pd);   <span class="comment">// first cast to B</span></span><br><span class="line">A *pa2 = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pb);   <span class="comment">// ok: unambiguous</span></span><br></pre></td></tr></table></figure>

<div align=left><img src="C-强制转换运算符/向上类型转换2.png" style="zoom:50%;" /></div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		在给定 E 类型对象和指向 D 子对象的指针的情况下，若要从 D 子对象导航到最左侧的 A 子对象，可以进行三次转换。 可以执行从 D 	指针到 E 指针的 dynamic_cast 转换，然后执行从 E 到 B 的转换（可以是 dynamic_cast，也可以是隐式转换），最后执行从 B 到 	 A 的隐式转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D *dPtr = <span class="keyword">new</span> <span class="built_in">E</span>();</span><br><span class="line">E *pe = <span class="built_in">dynamic_cast</span>&lt;E *&gt;(dPtr);</span><br><span class="line">B *pb = pe;   <span class="comment">// upcast, implicit conversion</span></span><br><span class="line">A *pa = pb;   <span class="comment">// upcast, implicit conversion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	横向类型转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">D *dPtr = <span class="keyword">new</span> <span class="built_in">E</span>();</span><br><span class="line">B *pb = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(dPtr); <span class="comment">// 横向类型转换</span></span><br><span class="line">A* pa = pb;   <span class="comment">// upcast, implicit conversion</span></span><br></pre></td></tr></table></figure>

<h1 id="三、const-cast"><a href="#三、const-cast" class="headerlink" title="三、const_cast"></a>三、const_cast</h1><p>移除对象的 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 和 <strong><code>__unaligned</code></strong> 属性，如果一个对象本身就是<code>const</code>属性，使用<code>const_cast</code>，结果是C++标准未定义的。</p>
<p>语法：</p>
<p><code>const_cast &lt;type&gt; ( expression )</code></p>
<p><strong>应用场景</strong></p>
<ul>
<li>函数形参是<code>non-const</code>变量，并且函数不会对实参的值进行改动，但变量为<code>const</code></li>
<li>变量为<code>non-const</code>，使用一个<code>const</code>的指针(引用)来指向它，某个地方需要修改指针(引用)指向的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *num &lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pi_c = &amp;j;</span><br><span class="line"><span class="type">int</span> *pi = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(pi_c);</span><br><span class="line">*pi = <span class="number">1</span>; <span class="comment">// j为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri_c = j;</span><br><span class="line"><span class="type">int</span> &amp;ri = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(ri_c);</span><br><span class="line">ri = <span class="number">2</span>; <span class="comment">// j为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 警告：i本身为const,使用const_cast行为是未定义的 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pi_c = &amp;i;</span><br><span class="line"><span class="type">int</span> *pi = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(pi_c);</span><br><span class="line">*pi = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i:  &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  adderss:  &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl; <span class="comment">// i:  10  adderss:  0x30c624598</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pi:  &quot;</span> &lt;&lt; *pi &lt;&lt; <span class="string">&quot;  adderss:  &quot;</span> &lt;&lt; pi &lt;&lt; endl; <span class="comment">// *pi:  1  adderss:  0x30c624598</span></span><br></pre></td></tr></table></figure>

<h1 id="四、reinterpret-cast"><a href="#四、reinterpret-cast" class="headerlink" title="四、reinterpret_cast"></a>四、reinterpret_cast</h1><p>允许将任何指针(引用)转换为任何其他指针(引用)类型。 也允许将任何整数类型转换为任何指针(引用)类型以及反向转换。<strong><code>reinterpret_cast</code></strong> 运算符无法强制转换掉 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 或 <strong><code>__unaligned</code></strong> 特性。滥用 <strong><code>reinterpret_cast</code></strong> 运算符可能很容易带来风险。</p>
<p>语法</p>
<p><code>reinterpret_cast &lt; type &gt; ( expression )</code></p>
<p><strong>应用场景</strong></p>
<ul>
<li>改变指针或引用的类型</li>
<li>将指针或引用转换为一个足够长度的整型</li>
<li>将整型转换为指针或引用类型</li>
</ul>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 智能指针</title>
    <url>/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.html</url>
    <content><![CDATA[<h1 id="一、智能指针简介"><a href="#一、智能指针简介" class="headerlink" title="一、智能指针简介"></a>一、智能指针简介</h1><h2 id="1-1-为什么需要智能指针"><a href="#1-1-为什么需要智能指针" class="headerlink" title="1.1 为什么需要智能指针"></a>1.1 为什么需要智能指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态申请资源后忘记释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发生异常</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> str;	<span class="comment">// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用传统指针时，需要手动分配和释放内存，这可能会导致内存泄漏（未释放已分配的内存）或释放后的野指针（指向已释放的内存）。智能指针通过自动内存管理来帮助解决这些问题，确保在不再需要内存时自动释放它。</p>
<span id="more"></span>

<h2 id="1-2-智能指针思想"><a href="#1-2-智能指针思想" class="headerlink" title="1.2 智能指针思想"></a>1.2 智能指针思想</h2><p>智能指针是在<code>&lt;memory&gt;</code>头文件中的 <code>std</code> 命名空间中定义的。 将智能指针抽象成一个对象，由该对象管理动态申请的内存资源，当该对象出作用域析构时，如果引用计数减到0，则连着将动态申请的内存free。</p>
<p><strong>实现智能指针关键点</strong></p>
<ul>
<li>RAII</li>
<li>支持像指针一样使用</li>
</ul>
<p>RAII 是 “资源获取即初始化”（Resource Acquisition Is Initialization）的缩写，旨在通过对象生命周期的管理来确保资源（如内存、文件句柄、数据库连接等）的正确获取和释放。RAII 的核心思想是，资源的获取操作应该与对象的初始化操作绑定在一起，资源的释放应该与对象的销毁操作绑定在一起。这意味着在对象的构造函数中获取资源，在对象的析构函数中释放资源，从而确保资源的正确管理。</p>
<p>RAII 有以下关键特点：</p>
<ol>
<li><strong>资源管理封装：</strong> RAII 鼓励将资源的管理和使用封装在对象中，以确保资源在对象的生命周期内正确获取和释放。这允许开发人员不必手动记住释放资源的细节。</li>
<li><strong>自动化资源释放：</strong> 当对象超出其作用域范围时，其析构函数自动被调用，从而自动释放与资源相关的资源，无论是通过正常的代码路径还是异常路径。</li>
<li><strong>异常安全性：</strong> 使用 RAII 可以确保即使在发生异常时，资源也会被正确释放，从而避免资源泄漏。</li>
<li><strong>代码可读性：</strong> RAII 使代码更加清晰和易于理解，因为资源管理逻辑被封装在对象的构造和析构中，而不是分散在代码中。</li>
</ol>
<h1 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h1><h2 id="2-1-面临问题"><a href="#2-1-面临问题" class="headerlink" title="2.1 面临问题"></a>2.1 面临问题</h2><p><code>auto_ptr</code> 是c++ 98定义的智能指针模板,C++11 后auto_ptr 已经被“抛弃”，已使用unique_ptr替代。</p>
<p><strong>auto_ptr 被C++11抛弃的主要原因</strong></p>
<ol>
<li><p>拷贝构造或者赋值采用资源管理器转移思想，存在被拷贝对象悬空问题</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Date&gt; <span class="title">d1</span><span class="params">(<span class="keyword">new</span> Date(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;Date&gt; <span class="title">d2</span><span class="params">(<span class="keyword">new</span> Date(<span class="number">2023</span>,<span class="number">11</span>,<span class="number">11</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">d1 = d2;</span><br><span class="line">cout &lt;&lt; d<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// 打印空指针，此时继续使用d2访问数据会存在问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在STL中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;auto_ptr&lt;string&gt;&gt; v;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m s1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">s2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m s2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s1));</span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s2));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[0]：&quot;</span> &lt;&lt;  *v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[1]：&quot;</span> &lt;&lt;  *v[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>];	<span class="comment">// 风险，如果进行赋值，存在悬空问题。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[0]：&quot;</span> &lt;&lt;  *v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[1]：&quot;</span> &lt;&lt;  *v[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 程序崩溃，非法访问内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不支持对象数组的内存管理</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>; <span class="comment">// No matching constructor for initialization of &#x27;auto_ptr&lt;int[]&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-模拟实现"><a href="#2-2-模拟实现" class="headerlink" title="2.2 模拟实现"></a>2.2 模拟实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      T* _ptr;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(T *p = <span class="number">0</span>)</span> : _ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">auto_ptr</span>(auto_ptr &amp;a) : _ptr(a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">      auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr &amp;__p) &#123;</span><br><span class="line">          <span class="built_in">reset</span>(__p.<span class="built_in">release</span>());</span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将auto_ptr内部指针设置为空指针，而不破坏当前由auto_ptr所指向的对象。函数返回调用之前所指向的对象。</span></span><br><span class="line">      <span class="function">T *<span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          T *tmp = _ptr;</span><br><span class="line">          _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">return</span> tmp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (_ptr != p)</span><br><span class="line">              <span class="keyword">delete</span> _ptr;</span><br><span class="line">          _ptr = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> *_ptr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> _ptr;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h1><ul>
<li><p>唯一拥有：<code>unique_ptr</code> 是<strong>独占所有权</strong>的智能指针，意味着在任何时刻只能有一个 <code>unique_ptr</code> 拥有某个对象的所有权。这也确保了对象不会被多个指针共享，避免了重复释放内存的风险。</p>
</li>
<li><p>自动释放：当 <code>unique_ptr</code> 超出其作用域时，会自动调用 <code>delete</code> 释放所管理的对象。这减少了内存泄漏的风险。</p>
</li>
<li><p>不支持拷贝：<code>unique_ptr</code> 不允许拷贝，防止两个指针指向同一个对象。</p>
</li>
<li><p>支持移动语义：可以通过 <code>std::move</code> 将 <code>unique_ptr</code> 转移到另一个指针，这样原来的指针就失去了对对象的所有权。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      T *_ptr;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> : _ptr(p) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">      unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;o) : _ptr(o.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    	unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">          <span class="built_in">reset</span>();</span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr &amp;&amp;o) &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;o)&#123;</span><br><span class="line">          		<span class="built_in">reset</span>(o.<span class="built_in">release</span>());  </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          T *tmp = _ptr;</span><br><span class="line">          _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">return</span> tmp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (_ptr != p)</span><br><span class="line">              <span class="keyword">delete</span> _ptr;</span><br><span class="line">          _ptr = p;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      ~<span class="built_in">unique_ptr</span>() &#123; <span class="keyword">delete</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;x)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_ptr, x._ptr);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">          __glibcxx_assert(<span class="built_in">get</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">          __glibcxx_assert(<span class="built_in">get</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span> == <span class="built_in">get</span>() ? <span class="literal">false</span> : <span class="literal">true</span>; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h1><ul>
<li><p><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可共享对一个对象的所有权，并共同负责管理该对象的生命周期。当最后一个 <code>shared_ptr</code> 被销毁时，对象的生命周期才会结束。</p>
</li>
<li><p><strong>引用计数</strong>：每当创建一个新的 <code>shared_ptr</code> 指向同一对象时，引用计数会增加；每当 <code>shared_ptr</code> 被销毁或重置时，引用计数会减少。当引用计数降为零时，所指向的对象会被销毁。</p>
</li>
<li><p><strong>线程安全</strong>：<strong>对 <code>shared_ptr</code> 本身的操作是线程安全的</strong>，引用计数的增加和减少是线程安全的。<strong>对所指对象的操作不一定是线程安全的</strong>，如果多个线程需要同时读取或修改由 <code>shared_ptr</code> 所管理的对象，需要自己管理该对象的线程安全，例如使用互斥锁。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : _ptr(ptr), _pcount(new int(<span class="number">1</span>)), _pmtx(new mutex) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放资源</span></span><br><span class="line"><span class="comment">    Release() 方法减少引用计数，并根据引用计数的值来判断是否需要删除指向的堆内存对象和引用计数对象。</span></span><br><span class="line"><span class="comment">    在操作之前，我们使用互斥量 _pmtx 进行加锁，以保证线程安全。*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">                <span class="comment">// 删除器进行删除</span></span><br><span class="line">                _del(_ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> _pcount;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (deleteFlag) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pmtx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*_pcount);</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">            : _ptr(sp._ptr), _pcount(sp._pcount), _pmtx(sp._pmtx) &#123;</span><br><span class="line">        <span class="built_in">AddCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    shared_ptr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            <span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pcount = sp._pcount;</span><br><span class="line">            _pmtx = sp._pmtx;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">AddCount</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator*() 重载</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator-&gt;() 重载</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get() 方法</span></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use_count() 方法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_pcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap() 方法，交换 2 个 shared_ptr 智能指针的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&lt;T&gt; &amp;sp)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(_ptr, sp._ptr);</span><br><span class="line">        std::<span class="built_in">swap</span>(_pcount, sp._pcount);</span><br><span class="line">        std::<span class="built_in">swap</span>(_pmtx, sp._pmtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset() 方法，重置 shared_ptr 智能指针对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放原有资源</span></span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值</span></span><br><span class="line">        _ptr = ptr;</span><br><span class="line">        _pcount = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">        _pmtx = <span class="keyword">new</span> mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;           <span class="comment">// 指向堆内存对象的指针</span></span><br><span class="line">    <span class="type">int</span> *_pcount;      <span class="comment">// 引用计数的指针</span></span><br><span class="line">    mutex *_pmtx;      <span class="comment">// 保护引用计数的互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装器</span></span><br><span class="line">    function&lt;<span class="type">void</span>(T *)&gt; _del = [](T *ptr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lambda delete:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-函数模版make-shared"><a href="#4-1-函数模版make-shared" class="headerlink" title="4.1 函数模版make_shared"></a>4.1 函数模版make_shared</h2><p><code>shared_ptr </code>需要维护引用计数的信息：</p>
<ul>
<li><p>强引用, 用来记录当前有多少个存活的 shared_ptrs 正共享该对象，共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)</p>
</li>
<li><p>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs.，当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)。</p>
</li>
</ul>
<p><strong>优点1 提高内存分配效率</strong></p>
<p>通过使用原始的 <code>new</code>运算符分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块，总共需要分配2次内存空间。</p>
<img src="C-智能指针/内存图1.png" alt="内存图1" style="zoom:50%;" />



<p><code>make_shared</code> 只需要<strong>单次内存分配</strong>，提高了性能，并减少了内存碎片。</p>
<img src="C-智能指针/内存图2.png" alt="内存图2" style="zoom:50%;" />

<p><strong>优点2 异常安全</strong></p>
<p>使用 <code>new</code> 直接创建对象时，如果在 <code>std::shared_ptr</code> 构造之前抛出异常，可能会导致内存泄漏。而使用 <code>make_shared</code> 可以避免这种情况，因为对象的分配和智能指针的构造是原子操作，不会中途出现内存泄漏的问题。</p>
<p><strong>缺点1 对象构造函数是保护或私有时,无法使用 <code>make_shared</code></strong></p>
<p><strong>缺点2 对象的内存可能无法及时回收</strong></p>
<p><code>make_shared</code> 只分配一次内存，减少了内存分配的开销，使得控制块和托管对象在同一内存块上分配。而控制块是由 shared_ptr 和 weak_ptr 共享的，因此两者共同管理着这个内存块（托管对象 + 控制块）。当强引用计数为 0 时，托管对象被析构（即析构函数被调用），但内存块并未被回收，只有等到最后一个 weak_ptr 离开作用域时，弱引用也减为 0 才会释放这块内存块。原本强引用减为 0 时就可以释放的内存, 现在变为了强引用和弱引用都减为 0 时才能释放, 意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题。</p>
<h2 id="4-2-类模版enable-shared-from-this"><a href="#4-2-类模版enable-shared-from-this" class="headerlink" title="4.2 类模版enable_shared_from_this"></a>4.2 类模版enable_shared_from_this</h2><p><code>enable_shared_from_this</code>是一个模板类，定义于头文件<code>&lt;memory&gt;</code>。 <code>enable_shared_from_this</code> 能让一个对象（假设其名为 t ，且已被一个 <code>shared_ptr</code> 对象 pt 管理）<strong>安全地创建指向自身的 shared_ptr 智能指针</strong>（假设名为 pt1, pt2, … ） ，它们与 pt <strong>共享对象 t 的所有权</strong>。</p>
<p>​    若一个类 T 继承<code>enable_shared_from_this&lt;T&gt; </code>，则会为该类 T 提供成员函数 <code>shared_from_this </code>。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Bad &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad());</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;bp1.use_count() = &quot; &lt;&lt; bp1.use_count() &lt;&lt; std::endl; // 输出1</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; std::endl; // 输出1</span><br><span class="line">    </span><br><span class="line">    // 进程崩溃，对象析构了2次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncWorker</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;AsyncWorker&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动一个异步任务，在线程中执行</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        std::<span class="built_in">thread</span>([self] &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            self-&gt;<span class="built_in">onTaskComplete</span>();</span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTaskComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task complete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里可以访问对象的成员或调用其他方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AsyncWorker</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AsyncWorker destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 AsyncWorker 对象并通过 shared_ptr 管理</span></span><br><span class="line">        std::shared_ptr&lt;AsyncWorker&gt; worker = std::<span class="built_in">make_shared</span>&lt;AsyncWorker&gt;();</span><br><span class="line">        worker-&gt;<span class="built_in">startAsyncTask</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待异步任务完成</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 主线程等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 程序结束，确保对象正确销毁</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 让 detachment 线程输出 &quot;destroyed&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>应用场景</strong></p>
<ul>
<li><p><strong>安全的引用管理</strong>： 如果类中的某些方法需要返回一个 <code>shared_ptr</code> 指向该类的实例，而调用方已经拥有一个 <code>shared_ptr</code>，直接返回 <code>this</code> 会产生问题，因为 <code>this</code> 不是智能指针。如果多个地方都创建 <code>shared_ptr</code>，对象可能会在引用计数不一致的情况下被提前释放。通过 <code>enable_shared_from_this</code>，可以确保同一个对象的所有 <code>shared_ptr</code> 共享相同的引用计数。</p>
</li>
<li><p><strong>异步操作或回调</strong>： 在异步操作（如网络请求、I&#x2F;O 操作、线程回调）中，如果想确保对象在操作完成之前不会被销毁，可以使用 <code>shared_from_this()</code> 在回调中安全持有对象的 <code>shared_ptr</code>，从而延长对象的生命周期，防止它在异步操作完成前被销毁。</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li><code>shared_from_this()</code> 只能在对象已经通过 <code>shared_ptr</code> 管理时调用。如果在一个尚未通过 <code>shared_ptr</code> 管理的对象上调用 <code>shared_from_this()</code>，则会导致运行时错误（<code>std::bad_weak_ptr</code> 异常）。</li>
<li>当你希望某个对象能够通过多个地方持有它的 <code>shared_ptr</code> 时，继承 <code>enable_shared_from_this</code> 可以避免出现多个 <code>shared_ptr</code> 独立管理同一对象的情况。</li>
</ul>
<h1 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h1><ul>
<li><p><strong>不管理生命周期</strong>：指向一个由<code>shared_ptr</code>管理的对象，但<strong>不会改变shared_ptr的引用计数</strong>。</p>
</li>
<li><p><strong>访问管理对象</strong>：<code>weak_ptr</code> 不能直接访问所管理的对象，但可以通过 <code>lock()</code> 方法获取一个有效的 <code>shared_ptr</code>，然后访问对象。</p>
</li>
</ul>
<h2 id="5-1-循环引用"><a href="#5-1-循环引用" class="headerlink" title="5.1 循环引用"></a>5.1 循环引用</h2><p>循环引用：指两个或多个对象通过 <code>shared_ptr</code> 相互引用，导致它们的引用计数永远不会降为零，从而引发内存泄漏。</p>
<img src="C-智能指针/循环引用1.png" alt="循环引用1" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; ptrB;  <span class="comment">// 指向 B 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; ptrA;  <span class="comment">// 指向 A 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 和 B 互相引用</span></span><br><span class="line">    a-&gt;ptrB = b;</span><br><span class="line">    b-&gt;ptrA = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 这里不会调用析构函数，因为循环引用导致引用计数无法降为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用<code>weak_ptr</code>解决循环引用问题</p>
<img src="C-智能指针/循环引用2.png" alt="循环引用2" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; ptrB;  <span class="comment">// 指向 B 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;A&gt; ptrA;  <span class="comment">// 使用 weak_ptr 代替 shared_ptr</span></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;ptrB = b;</span><br><span class="line">    b-&gt;ptrA = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 正常调用析构函数，解决了循环引用问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-相关成员函数"><a href="#5-2-相关成员函数" class="headerlink" title="5.2 相关成员函数"></a>5.2 相关成员函数</h2><p><code>bool expired() const noexcept;</code></p>
<p>作用：检查 <code>weak_ptr</code> 是否已失效。如果对象已无效（对应的 <code>shared_ptr</code> 引用计数为 0），返回 true，否则返回 false。</p>
<p><code>shared_ptr&lt;element_type&gt; lock() const noexcept;</code></p>
<p>作用：尝试获取指向对象的 <code>shared_ptr</code>。如果对象还有效，则返回一个指向该对象的 <code>shared_ptr</code>；如果对象已无效或<code>weak_ptr</code>指向空，则返回空的 <code>shared_ptr</code>。</p>
<p><code>void reset() noexcept;</code></p>
<p>作用：将 <code>weak_ptr</code> 置为空。</p>
<p><code>long int use_count() const noexcept;</code></p>
<p>作用：返回与 <code>weak_ptr</code> 关联的 <code>shared_ptr</code> 的引用计数（即还有多少个 <code>shared_ptr</code> 引用该对象）。如果对象已失效或<code>weak_ptr</code>指向空，则返回 0。</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类与对象（一）</title>
    <url>/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、面向过程与面向对象编程"><a href="#一、面向过程与面向对象编程" class="headerlink" title="一、面向过程与面向对象编程"></a>一、面向过程与面向对象编程</h1><p>&emsp;我们经常听别人谈起C语言是面向过程的编程语言，而C++是面向对象的编程语言。但是你让他具体说下什么是面向过程、什么是面向对象可能他很难说清楚。今天鄙人拙见谈谈什么是面向过程、什么是面向对象的看法。不管是面向什么都要把程序写出来，那程序是什么？计算机编程领域的祖师爷尼古拉斯•威茨曾经说过<code>程序=数据结构+算法</code>， <strong>所以程序的本质：为了解决某个问题，选择合适的数据结构和算法进行若干步骤的求解</strong>。对于一个问题求解的思路有很多种，<strong>我认为面向过程与面向对象编程的区别就是对问题分析求解的思想不同</strong>。</p>
<span id="more"></span>

<p>&emsp;<strong>面向过程编程：将一个大问题分而治之划分成若干个小问题</strong>。每个小问题需要做某些操作并对数据进行某些处理，所以我们定义函数来解决这些小问题，并在函数里面对数据进行处理。<strong>我们会发现在面向过程的思想一直围绕解决若干个小问题，每个小问题对数据操作处理不一样。所以数据与函数是分开定义的，不能很好的结合在一起</strong>。所以在C语言中数据定义在结构体中，在函数中操作数据。对每个小问题通过不同函数来解决，最终合并起来解决整个大问题，所以我们常常听说面向过程编程就是面向函数编程。</p>
<p>&emsp;<strong>面向对象编程</strong>：道教中有句名言：道生一，一生二，二生三，三生万物。说明万物相互之间是有联系的。面向对象思想采纳了道教的观点，认为不管是看待世界还是看待问题，都是由具有行为的各种对象组成的，<strong>不同类型对象之间互相有着联系</strong>。<strong>每个对象具有某种属性和行为</strong>。例如人是一个对象，那人的名字、年龄、身高、体重等都为人这个对象的属性。人可以做好事情，比如吃饭、喝水、学习、睡觉等都为人这个对象的行为。<strong>我们发现面向对象思想将属性和行为做为一个不可分割的整体，即数据和处理数据的函数不可分割看待。</strong> 人这个对象可以有很多个，例如：张三、李四、王五。<strong>每一个具体对象都有这些相同的属性和行为所以抽象出类这个概念。即类是描述对象属性和行为的，是一个抽象的概论，而对象是类的实例化，是有生命的。</strong></p>
<p>&emsp;上面是我认为的什么是面向过程，什么是面向对象，<strong>总结一句话就是看待问题、解决问题的思想不同。</strong> 我们不能说哪一种好哪一种不好，每个人可以根据自身对问题看法选择。<strong>本人不认同C语言就一定是面向过程的编程语言，C++就一定是面向对象的编程语言的说法。只能说C语言之父丹尼斯·里奇在语言设计时偏向于面向过程的思想。C++之父本贾尼在语言设计时偏向于面向对象的思想。导致语言层面对不同思想支持力度不同</strong>。如果有人问C语言一定不能面向对象编程或C++一定不能面向过程编程那一定是个刚入门的学习者。</p>
<p>&emsp;<strong>另外说明的是，C++的设计思想是面向对象的，但是C++是站在C语言的肩膀上的，对C语言进行了兼容，所以我认为C++是基于面向对象的，而不是像Java一样全面向对象的</strong>。</p>
<h1 id="二、C-对C语言struct的兼容"><a href="#二、C-对C语言struct的兼容" class="headerlink" title="二、C++对C语言struct的兼容"></a>二、C++对C语言struct的兼容</h1><p>上文中说过C++是站在C语言的肩膀上的，对C语言进行了兼容，所以用C语言写的结构体在C++中可以正常运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">struct</span> Person* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span> p1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span> p2;</span><br><span class="line">	<span class="built_in">strcpy</span>(p<span class="number">2.</span>name, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	p<span class="number">2.</span>age = <span class="number">19</span>;</span><br><span class="line">	<span class="built_in">Print</span>(&amp;p1);</span><br><span class="line">	<span class="built_in">Print</span>(&amp;p2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">19</span></span><br></pre></td></tr></table></figure>

<p><strong>C++中<code>struct</code>的本质就是<code>class</code>,所以可以在<code>struct</code>中定义函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, _name, _age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Person</span> p1 = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">19</span></span><br></pre></td></tr></table></figure>

<p><strong>C++中<code>struct</code>与<code>class</code>的唯一区别在下文中有讲解</strong></p>
<h1 id="三、类的定义"><a href="#三、类的定义" class="headerlink" title="三、类的定义"></a>三、类的定义</h1><p>&emsp;C++面向对象的思想，认为对象由属性和行为组成，不能分割看待，并将属性和行为相同的对象抽象出类这个概念。属性和行为都在类里面。在类中定义的属性称为成员变量，类中定义的行为称为成员方法。</p>
<p>语法：<code>class</code>为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类型</span><br><span class="line">&#123;</span><br><span class="line">	属性（成员变量）</span><br><span class="line">	行为（成员方法）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>根据是否在类中定义成员方法将类的定义分为两种</strong></p>
<h2 id="3-1-成员方法的定义在类里面"><a href="#3-1-成员方法的定义在类里面" class="headerlink" title="3.1 成员方法的定义在类里面"></a>3.1 成员方法的定义在类里面</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-成员方法的定义不在类里面"><a href="#3-2-成员方法的定义不在类里面" class="headerlink" title="3.2 成员方法的定义不在类里面"></a>3.2 成员方法的定义不在类里面</h2><p><strong>在项目中推荐这种方式定义类，日常测试时则可以任选一种</strong><br><code>Person.h 头文件</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span>; <span class="comment">// 只在类中声明成员方法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Person.cpp 源文件</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> <span class="comment">// 成员方法的定义 Person为类型 :: 为作用域限定符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">	_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在成员方法的定义时，需要用<code>类型+作用域限定符</code>指明是哪一个作用域里面函数，因为一个类相当于一个作用域</strong></p>
<h1 id="四、类的封装性"><a href="#四、类的封装性" class="headerlink" title="四、类的封装性"></a>四、类的封装性</h1><p>&emsp;面向对象思想中，对象由属性和行为构成。并且不同类型对象之间相关联系。对象之间相互联系并不代表说我一定要把我这个对象的所有细节对你展开。例如：我这个对象实现了吃饭这个行为，另外一个对象实现了开车这个行为。假设存在开车需要先吃饭的联系，你只要开车之前先吃饭就行，不用管这个对象到底如何吃饭的、吃了什么。<strong>在面向对象思想中引入封装性这个概念，即隐藏对象实现的具体细节，只对外提供调用接口</strong>。封装是通过<code>访问限定符</code>实现的</p>
<h2 id="4-1-访问限定符"><a href="#4-1-访问限定符" class="headerlink" title="4.1 访问限定符"></a>4.1 访问限定符</h2><p><strong>访问限定符有三种：public、protected、private 三种类型</strong></p>
<ol>
<li>public修饰的成员在类外可以直接被访问</li>
<li>protected和private修饰的成员在类外不能直接被访问(protected与private的区别在于继承时有所不同)</li>
<li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li>
<li>访问限定符是基于类而不是基于对象的，同一个类的所有对象可以互相访问</li>
<li><strong>class的默认访问权限为private，struct为public(因为struct要兼容C)</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="comment">// 同一个类的所有对象可以互相访问，所以可以访问p的私有成员</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p._name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p._age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1, p2;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 正确，因为成员方法Init访问限定符为public， 类外面可以访问</span></span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 正确，因为成员方法Init访问限定符为public， 类外面可以访问</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print1</span>(); <span class="comment">// 正确，因为成员方法Print1访问限定符为public， 类外面可以访问</span></span><br><span class="line">	p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 错误，因为成员变量_age访问限定符为private， 类外面不可以访问</span></span><br><span class="line">	</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print2</span>(p2); <span class="comment">// 正确，因为成员方法Print2访问限定符为public，类外面可以访问</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-struct与class区别"><a href="#4-2-struct与class区别" class="headerlink" title="4.2 struct与class区别"></a>4.2 struct与class区别</h2><p><strong><code>struct</code>与<code>class</code>都是定义类的关键字，唯一的区别class的默认访问权限与继承方式为private，struct为public(因为struct要兼容C)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, _name, _age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 正确，因为成员方法Init访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 正确，因为成员方法Print访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line">	p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 正确，因为成员变量_age访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 错误，因为成员方法Init访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 错误，因为成员方法Print访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line">	p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 错误，因为成员变量_age访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、对象"><a href="#五、对象" class="headerlink" title="五、对象"></a>五、对象</h1><p><strong>用类创建对象的过程，称为类的实例化</strong></p>
<p>●类是描述对象属性和行为的，是一个抽象的概论，而对象是类的具体实现是有生命的。类是不占内存空间的，而实例化出的对象是占内存空间的。可以把类当作建筑物图纸，对象是根据设计图具体建出来的房子<br>●一个类可以实例化出多个对象,每个对象占用不同内存空间</p>
<h2 id="5-1-对象的大小"><a href="#5-1-对象的大小" class="headerlink" title="5.1 对象的大小"></a>5.1 对象的大小</h2><p>&emsp;对象所占内存空间的大小计算关键看对象里面存放了什么。对象是类的实例化，类由成员变量和成员方法组成。每个对象的属性不同，比如我叫张三，你叫李四。但是行为都是相同的，大家都要吃饭、睡觉等。<strong>每个对象中有没有存放相同成员方法成为计算对象大小关键</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/edb7b7559122540d66bdad794360826d.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>&emsp;每个对象中成员变量是不同的，但是调用相同的成员函数（传入隐藏的this参数区分不同对象），如果按照此种方式一存储，当一个类创建多个对象时，每个对象中都会保存一份相同代码，浪费空间，<strong>所以采用方式二存储：一个对象的所占内存空间大小，是该对象中所有”非静态成员变量”所占空间大小之和（有虚函数时还有加上虚函数表指针大小）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>空类（类中没有成员变量）实例化出来的对象大小为1字节</strong>。因为空类比较特殊，实例化出来的对象没有存储任何东西，但是为了表示这个对象，编译器给了空类的对象一个字节来唯一标识</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout&lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>&emsp;大家会觉得Person类实例化出来对象大小为14字节，因为_name为10字节，_age为4字节加起来就14字节，但结果是16字节。<strong>因为对象中成员变量也要进行内存对齐</strong>， <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tqbDE2Ny9hcnRpY2xlL2RldGFpbHMvMTIzNTM4NzIw">关于内存对齐可参考这篇链接链接<i class="fa fa-external-link-alt"></i></span></p>
<p><font color=#0000FF ><strong>结论：<br>● 一个对象的所占内存空间大小，是该对象中所有“非静态成员变量所占空间大小之和（有虚函数时还有加上虚函数表指针大小）”<br>● 空类（类中没有成员变量）实例化出来的对象大小为1字节<br>● 对象中成员变量也要进行内存对齐</strong></font></p>
<h1 id="六、this指针"><a href="#六、this指针" class="headerlink" title="六、this指针"></a>六、this指针</h1><h2 id="6-1-什么是this指针"><a href="#6-1-什么是this指针" class="headerlink" title="6.1 什么是this指针"></a>6.1 什么是this指针</h2><p>&emsp;回答什么是this指针前先看下面这份代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>&emsp;Person类中有Init与Print两个成员方法，成员方法中没有关于不同对象的区分，那当p1调用Init函数时，该函数是如何知道应该设置p1对象，而不是设置p2对象呢？同理p2调用Print函数时，该函数是如何知道应该打印p2对象的属性，而不是打印p1对象的属性呢？</p>
<p>&emsp;<strong>C++中引入this指针解决该问题，即：C++编译器给每个“非静态的成员方法“增加了一个隐藏的指针参数，让该指针指向当前对象(运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> <span class="comment">//等同于 void Init(Person* const this, const char* name, int age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name); <span class="comment">// 等同于 strcpy(this-&gt;_name, name); </span></span><br><span class="line">		_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">//等同于 void Print(Person* const this)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl; <span class="comment">// 等同于cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;_age &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 等同于 p1.Init(&amp;p1,&quot;张三&quot;, 18);</span></span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>); <span class="comment">// 等同于 p2.Init(&amp;p2,&quot;李四&quot;, 20);</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 等同于p1.Print(&amp;p1);</span></span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>(); <span class="comment">// 等同于p2.Print(&amp;p2);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-this指针的特性"><a href="#6-2-this指针的特性" class="headerlink" title="6.2 this指针的特性"></a>6.2 this指针的特性</h2><h3 id="6-2-1-成员方法不能显性定义this指针或调用时传入对象地址"><a href="#6-2-1-成员方法不能显性定义this指针或调用时传入对象地址" class="headerlink" title="6.2.1 成员方法不能显性定义this指针或调用时传入对象地址"></a>6.2.1 成员方法不能显性定义this指针或调用时传入对象地址</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，编译器会隐式定义this指针作为函数第一个形参，不能手动定义this指针做为形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(Person* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(_name, name); </span><br><span class="line">	_age = age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(&amp;p1,<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 错误，编译器自动会传入对象地址，不能手动传入</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-this指针不可修改"><a href="#6-2-2-this指针不可修改" class="headerlink" title="6.2.2 this指针不可修改"></a>6.2.2 this指针不可修改</h3><p>this指针类型为：<code>类名* const this</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span> = <span class="literal">nullptr</span>; <span class="comment">// 错误，this指针不可以修改</span></span><br><span class="line">	<span class="built_in">strcpy</span>(_name, name); <span class="comment">// 等同于 strcpy(this-&gt;_name, name); </span></span><br><span class="line">	_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-成员方法的形参不要与成员变量同名"><a href="#6-2-3-成员方法的形参不要与成员变量同名" class="headerlink" title="6.2.3 成员方法的形参不要与成员变量同名"></a>6.2.3 成员方法的形参不要与成员变量同名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		错误，成员方法的形参和成员变量同名，局部变量优先级更高，下面name和age都认为是形参的name和age</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(name, name); </span><br><span class="line">		age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>一般建议成员变量名前面加下划线或在成员变量名后面加下划线，与成员方法中的形参做为区别</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name); <span class="comment">// _name不是形参名，则编译器认为_name是成员变量，自动会加上this-&gt;,即 strcpy(this-&gt;_name,name);</span></span><br><span class="line">		_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>下面这种写法不推荐</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		由于成员方法的形参和成员变量同名，局部变量优先级更高，为了避免下面name和age都认为是形参的name和age</span></span><br><span class="line"><span class="comment">		我们用作用域限定符，指明哪个name、age是成员变量的name、age。但是不推荐这种写法，代码可读性、逻辑性较差</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(Person::name, name); <span class="comment">// Person::name 表示name是Person作用域中的name，因为一个类就是一个作用域</span></span><br><span class="line">		Person::age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-可以在非静态成员方法内显式使用this指针"><a href="#6-2-3-可以在非静态成员方法内显式使用this指针" class="headerlink" title="6.2.3 可以在非静态成员方法内显式使用this指针"></a>6.2.3 可以在非静态成员方法内显式使用this指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		在非静态成员方法内可以显性使用this指针，不过没有太大意义，因为编译器默认会用this指针访问成员变量</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;_age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-this指针存放在哪里"><a href="#6-3-this指针存放在哪里" class="headerlink" title="6.3 this指针存放在哪里"></a>6.3 this指针存放在哪里</h2><p>&emsp;this指针本质上其实是一个成员方法的形参，是对象调用成员方法时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。<strong>因为this指针是形参，this指针存放在调用成员方法的栈中，但是部分编译器将this指针存放在寄存器中</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d7a16e59ef8afe91372d10273977a294.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="七、-const-修饰类的成员函数"><a href="#七、-const-修饰类的成员函数" class="headerlink" title="七、 const 修饰类的成员函数"></a>七、 const 修饰类的成员函数</h1><p>&emsp;类的成员函数的隐藏形参this指针类型为：<code>类名* const this</code>,<strong>表示this指针本身不能改变，但是this指针指向的对象可以改变，即对象的成员变量可以改变</strong>。有些时候成员变量不需要改变，为了防止误操作，<strong>可以在成员函数形参列表后面加上const，表示对隐藏形参this指针修饰，此时this指针类型为：<code>const 类名* const this</code>,表明不能对this指针指向的对象里面的成员变量进行修改。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// 使用const修饰</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 枚举全解析：不断演进的enum</title>
    <url>/C-%E6%9E%9A%E4%B8%BE%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%B8%8D%E6%96%AD%E6%BC%94%E8%BF%9B%E7%9A%84Enum.html</url>
    <content><![CDATA[<h1 id="一、枚举快速入门"><a href="#一、枚举快速入门" class="headerlink" title="一、枚举快速入门"></a>一、枚举快速入门</h1><h2 id="1-1-枚举是什么"><a href="#1-1-枚举是什么" class="headerlink" title="1.1 枚举是什么"></a>1.1 枚举是什么</h2><p>​     枚举（<code>enum</code>，全称 <strong>enumeration</strong>）是 C&#x2F;C++ 提供的一种用户自定义数据类型。用户定义一组<strong>具名</strong>的整数标识符（称为“枚举集”、“枚举器常量”、“枚举器”或“成员”），枚举类型的变量存储该类型所定义的枚举集的值之一。</p>
<p>​	 在某些场景下使用枚举更具可读性和可维护性，例如：表示状态机、定义程序错误码、位掩码等。</p>
<h2 id="1-2-枚举的使用"><a href="#1-2-枚举的使用" class="headerlink" title="1.2 枚举的使用"></a>1.2 枚举的使用</h2><p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> [<span class="title">identifier</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		enumerator-<span class="built_in">list</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>identifier</em> : 可选，枚举类型名，如果没有指定，则为匿名枚举</p>
<p><em>enumerator-list</em>：定义枚举集的成员</p>
<span id="more"></span>

<p>下面的规则适用于枚举集的成员：</p>
<ul>
<li>第一个枚举常量的默认值为0，后续的枚举常量值默认为上一个枚举常量值+1</li>
</ul>
<ul>
<li>枚举集可以包含重复的常量值。例如，可以将值 0 与两个不同的标识符关联，但不推荐这样做</li>
<li>一个枚举集下所有枚举常量类型相同，在 ANSI C 中，类型始终为<code>int</code></li>
</ul>
<p><strong>推荐枚举常量名为全大写</strong>。</p>
<p>示例1：使用枚举表示星期</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span>            </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SATURDAY,      </span><br><span class="line">    SUNDAY = <span class="number">0</span>,     </span><br><span class="line">    MONDAY,        </span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,      </span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，值 0 与 <code>saturday</code> 关联。 标识符 <code>sunday</code> 将显式设置为 0。 默认情况下，将为剩余标识符提供从 1 到 5 的值。</p>
<p>示例2: 使用枚举表示交通信号灯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLight</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,         <span class="comment">// 值为0</span></span><br><span class="line">    YELLOW = <span class="number">2</span>,  <span class="comment">// 值为2</span></span><br><span class="line">    GREEN       <span class="comment">// 值为3    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkLight</span><span class="params">(TrafficLight light)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (light)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RED:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stop!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> YELLOW:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Get ready!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GREEN:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Go!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid signal!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TrafficLight signal = RED; <span class="comment">// 如果为C语言, 定义枚举变量需要在枚举类型前加 enum 关键字</span></span><br><span class="line">    <span class="built_in">checkLight</span>(signal);        <span class="comment">// 输出 &quot;Stop!&quot;</span></span><br><span class="line"></span><br><span class="line">    signal = GREEN;</span><br><span class="line">    <span class="built_in">checkLight</span>(signal);        <span class="comment">// 输出 &quot;Go!&quot;</span></span><br><span class="line">  </span><br><span class="line">    RED = <span class="number">4</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个例子我们发现：<strong>枚举常量的值是不可变的，枚举变量的值是可以变的</strong>。</p>
<h2 id="1-3-枚举存在的问题"><a href="#1-3-枚举存在的问题" class="headerlink" title="1.3 枚举存在的问题"></a>1.3 枚举存在的问题</h2><h3 id="1-3-1-作用域污染"><a href="#1-3-1-作用域污染" class="headerlink" title="1.3.1  作用域污染"></a>1.3.1  作用域污染</h3><p>枚举没有自己的作用域，编译器会把内部定义的枚举常量标识符导出到该枚举所在的作用域，这样虽然方便使用，但会导致名称冲突，造成作用域污染问题。</p>
<p>下面是一个作用域污染的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> <span class="comment">// 内部枚举常量被导出到Color所在作用域，即全局作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, </span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLight</span> <span class="comment">// 内部枚举常量被导出到TrafficLight所在作用域，即全局作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, <span class="comment">// ⚠️ 和 Color::RED 冲突</span></span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN <span class="comment">// ⚠️ 和 Color::GREEN 冲突</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> color = RED; <span class="comment">// ❌ 编译错误，RED 不明确（Color::RED or TrafficLight::RED？）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中解决此类问题的一个办法是使用命名空间，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kxl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TrafficLight</span></span><br><span class="line">    &#123;</span><br><span class="line">        RED, </span><br><span class="line">        YELLOW,</span><br><span class="line">        GREEN</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-隐式转换存在风险"><a href="#1-3-2-隐式转换存在风险" class="headerlink" title="1.3.2 隐式转换存在风险"></a>1.3.2 隐式转换存在风险</h3><p>虽然枚举存在一定的安全检查功能，一种枚举类型下的成员不允许分配到另外一种枚举类型的变量中。<strong>但C&#x2F;C++中枚举支持隐式转换，即一个枚举类型可以隐式转换为整型。甚至C语言支持整形可以隐式转换为枚举类型</strong>。隐式转换会带来一系列潜在的安全问题，从而导致不易察觉的错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">School</span></span><br><span class="line">&#123;</span><br><span class="line">    STUDENT,</span><br><span class="line">    TEACHER,</span><br><span class="line">    PRINCIPAL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Company</span></span><br><span class="line">&#123;</span><br><span class="line">    EMPLOYEE,</span><br><span class="line">    MANAGER,</span><br><span class="line">    CHAIRMAN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    School x = STUDENT;</span><br><span class="line">    Company y = MANAGER;</span><br><span class="line">    <span class="type">bool</span> b = x &gt;= PRINCIPAL; <span class="comment">// 编译通过，合理，相同枚举类型比较</span></span><br><span class="line">    b = x &lt; y; <span class="comment">// 编译通过，但不合理，它们没有可比性</span></span><br><span class="line">    <span class="type">int</span> z = STUDENT; <span class="comment">// 编译通过</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>b = x &lt; y</code>没有编译报错是因为枚举类型先被隐式转换为整型，然后才进行比较。对于<code>int z = STUDENT</code>也是一样的。</p>
<p>下面代码在C++中编译错误，但在C语言中编译通过，因为C语言整形可以隐式转换为枚举类型，该代码带来的破坏性是不可预知的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">School</span> <span class="title">s</span> =</span> CHAIRMAN; <span class="comment">// CHAIRMAN隐式转为整数2，2被隐式转为枚举常量PRINCIPAL，可能造成灾难性破坏。</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// 10被隐式转为枚举类型，School内不存在值为10的枚举常量，灾难性破坏</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-无法指定枚举的底层类型"><a href="#1-3-3-无法指定枚举的底层类型" class="headerlink" title="1.3.3 无法指定枚举的底层类型"></a>1.3.3 无法指定枚举的底层类型</h3><p>枚举的底层类型决定了它所占用的内存大小和能表示的数值范围。在 ANSI C 中，底层类型为<code>int</code>。不同的编译器对于相同枚举类型可能会使用不同的底层类型，这会造成可移植性问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">		RED = <span class="number">0xFFFFFFFF</span>		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个编译器对<code>Color</code>底层使用有符号数，那么值为*-1*。如果另一个编译器使用无符号数，那么值为<em>4294967295</em>。</p>
<h1 id="二、现代C"><a href="#二、现代C" class="headerlink" title="二、现代C++"></a>二、现代C++</h1><h2 id="2-1-C-11"><a href="#2-1-C-11" class="headerlink" title="2.1 C++ 11"></a>2.1 C++ 11</h2><p>​        由于枚举存在上述所说的种种问题，在<code>C++ 11</code>中提出强枚举类型，它具有更严格的类型检查和作用域控制。另外，为了保证代码的兼容性，也保留了<code>C++ 11</code>之前枚举的特性，我们称为传统枚举。强枚举类型定义非常简单，只需要在枚举定义的<code>enum</code>关键字之后加上<code>class</code>或<code>struct</code>关键字即可。</p>
<p><strong>强枚举类型</strong>具备以下新特性：</p>
<ul>
<li><p>枚举有作用域，即枚举名， 不能在外部直接访问枚举常量</p>
</li>
<li><p>枚举类型不会隐式转换为整型。</p>
</li>
<li><p>可以指定枚举的底层类型，底层类型默认为<code>int</code></p>
</li>
<li><p>不允许匿名，即必须要有<em>identifier</em></p>
</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> [<span class="keyword">class</span>|<span class="keyword">struct</span>] [identifier] [: type]</span><br><span class="line">&#123;</span><br><span class="line">		enumerator-list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>C++ 11</code>中传统枚举也可以指定底层类型，但如果未指定，底层类型由编译器选择，这是为了兼容<code>C++ 11</code>之前代码。</p>
</blockquote>
<p>下面是一个演示强枚举类型的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">uint8_t</span> <span class="comment">// 指定底层类型为uint8_t</span></span><br><span class="line">&#123;             </span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLight</span> <span class="comment">// 底层类型默认使用int</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,  <span class="comment">// 该枚举常量在作用域TrafficLight中</span></span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN <span class="comment">// 该枚举常量在作用域TrafficLight中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color x1 = RED; <span class="comment">// 错误，必须指定RED的作用域</span></span><br><span class="line">    Color x2 = Color::RED; <span class="comment">// 正确</span></span><br><span class="line">    TrafficLight y1 = Color::RED; <span class="comment">// 错误，类型不匹配。</span></span><br><span class="line">    TrafficLight y2 = TrafficLight::RED; <span class="comment">// 正确</span></span><br><span class="line">    <span class="type">bool</span> b = x2 &gt; y2; <span class="comment">// 错误，强枚举类型不会隐式转换为整型。</span></span><br><span class="line">    <span class="type">int</span> i = x2; <span class="comment">// 错误，强枚举类型不会隐式转换为整型。</span></span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(x2); <span class="comment">// 正确，可以强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>C23</code>支持指定枚举的底层类型。</p>
</blockquote>
<h2 id="2-2-C-17"><a href="#2-2-C-17" class="headerlink" title="2.2 C++ 17"></a>2.2 C++ 17</h2><p>​         <code>C++ 17</code> 允许对有底层类型的枚举对象使用<a href="https://blog.kjlcloud.com/C-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96.html">列表初始化</a>。强枚举类型天生符合条件，因为它默认的底层类型为<code>int</code>，而传统枚举必须显式指定底层类型才符合条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLight</span> : <span class="type">u_int8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,         <span class="comment">// 值为0</span></span><br><span class="line">    YELLOW = <span class="number">2</span>,  <span class="comment">// 值为2</span></span><br><span class="line">    GREEN       <span class="comment">// 值为3    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color c&#123;<span class="number">5</span>&#125;;     <span class="comment">// 编译成功，强枚举类型，没有显式指定了底层类型，则使用默认类型int</span></span><br><span class="line">    Color c1 = <span class="number">5</span>;   <span class="comment">// 编译失败</span></span><br><span class="line">    Color c2 = &#123;<span class="number">5</span>&#125;; <span class="comment">// 编译失败</span></span><br><span class="line">    <span class="function">Color <span class="title">c3</span><span class="params">(<span class="number">5</span>)</span></span>;    <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">    TrafficLight t&#123;<span class="number">5</span>&#125;; <span class="comment">// 编译成功，虽然为传统枚举，但显式指定了底层类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果定义<code>Color c1&#123;3.14&#125;</code>会编译失败，因为列表初始化禁止缩窄转换。另外我们注意到<em>c</em>与<em>t</em>的值为5，但是它们对应的枚举类型中没有哪一个枚举常量的值为5。<code>C++ 11</code>为了枚举的安全性，对枚举做的严格限制被打破了，那么<code>C++ 17</code>为什么要这么做？</p>
<p>现在假设一个场景，我们需要一个新整数类型，该类型不能与其他类型做隐式转换，从而消除无意的隐式转换导致细微错误的可能。显然使用<code>typedef</code>的方法是不行的。另外，虽然通过定义一个类的方式达到这个目的，但是这个方法需要编写大量的代码来重载运算符，也不是一个理想的方案。所以，C++的专家把目光投向了可以指定底层类型的枚举身上，枚举的特性几乎完美地符合以上要求，除了初始化时需要强制类型转换。于是，<code>C++ 17</code>为有底层类型的枚举放宽了初始化的限制，允许使用列表初始化。在<code>C++ 17</code>种新引入的<code>std::byte</code>类型就是用这种方法，下面是简单模拟实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">byte</span> : <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    byte b1&#123;<span class="number">3</span>&#125;; <span class="comment">// 正确</span></span><br><span class="line">    byte b2&#123;<span class="number">5</span>&#125;; <span class="comment">// 正确</span></span><br><span class="line">    b1 = b2; <span class="comment">// 正确</span></span><br><span class="line">    </span><br><span class="line">    b1 = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">int</span> i = b1; <span class="comment">// 错误，枚举不允许隐式转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-C-20"><a href="#2-3-C-20" class="headerlink" title="2.3 C++ 20"></a>2.3 C++ 20</h2><p><code>C++ 20</code>扩展了<code>using</code>功能，它可以引入<strong>强枚举类型</strong>的成员。在一些情况下，这样做会让代码更加简洁易读。</p>
<p><code>using enum 强制枚举类型名</code> : 将全部枚举常量引入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLight</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,        <span class="comment">// 值为0</span></span><br><span class="line">    YELLOW = <span class="number">2</span>, <span class="comment">// 值为2</span></span><br><span class="line">    GREEN       <span class="comment">// 值为3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkLight</span><span class="params">(TrafficLight light)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">TrafficLight</span>; <span class="comment">// 将全部枚举常量引入，后续使用无需指定命名空间</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (light)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RED:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stop!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> YELLOW:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Get ready!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GREEN:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Go!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid signal!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>using 强制枚举类型::枚举常量标识符</code> : 将指定枚举常量引入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLight</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,        <span class="comment">// 值为0</span></span><br><span class="line">    YELLOW = <span class="number">2</span>, <span class="comment">// 值为2</span></span><br><span class="line">    GREEN       <span class="comment">// 值为3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkLight</span><span class="params">(TrafficLight light)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> TrafficLight::RED; <span class="comment">// 将RED引入，后续使用无需指定命名空间</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (light)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RED:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stop!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TrafficLight::YELLOW:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Get ready!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TrafficLight::GREEN:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Go!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid signal!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>谢丙堃 &lt;&lt;现代C++语言核心特性解析&gt;&gt;</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2NwcC9jLWxhbmd1YWdlL2MtZW51bWVyYXRpb24tZGVjbGFyYXRpb25z">microsoft  C++ 语言文档<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>如涉及版权问题，版权所有为原作者</strong></p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
        <tag>C++ 20</tag>
        <tag>C++ 11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类与对象（三）</title>
    <url>/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、深度刨析构造函数"><a href="#一、深度刨析构造函数" class="headerlink" title="一、深度刨析构造函数"></a>一、深度刨析构造函数</h1><h2 id="1-1-编译器对构造函数的优化"><a href="#1-1-编译器对构造函数的优化" class="headerlink" title="1.1 编译器对构造函数的优化"></a>1.1 编译器对构造函数的优化</h2><p>&emsp;<strong>比较新的C++编译器在一行语句里面，若存在连续的构造函数（拷贝构造函数）调用，编译器对其优化为一次调用。注意：C++标准并没有规定必须要进行优化</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/ce31e632225d131eb3f89045ccee8df7.png#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p>下面测试用例的编译器进行了优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">test</span><span class="params">(Person obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	Person p2 = <span class="built_in">test</span>(p1);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>下面测试用例不是连续的构造函数（拷贝构造函数）调用，编译器不能优化<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ed6bd1c9d012659a732537254cb5d8bc.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">test</span><span class="params">(Person obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">	p2 = <span class="built_in">test</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">赋值运算符重载</span><br></pre></td></tr></table></figure>
<h2 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h2><h3 id="1-2-1-什么是初始化列表"><a href="#1-2-1-什么是初始化列表" class="headerlink" title="1.2.1 什么是初始化列表"></a>1.2.1 什么是初始化列表</h3><p>&emsp;如果问大家类的对象是在什么时候定义初始化的，大家都能回答上来，是在调用构造函数（拷贝构造函数）时初始化的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p1; <span class="comment">// 调用默认构造函数对p1初始化</span></span><br><span class="line">Person p2 = p1; <span class="comment">// 调用拷贝构造函数对p2初始化   </span></span><br></pre></td></tr></table></figure>

<p>&emsp;那么对象的成员变量在什么时候定义初始化呢，我们一般习惯认为在构造函数（拷贝构造函数）体内初始化成员变量，然而这种想法是错误的，这只是对成员变量赋值而不是初始化。<strong>成员变量真正的初始化是在初始化列表进行的。初始化列表位于形参列表之后，函数体{ }之前，这也说明初始化列表进行的工作发生在函数体内任何代码执行之前</strong>。</p>
<h3 id="1-2-2-初始化列表定义"><a href="#1-2-2-初始化列表定义" class="headerlink" title="1.2.2 初始化列表定义"></a>1.2.2 初始化列表定义</h3><p>初始化列表定义语法：<strong>以冒号开始，每个成员变量初始化由变量名+括号，括号内是初始值，成员变量间用逗号隔开</strong></p>
<p>● 没有显式定义在初始化列表中成员变量，编译器对内置类型初始化为随机值，自定义类型调用其默认构造函数<br>● 每个成员变量在初始化列表中只能出现一次（初始化只能一次）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">		: _year(year)</span><br><span class="line">		, _month(month)</span><br><span class="line">		, _day(day)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">const</span> Date&amp; obj)</span><br><span class="line">		: _year(obj._year)</span><br><span class="line">		, _month(obj._month)</span><br><span class="line">		, _day(obj._day)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-必须使用初始化列表场景"><a href="#1-2-3-必须使用初始化列表场景" class="headerlink" title="1.2.3 必须使用初始化列表场景"></a>1.2.3 必须使用初始化列表场景</h3><p><strong>成员变量为以下情况，成员变量必须放在初始化列表中进行初始化：</strong><br>● 成员变量为引用（引用必须在定义时初始化）<br>● 成员变量为const(C++中const变量必须在定义时初始化)<br>● 成员变量为自定义类型且没有默认构造函数（不显式在初始化列表中定义，编译器会自动调用其默认构造函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> val)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>&amp; _a;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> _b;</span><br><span class="line">	A _c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span>&amp; a, <span class="type">int</span> b, <span class="type">int</span> c)</span><br><span class="line">		:_a(a)</span><br><span class="line">		,_b(b)</span><br><span class="line">		,_c(c)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-推荐使用初始化列表场景"><a href="#1-2-4-推荐使用初始化列表场景" class="headerlink" title="1.2.4 推荐使用初始化列表场景"></a>1.2.4 推荐使用初始化列表场景</h3><p>&emsp;<strong>成员变量类型为自定义类型推荐使用初始化列表</strong>，<strong>如果不使用初始化列表</strong>：编译器调用成员变量的默认构造函数，并在函数体内调用赋值运算符重载进行赋值，<strong>开销2次</strong>。<strong>使用初始化列表</strong>：在初始化列表中调用成员变量的构造函数，函数体内不需要赋值，<strong>开销1次</strong></p>
<p><strong>测试：不使用初始化列表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = obj._x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = obj._x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line">	A _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day,<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		_a = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2020</span>, <span class="number">01</span>, <span class="number">02</span>, a)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用类A构造函数</span><br><span class="line">调用类A构造函数</span><br><span class="line">调用类A赋值运算符重载</span><br></pre></td></tr></table></figure>
<p><strong>测试：使用初始化列表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = obj._x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = obj._x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用类A赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line">	A _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day,<span class="type">const</span> A&amp; a)</span><br><span class="line">		: _a(a)</span><br><span class="line">	&#123;</span><br><span class="line">		_year = year;</span><br><span class="line">		_month = month;</span><br><span class="line">		_day = day;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2020</span>, <span class="number">01</span>, <span class="number">02</span>, a)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用类A构造函数</span><br><span class="line">调用类A拷贝构造函数</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-成员变量的初始化顺序"><a href="#1-2-5-成员变量的初始化顺序" class="headerlink" title="1.2.5 成员变量的初始化顺序"></a>1.2.5 成员变量的初始化顺序</h3><p>&emsp;<strong>成员变量的初始化顺序由类中成员变量声明次序决定，与其在初始化列表中的先后次序无关。所以推荐初始化列表中成员变量次序与类中声明次序一致</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> val)</span><br><span class="line">		: _y(val)</span><br><span class="line">		, _x(_y)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; _y = &quot;</span> &lt;&lt; _y &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	a.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_x = <span class="number">-858993460</span> _y = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;在初始化列表中_y的次序在_x前，如果成员变量初始化次序由初始化列表中次序决定，先将形参val值初始化给_y,然后将_y值初始化给_x，所以_x&#x3D;_y&#x3D;val。但观察输出结果发现_x为随机值，_y&#x3D;val,因为类中_x声明次序在_y前面，所以先将_y的值初始化给_x,此时_y为随机值,所以_x也为随机值,然后将val值初始化给_y</p>
<h1 id="二、static"><a href="#二、static" class="headerlink" title="二、static"></a>二、static</h1><p>&emsp;<strong>类中用static修饰的成员变量称为静态成员变量，用static修饰的成员函数称为静态成员函数</strong></p>
<h2 id="2-1-静态成员变量"><a href="#2-1-静态成员变量" class="headerlink" title="2.1 静态成员变量"></a>2.1 静态成员变量</h2><p>● 静态成员变量为类中所有对象共享，对象中不存储静态成员变量<br>● 静态成员变量必须在类外定义并初始化且不需要加static关键字<br>● 静态成员变量可用对象或类名访问,前提是静态成员变量控制权限为public</p>
<p>下面程序为统计创建出多少个类对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _sCount; <span class="comment">// 静态成员变量的声明，为了测试对象或类访问变量，控制权限给的public，一般不建议给public</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		++_sCount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		++_sCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; A::_sCount &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过类名访问</span></span><br><span class="line">	A a1;</span><br><span class="line">	A a2;</span><br><span class="line">	<span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; a<span class="number">3.</span>_sCount &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过对象访问</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">已创建：<span class="number">0</span>个对象</span><br><span class="line">已创建：<span class="number">3</span>个对象</span><br></pre></td></tr></table></figure>
<h2 id="2-2-静态成员函数"><a href="#2-2-静态成员函数" class="headerlink" title="2.2 静态成员函数"></a>2.2 静态成员函数</h2><p>● 静态成员函数没有隐藏的this形参，不能访问任何非静态成员变量<br>● 静态成员函数和类的普通成员函数一样，也有public、protected、private3种访问级别，也可以具有返回值<br>● 静态成员函数可用对象或类名访问,前提是静态成员函数控制权限为public<br>●  静态成员函数内不能调用非静态成员函数(静态成员函数没有隐藏this形参)<br>● 非静态成员函数内可以调用静态成员函数（非静态成员函数有隐藏this形参）</p>
<p>上面统计创建出多少个类对象的程序，_sCount给的public控制权限封装性不好，程序修改为_sCount控制权限为private,通过静态成员函数去访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _sCount; <span class="comment">// 静态成员变量的声明，为了测试对象或类访问变量，控制权限给的public，一般不建议给public</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		++_sCount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">A</span>(A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		++_sCount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetACount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		<span class="keyword">return</span> _sCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; A::<span class="built_in">GetACount</span>() &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过类名访问</span></span><br><span class="line">	A a1;</span><br><span class="line">	A a2;</span><br><span class="line">	<span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; a<span class="number">3.</span><span class="built_in">GetACount</span>() &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过对象访问</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">已创建：<span class="number">0</span>个对象</span><br><span class="line">已创建：<span class="number">3</span>个对象</span><br></pre></td></tr></table></figure>
<h1 id="三、C-11-成员变量初始化新玩法"><a href="#三、C-11-成员变量初始化新玩法" class="headerlink" title="三、C++11 成员变量初始化新玩法"></a>三、C++11 成员变量初始化新玩法</h1><p>&emsp;<strong>C++11 之前令人诟病的是编译器生成的默认构造函数对于类型为内置类型成员变量不进行初始化处理</strong>，若需对内置类型成员变量初始化需要手动定义构造函数，在构造函数的初始化列表对成员变量初始化(构造函数体内对成员变量赋值)。<strong>C++11 引入非静态成员变量在类中声明时给缺省值的玩法，当在构造函数中没有显式对成员变量初始化（赋值）则用缺省值初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _sCount; </span><br><span class="line">	<span class="type">int</span> _x = <span class="number">1</span>; <span class="comment">// 在声明时给缺省值</span></span><br><span class="line">	<span class="type">int</span> _y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;_sCout = &quot;</span> &lt;&lt; _sCount &lt;&lt; <span class="string">&quot; _x = &quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; _y = &quot;</span> &lt;&lt; _y &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">Print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_sCout = <span class="number">0</span> _x = <span class="number">1</span> _y = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="四、友元"><a href="#四、友元" class="headerlink" title="四、友元"></a>四、友元</h1><p>&emsp;<strong>友元可以让函数突破类的封装性，能访问任何控制权限（public、protected、private）的成员，在某些场景下提供了便利，但破坏了封装性，一般不推荐使用</strong></p>
<h2 id="4-1-友元函数"><a href="#4-1-友元函数" class="headerlink" title="4.1 友元函数"></a>4.1 友元函数</h2><p>&emsp;我们可以用<code>&lt;&lt;</code>运算符配合<code>cout</code>打印内置类型变量，但如果要打印自定义类型，需要对<code>&lt;&lt;</code>进行运算符重载。当重载为成员函数时会带来问题，因为非静态成员函数默认第一个形参为隐藏this指针，调用时编译器会将左操作数地址传给隐藏的形参this指针，this指针类型为 <code>类名* const</code> ,而左操作数<code>cout</code>对象类型为<code>ostream</code>，类型不匹配，只能通过函数名，或交换左右操作数位置方式调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; _x &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a &lt;&lt; endl; 错误，左操作数地址类型为ostream* ， 隐藏形参this类型为 A*</span></span><br><span class="line">	a.<span class="keyword">operator</span>&lt;&lt;(cout); <span class="comment">// 正确</span></span><br><span class="line">	a &lt;&lt; cout; <span class="comment">// 正确，调用时将左操作数地址传给隐藏形参this,右操作数传给形参out</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;由于运算符重载为非静态成员函数都有隐藏this形参，而<code>&lt;&lt;</code>运算符左操作数为<code>cout</code>。类型不匹配，只能将运算符重载为全局函数，但由于成员变量访问权限为<code>非public</code>，类外不能访问成员变量。这种场景可以使用友元函数，<strong>友元函数：能访问任何控制权限（public、protected、private）的成员，它是定义在类外部的普通函数，不属于任何类，但需要在对应类里面进行函数声明，声明时需要加friend关键字</strong></p>
<p>● 友元函数可以在类里面任何地方声明，不受类访问限定符限制<br>● 一个函数可以是多个类的友元函数<br>● 友元函数不能用const修饰，因为没有this指针</p>
<p><code>友元函数写法一：在类中声明友元函数，类外定义友元函数</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, A&amp; obj); <span class="comment">// 在类中声明友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,A&amp; obj) <span class="comment">// 友元函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; obj._x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_x = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>友元函数写法二：在类中声明并定义友元函数</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,A&amp; obj) <span class="comment">// 友元函数定义</span></span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; obj._x &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-2-友元类"><a href="#4-2-友元类" class="headerlink" title="4.2 友元类"></a>4.2 友元类</h2><p>&emsp; 类A是类B的友元，则称类A为类B的友元类。友元类所有成员函数可以访问另一个类的任何控制权限（public、protected、private）的成员</p>
<p>● 友元关系是单向的(A是B的友元类，A可以访问B，但B不能访问A的非public的成员)<br>● 友元关系不能传递(A是B的友元，B是C的友元，不能说明A是C的友元)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>; <span class="comment">// 声明类A是类B的友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;_b = &quot;</span> &lt;&lt; b._b &lt;&lt; endl; <span class="comment">// 可以访问类B的任何权限的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h1><p>&emsp;<strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。内部类只是定义在外部类里面，它不属于外部类，不能通过外部类的对象去访问内部类。</strong></p>
<p>● 内部类就是外部类的友元类,外部类不是内部类的友元类<br>● 外部类可以使用访问限定符public、protected、private限定内部类<br>● 内部类可以直接访问外部类的静态成员，不需要用外部类的对象&#x2F;类名<br>● 内部类只是定义在外部类里面而已，并不占用外部类的空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> _sCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> _b;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(A&amp; obj)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; _sCount &lt;&lt; endl; <span class="comment">// 直接访问外部类静态成员变量</span></span><br><span class="line">			cout &lt;&lt; obj._a &lt;&lt; endl; <span class="comment">// 通过对象访问成员变量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A::B b; <span class="comment">// 正确，类B访问权限为public，通过作用域限定符::访问类A中的类B并初始化对象b</span></span><br><span class="line">	<span class="comment">// A::C c 错误，类C访问权限为private </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 类与对象（二）</title>
    <url>/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p><strong>前言：C++编译器默认在类中生成六个特殊的成员函数，如果在类中显式定义相对应的成员函数，编译器则不会生成对应成员函数</strong></p>
<h1 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h1><h2 id="1-1-什么是构造函数"><a href="#1-1-什么是构造函数" class="headerlink" title="1.1 什么是构造函数"></a>1.1 什么是构造函数</h2><p>&emsp;根据经验，不少难以察觉的程序错误都是由于变量没有正确初始化导致的，而初始化工作很容易被人遗忘。<strong>C++中引入构造函数的概念，构造函数是一个特殊的成员函数，函数名与类名相同,实例化对象时由编译器自动调用构造函数，保证对象中的成员变量都被正确初始化。构造函数在对象的生命周期内只调用一次。注意：构造函数的作用是初始化对象，而不是为对象分配内存空间。</strong></p>
<p>&emsp;构造函数不显式定义时由编译器自动生成，当显式定义构造函数时，编译器不会自动生成。构造函数的<strong>函数名必要与类名一致</strong>，并且<strong>没有返回值</strong>（void也不行)。</p>
<span id="more"></span>

<h2 id="1-2-构造函数特性"><a href="#1-2-构造函数特性" class="headerlink" title="1.2 构造函数特性"></a>1.2 构造函数特性</h2><h3 id="1-2-1-构造函数支持函数重载"><a href="#1-2-1-构造函数支持函数重载" class="headerlink" title="1.2.1 构造函数支持函数重载"></a>1.2.1 构造函数支持函数重载</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age) <span class="comment">// 带参数的构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name,name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-实例化对象时编译器自动调用对应的构造函数"><a href="#1-2-2-实例化对象时编译器自动调用对应的构造函数" class="headerlink" title="1.2.2 实例化对象时编译器自动调用对应的构造函数"></a>1.2.2 实例化对象时编译器自动调用对应的构造函数</h3><p><strong>对象生命周期内只会调用一次构造函数，编译器在实例化对象时根据传入参数个数选择匹配的构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age) <span class="comment">// 带参数的构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name,name);</span><br><span class="line">		_age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用带参数的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 调用无参构造函数</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用无参构造函数</span><br><span class="line">调用带参数的构造函数</span><br></pre></td></tr></table></figure>
<p>说明：实例化对象调用无参构造函数不能这种方式写<code>Person p1();</code>因为编译器会认为这个是函数声明，Person是函数返回类型，p1为函数名。只能这样方式写<code>Person p1;</code>才调用无参构造函数，虽然看起来语法有些奇怪</p>
<h3 id="1-2-3-默认构造函数"><a href="#1-2-3-默认构造函数" class="headerlink" title="1.2.3 默认构造函数"></a>1.2.3 默认构造函数</h3><p><strong>构造函数的形参列表为空称为默认构造函数，默认构造函数有3种，一个类中默认构造函数只能有一个，推荐使用全缺省的默认构造函数</strong></p>
<p>1.类中没有显式定义构造函数，则C++编译器会自动生成一个无参的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 调用编译器生成的默认构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在类中显式定义一个无参构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 调用显式定义的默认构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在类中定义一个全缺省的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 调用显式全缺省的默认构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-编译器生成的默认构造函数的功能"><a href="#1-3-编译器生成的默认构造函数的功能" class="headerlink" title="1.3 编译器生成的默认构造函数的功能"></a>1.3 编译器生成的默认构造函数的功能</h2><p>&emsp;在类中不显式定义构造函数，编译器生成默认构造函数。<strong>这个构造函数对于对象中内置类型成员变量不做任何初始化，如果成员变量为自定义类型则调用它的默认构造函数</strong></p>
<p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是类A的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">	A ob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">这是类A的构造函数</span><br><span class="line">年龄：<span class="number">-858993460</span></span><br></pre></td></tr></table></figure>
<p>编译器生成Person类的默认构造函数对于内置类型成员变量没有任何处理，所以_age打印出来是随机值，ob为自定义类型，所以调用了ob对应的默认构造函数</p>
<h2 id="1-4-explicit关键字"><a href="#1-4-explicit关键字" class="headerlink" title="1.4 explicit关键字"></a>1.4 explicit关键字</h2><p>&emsp;<strong>使用<code>explicit</code>关键字修饰的构造函数将禁止隐式类型转换，只能以显式的方式进行类型转换</strong>。<code>explicit</code>只能在类内部使用，即构造函数的声明与定义分离，只能在声明前面加<code>explicit</code>修饰。</p>
<h3 id="1-4-1-隐式类型转换"><a href="#1-4-1-隐式类型转换" class="headerlink" title="1.4.1 隐式类型转换"></a>1.4.1 隐式类型转换</h3><p>c++支持隐式类型转换，即根据类型A变量的值创建一个类型B的临时变量，并将该临时变量赋值给某个类型B变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _a = a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = &#123;<span class="number">3</span>&#125;; <span class="comment">// 隐式类型转换</span></span><br><span class="line">    A b = <span class="number">4</span>;   <span class="comment">// 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5c762a283064d976d49c02a2baccae0.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-2-禁止构造函数隐式类型转换"><a href="#1-4-2-禁止构造函数隐式类型转换" class="headerlink" title="1.4.2 禁止构造函数隐式类型转换"></a>1.4.2 禁止构造函数隐式类型转换</h3><p>例1： 构造函数只有单个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _a = a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = &#123;<span class="number">3</span>&#125;; <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A b = <span class="number">4</span>;   <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A c = (A)<span class="number">3</span>; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line">    A D = (A)&#123;<span class="number">4</span>&#125;; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例2： 构造函数有多个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> : _a(a), _b(b) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A b = (A)&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、析构函数"><a href="#二、析构函数" class="headerlink" title="二、析构函数"></a>二、析构函数</h1><p>&emsp;根据经验，动态申请的内存空间在使用结束后往往忘记释放，造成内存泄漏的问题。<strong>C++中引入析构函数的概念，析构函数是一个特殊的成员函数，函数名在类名基础上加前缀<code>~</code>。对象生命周期结束时，C++编译器自动调用析构函数。注意：对象销毁工作是由编译器完成的，析构函数作用是在对象销毁前完成某些资源清理</strong></p>
<p>&emsp;析构函数不显式定义时由编译器自动生成，当显式定义构造函数时，编译器不会自动生成。析构函数的<strong>函数名在类名前加上字符 ~</strong>，并且<strong>没有返回值</strong>（void也不行)，<strong>没有形参</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 10  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line">	<span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line">	<span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SeqList</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * initSize);</span><br><span class="line">		_size = <span class="number">0</span>;</span><br><span class="line">		_capacity = initSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SeqList</span>() <span class="comment">// 析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(_data); <span class="comment">// 释放动态内存分配的空间</span></span><br><span class="line">		_data = <span class="literal">nullptr</span>;</span><br><span class="line">		_size = <span class="number">0</span>;</span><br><span class="line">		_capacity = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-编译器生成的析构函数的功能"><a href="#2-1-编译器生成的析构函数的功能" class="headerlink" title="2.1 编译器生成的析构函数的功能"></a>2.1 编译器生成的析构函数的功能</h2><p>&emsp;<strong>在类中不显式定义析构函数，编译器自动生成析构函数。这个构造函数对于对象中内置类型成员变量不做处理，如果成员变量为自定义类型则调用它的析构函数</strong></p>
<p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是类A的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">	A ob;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">这是类A的析构函数</span><br></pre></td></tr></table></figure>
<h1 id="三、拷贝构造函数"><a href="#三、拷贝构造函数" class="headerlink" title="三、拷贝构造函数"></a>三、拷贝构造函数</h1><p>&emsp;在生活中我们有时候会想，如果能够复制一个一模一样的自己那该多好。可以替我学习、替我工作。当然这只是人的幻想罢了，但在C++中可以梦想成真。<strong>C++中引入了拷贝构造函数的概念，用一个已存在的对象创建新对象时，由编译器自动调用拷贝构造函数，创建的新对象与已存在对象一模一样</strong></p>
<p>&emsp;<strong>拷贝构造函数不显式定义时由编译器自动生成，当显式定义拷贝构造函数时，编译器不会自动生成。 拷贝构造函数是构造函数的重载，它与构造函数外表唯一区别是拷贝构造函数只有一个形参，形参必须为引用，并推荐用const修饰</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用拷贝构造函数，推荐写法</span></span><br><span class="line">	Person p3 = p1; <span class="comment">// 调用拷贝构造函数，不推荐写法</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">3.</span><span class="built_in">Print</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-拷贝构造函数特性"><a href="#3-1-拷贝构造函数特性" class="headerlink" title="3.1 拷贝构造函数特性"></a>3.1 拷贝构造函数特性</h2><h3 id="3-1-1-显式定义拷贝构造函数时必须显式定义默认构造函数"><a href="#3-1-1-显式定义拷贝构造函数时必须显式定义默认构造函数" class="headerlink" title="3.1.1 显式定义拷贝构造函数时必须显式定义默认构造函数"></a>3.1.1 显式定义拷贝构造函数时必须显式定义默认构造函数</h3><p>&emsp;<strong>拷贝构造函数是构造函数的重载，当显式定义拷贝构造函数时，编译器不会生成默认构造函数，此时需要显式定义默认构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1; <span class="comment">// 错误，没有默认构造函数可以调用</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-2-拷贝构造函数形参必须为引用原因"><a href="#3-1-2-拷贝构造函数形参必须为引用原因" class="headerlink" title="3.1.2 拷贝构造函数形参必须为引用原因"></a>3.1.2 拷贝构造函数形参必须为引用原因</h2><p><strong>下面这段代码拷贝构造函数的形参不是引用，会出现死循环递归调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span>  Person obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">		_age = obj._age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，变成死循环</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f6544bdd817c85f8cae9be41dad0afa.png#pic_center" alt="在这里插入图片描述"><br><strong>还有一种不推荐的写法，因为引用的本质是指针，所以拷贝构造函数形参可以是指针类型，只是这种写法可读性、清晰性不高，并且调用时需要传对象地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person* obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, obj-&gt;_name);</span><br><span class="line">		_age = obj-&gt;_age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(&amp;p1)</span></span>; <span class="comment">// 使用指针方法调用拷贝构造函数</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-编译器生成的拷贝构造函数的功能"><a href="#3-2-编译器生成的拷贝构造函数的功能" class="headerlink" title="3.2 编译器生成的拷贝构造函数的功能"></a>3.2 编译器生成的拷贝构造函数的功能</h2><p><strong>&emsp;在类中不显式定义拷贝构造函数，编译器自动生成拷贝构造函数。这个拷贝构造函数对于对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的拷贝构造函数</strong></p>
<p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是类A的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是类A的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line">	A ob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">	p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">这是类A的构造函数</span><br><span class="line">这是类A的拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure>
<h1 id="四、运算符重载"><a href="#四、运算符重载" class="headerlink" title="四、运算符重载"></a>四、运算符重载</h1><p>&emsp;C++为了增强代码的可读性引入了运算符重载概念，<strong>运算符重载是一个特殊的函数</strong>。通过关键字<code>operator</code>加上运算符来表示函数名，函数的返回值类型及参数列表与普通函数类似。<strong>重载的运算符并不会改变它们做为内置运算符的使用方法。</strong></p>
<p>● 不能重载C++语言不支持的运算符，比如 @<br>● 不要试图改变重载运算符的语义，要与内置语义保存一致。例如将++运算符重载后执行递减操作，损害代码的可读性、正确性</p>
<h2 id="4-1-运算符重载的两种形式"><a href="#4-1-运算符重载的两种形式" class="headerlink" title="4.1 运算符重载的两种形式"></a>4.1 运算符重载的两种形式</h2><p>&emsp;<strong>运算符重载有两种形式，一种运算符被重载为类的成员函数，另一种重载为全局函数。推荐被重载为类的成员函数。运算符重载为成员函数比重载为全局函数而言函数的形参看起来少一个参数，对于成员函数编译器会将左操作数的地址隐式传给形参this指针</strong></p>
<h3 id="4-1-1-重载为类的成员函数"><a href="#4-1-1-重载为类的成员函数" class="headerlink" title="4.1.1 重载为类的成员函数"></a>4.1.1 重载为类的成员函数</h3><p>&emsp;<strong>运算符的左操作数为类的对象时，建议运算符重载为类的成员函数，因为C++编译器给每个“非静态的成员函数“增加了一个隐藏的this指针形参，并会将左操作数（即类对象）的地址做为实参传给形参this指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">bool</span> Date::<span class="keyword">operator</span>&lt;(Date&amp; obj) <span class="comment">// 重载&lt; 运算符，用来比较两个日期类型对象的大小</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_year &lt; obj._year)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(_year == obj._year &amp;&amp; _month &lt; obj._month)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (_year == obj._year &amp;&amp; _month == obj._month &amp;&amp; _day &lt; obj._day)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-重载为全局函数"><a href="#4-1-2-重载为全局函数" class="headerlink" title="4.1.2 重载为全局函数"></a>4.1.2 重载为全局函数</h3><p>&emsp;<strong>运算符的左操作数不是类的对象时，运算符重载为全局函数。假设重载为成员函数，编译器会将左操作数地址传给隐藏的形参this指针，this指针类型为 <code>类名* </code> ,与<code>&amp;左操作数</code>类型不匹配</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; obj._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-运算符重载调用"><a href="#4-2-运算符重载调用" class="headerlink" title="4.2 运算符重载调用"></a>4.2 运算符重载调用</h2><p>&emsp;<strong>运算符重载是一种特殊的函数，在与普通函数相比，函数调用有些不同。不仅支持正常的函数名+()方式调用，又支持通过运算符方式调用。推荐使用运算符方式调用，提高代码可读性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; obj._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Date d1;</span><br><span class="line">	cout &lt;&lt; d1; <span class="comment">// 运算符方式调用， &lt;&lt; 为运算符  cout为左操作数  d1为右操作数</span></span><br><span class="line">	<span class="keyword">operator</span>&lt;&lt;(cout,d1); <span class="comment">// 通过函数名方式调用，operator&lt;&lt; 为函数名， cout、d1为形参</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-不能重载的运算符"><a href="#4-3-不能重载的运算符" class="headerlink" title="4.3 不能重载的运算符"></a>4.3 不能重载的运算符</h2><p>&emsp;C++运算符集合中，5种运算符不运行重载，为：<code>.* 、:: 、?: 、sizeof 、.</code></p>
<h2 id="4-4-重载-和"><a href="#4-4-重载-和" class="headerlink" title="4.4 重载++和- -"></a>4.4 重载++和- -</h2><p>&emsp;两个运算符分为前置版本与后置版本，运算符重载是一种特殊的函数，函数名由关键字<code>operator</code>+运算符组成，那问题来了，<code>operator++</code>是重载的前置++还是后置++，<code>operator--</code>是重载的前置- -还是后置- -。<strong>为了解决这个问题，C++标准规定：当重载前置版本的++或- -时，函数形参为空，当重载后置版本的++或- -时，函数需要定义一个int类型的形参作为标志进行区分</strong></p>
<p><font color=#0000FF >说明：对于自定义类型，尤其是对象所占内存空间比较大时，前置版本比后置版本效率高很多</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	Date&amp; <span class="keyword">operator</span>+=(<span class="type">int</span> day); <span class="comment">// 日期+=天数</span></span><br><span class="line">	</span><br><span class="line">	Date&amp; <span class="keyword">operator</span>++(); <span class="comment">// ++日期</span></span><br><span class="line"></span><br><span class="line">	Date <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// 日期++ ,后置++为了跟前置++区分，增加一下int类型参数占位，构成函数重载</span></span><br><span class="line"></span><br><span class="line">	Date&amp; <span class="keyword">operator</span>-=(<span class="type">int</span> day); <span class="comment">// 日期-=天数</span></span><br><span class="line"></span><br><span class="line">	Date&amp; <span class="keyword">operator</span>--(); <span class="comment">// --日期</span></span><br><span class="line"></span><br><span class="line">	Date <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">// 日期-- ,后置--为了跟前置--区分，增加一下int类型参数占位，构成函数重载</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> -= -day;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_day += day;</span><br><span class="line">	<span class="keyword">while</span> (_day &gt; <span class="built_in">GetMonthDay</span>(_year, _month)) <span class="comment">// 当day大于该月天数时</span></span><br><span class="line">	&#123;</span><br><span class="line">		_day -= <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">		_month++;</span><br><span class="line">		<span class="keyword">if</span> (_month == <span class="number">13</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_year++;</span><br><span class="line">			_month = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>-=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> += -day;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_day -= day;</span><br><span class="line">	<span class="keyword">while</span> (_day &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_month--;</span><br><span class="line">		<span class="keyword">if</span> (_month == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_year--;</span><br><span class="line">			_month = <span class="number">12</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		_day += <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Date d1;</span><br><span class="line">	++d1; <span class="comment">// 前置++</span></span><br><span class="line">	d1++; <span class="comment">// 后置++</span></span><br><span class="line">	d<span class="number">1.</span><span class="keyword">operator</span>++(); <span class="comment">// 通过函数名方式调用，没有传入实参，调用前置++</span></span><br><span class="line">	d<span class="number">1.</span><span class="keyword">operator</span>++(<span class="number">1</span>); <span class="comment">// 通过函数名方式调用，传入int类型实参，调用后置++</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-赋值运算符重载"><a href="#4-5-赋值运算符重载" class="headerlink" title="4.5 赋值运算符重载"></a>4.5 赋值运算符重载</h2><p>&emsp;<strong>对已存在的类对象进行赋值拷贝时，会调用赋值运算符重载。赋值运算符重载不显式定义时由编译器自动生成，当显式定义赋值运算符重载，编译器不生成。</strong></p>
<p><strong>注意：赋值运算符只能重载为类的成员函数，而不能将其重载为类的非成员函数。因为当重载为类的非成员函数时并不属于该类，编译器一看，类内并没有一个以本类或本类的引用为参数的赋值运算符重载函数，所以会自动提供一个。为了避免这样的二义性，C++强制规定，赋值运算符重载函数只能定义为类的成员函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Date <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; obj);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	_year = obj._year;</span><br><span class="line">	_month = obj._month;</span><br><span class="line">	_day = obj._day;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Date d1;</span><br><span class="line">	Date d2;</span><br><span class="line">	d2 = d1; <span class="comment">// d2对象已经存在，调用赋值运算符重载将d1的值拷贝给d2</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-1-编译器生成的赋值运算符重载功能"><a href="#4-5-1-编译器生成的赋值运算符重载功能" class="headerlink" title="4.5.1 编译器生成的赋值运算符重载功能"></a>4.5.1 编译器生成的赋值运算符重载功能</h3><p><strong>&emsp;在类中不显式定义赋值运算符重载，编译器自动生成赋值运算符重载。编译器生成的赋值运算符重载对于对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的赋值运算符重载</strong></p>
<p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B <span class="keyword">operator</span>=(B&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = obj._x;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;类B的赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _y;</span><br><span class="line">	B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> y = <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	A b;</span><br><span class="line">	b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类B的赋值运算符重载</span><br></pre></td></tr></table></figure>
<h2 id="4-6-取地址运算符重载与const-取地址运算符重载"><a href="#4-6-取地址运算符重载与const-取地址运算符重载" class="headerlink" title="4.6 取地址运算符重载与const 取地址运算符重载"></a>4.6 取地址运算符重载与const 取地址运算符重载</h2><p>&emsp;<strong>取地址运算符重载与const 取地址运算符重载不显式定义时由编译器自动生成，当显式定义时，编译器不会自动生成。只有需要对取地址做特殊处理时才显式定义，一般用编译器自动生成的即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _year;</span><br><span class="line">	<span class="type">int</span> _month;</span><br><span class="line">	<span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Date* <span class="keyword">operator</span>&amp;();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Date* <span class="keyword">operator</span>&amp;()<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> Date* Date::<span class="keyword">operator</span>&amp;()</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">const</span> Date* Date::<span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 结构化绑定</title>
    <url>/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A.html</url>
    <content><![CDATA[<h1 id="一、结构化绑定"><a href="#一、结构化绑定" class="headerlink" title="一、结构化绑定"></a>一、结构化绑定</h1><h2 id="1-1-引子"><a href="#1-1-引子" class="headerlink" title="1.1 引子"></a>1.1 引子</h2><p>在 C++中，如果一个函数需要返回<strong>两个值</strong>，我们可以使用<code>std::pair</code> 。例如：有个函数查找并返回一个整数数组的最小值和最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">findMinMax</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max = numbers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num: numbers)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (num &lt; min) min = num;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; max) max = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;min, max&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有多种方法可以获取<code>std::pair</code>中的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">42</span>, <span class="number">17</span>, <span class="number">89</span>, <span class="number">3</span>, <span class="number">56</span>, <span class="number">21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一 </span></span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">findMinMax</span>(data);</span><br><span class="line"><span class="type">int</span> min = r.first;</span><br><span class="line"><span class="type">int</span> max = r.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">findMinMax</span>(data);</span><br><span class="line"><span class="type">int</span> min = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(r);</span><br><span class="line"><span class="type">int</span> max = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="type">int</span> min, max;</span><br><span class="line">std::<span class="built_in">tie</span>(min, max) = <span class="built_in">findMinMax</span>(data);</span><br></pre></td></tr></table></figure>

<p>我们发现虽然有多种方法可以获取<code>std::pair</code>中的参数，但是都有如下问题：1. 代码不够简洁  2. 可读性较差。在<code>C++ 17</code>中可以通过结构化绑定一行代码搞定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [min, max] = <span class="built_in">findMinMax</span>(data);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="1-2-结构化绑定是什么"><a href="#1-2-结构化绑定是什么" class="headerlink" title="1.2 结构化绑定是什么"></a>1.2 结构化绑定是什么</h2><p><code>C++17</code>标准中引入了结构化绑定，即将指定的标识符绑定到初始化的子对象或元素上，相当于给初始化的子对象（或者元素）起了别名。注意别名不同于引用，后文会详细讲解它们区别。结构化绑定为我们提供了一种更简单、更直观的方式来操作复合数据类型。</p>
<p><strong>语法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">decl-specifier ref-<span class="built_in">qualifier</span>(optional) [ identifier-list ] = expression;</span><br><span class="line">decl-specifier ref-<span class="built_in">qualifier</span>(optional) [ identifier-list ] &#123; expression &#125;;</span><br><span class="line">decl-specifier ref-<span class="built_in">qualifier</span>(optional) [ identifier-list ] ( expression );</span><br></pre></td></tr></table></figure>

<p>各部分说明：</p>
<p>decl-specifier :  修饰符，可选的有<code>const</code>、<code>volatile</code>、<code>static</code>、<code>thread_local</code>，必选的为<code>auto</code></p>
<p>ref-qualifier：<code>&amp;</code>或<code>&amp;&amp;</code>，可选，表示左值引用或万能引用</p>
<p>identifier-list：用逗号分隔的标识符列表，标识符在绑定语句所在的作用域内可见</p>
<p>expression：表达式</p>
<p>下面有一个嵌套<code>std::map</code>，外层表示学校与班级，内层表示班级与学生人数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 嵌套 map：学校 -&gt; 班级 -&gt; 学生人数</span></span><br><span class="line">std::map&lt;std::string, std::map&lt;std::string, <span class="type">int</span>&gt;&gt; schools&#123;</span><br><span class="line">    &#123;<span class="string">&quot;HighSchoolA&quot;</span>, &#123;&#123;<span class="string">&quot;Class1&quot;</span>, <span class="number">35</span>&#125;, &#123;<span class="string">&quot;Class2&quot;</span>, <span class="number">30</span>&#125;&#125;&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;HighSchoolB&quot;</span>, &#123;&#123;<span class="string">&quot;Class1&quot;</span>, <span class="number">28</span>&#125;, &#123;<span class="string">&quot;Class2&quot;</span>, <span class="number">32</span>&#125;, &#123;<span class="string">&quot;Class3&quot;</span>, <span class="number">26</span>&#125;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外层遍历学校</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[school, classes]: schools) <span class="comment">// 将key绑定给标识符school, 将val绑定给标识符classes。由于不希望拷贝和修改，使用 const &amp; 修饰</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;School: &quot;</span> &lt;&lt; school &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层遍历班级</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[className, studentCount]: classes) <span class="comment">// 将key绑定给标识符className, 将val绑定给标识符studentCount。由于不希望拷贝和修改，使用 const &amp; 修饰</span></span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; className &lt;&lt; <span class="string">&quot; has &quot;</span> &lt;&lt; studentCount &lt;&lt; <span class="string">&quot; students.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-深入理解结构化绑定"><a href="#1-3-深入理解结构化绑定" class="headerlink" title="1.3 深入理解结构化绑定"></a>1.3 深入理解结构化绑定</h2><h3 id="1-3-1-绑定是什么"><a href="#1-3-1-绑定是什么" class="headerlink" title="1.3.1 绑定是什么"></a>1.3.1 绑定是什么</h3><p>在<em>1.2</em>节中我们提到结构化绑定就是将指定的标识符绑定到初始化的子对象上，等同于子对象的别名。下面通过两个示例来理解这句话。</p>
<p>示例一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; person = std::<span class="built_in">make_pair</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [name, age] = person;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;person.age&quot;</span> &lt;&lt; person.second &lt;&lt; <span class="string">&quot; &amp;person.age=&quot;</span> &lt;&lt; &amp;person.second &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; &amp;age=&quot;</span> &lt;&lt; &amp;age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;修改后&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;person.age&quot;</span> &lt;&lt; person.second &lt;&lt; <span class="string">&quot; &amp;person.age=&quot;</span> &lt;&lt; &amp;person.second &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; &amp;age=&quot;</span> &lt;&lt; &amp;age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">person.age18 &amp;person.age=<span class="number">0x16d8bf048</span></span><br><span class="line">age18 &amp;age=<span class="number">0x16d8bf010</span></span><br><span class="line">修改后</span><br><span class="line">person.age18 &amp;person.age=<span class="number">0x16d8bf048</span></span><br><span class="line">age20 &amp;age=<span class="number">0x16d8bf010</span></span><br></pre></td></tr></table></figure>

<p>可以看到修改<em>age</em>并不会影响<em>person.age</em>，而且它们内存地址是不一样。<strong>即编译器发现<code>auto</code>后面没有<code>&amp;</code>或<code>&amp;&amp;</code>时，会创建一个person对象的副本（匿名对象），然后将name与age绑定到这个匿名对象上</strong>。伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; person = std::<span class="built_in">make_pair</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> anonymous = person; <span class="comment">// 参考person创建的匿名对象</span></span><br><span class="line">aliasname name = anonymous.name; <span class="comment">// aliasname这里表示别名，而不是引用</span></span><br><span class="line">aliasname age = anonymous.age;</span><br></pre></td></tr></table></figure>



<p>示例二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; person = std::<span class="built_in">make_pair</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;[name, age] = person;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;person.age&quot;</span> &lt;&lt; person.second &lt;&lt; <span class="string">&quot; &amp;person.age=&quot;</span> &lt;&lt; &amp;person.second &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; &amp;age=&quot;</span> &lt;&lt; &amp;age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;修改后&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;person.age&quot;</span> &lt;&lt; person.second &lt;&lt; <span class="string">&quot; &amp;person.age=&quot;</span> &lt;&lt; &amp;person.second &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; &amp;age=&quot;</span> &lt;&lt; &amp;age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">person.age18 &amp;person.age=<span class="number">0x16b8c3048</span></span><br><span class="line">age18 &amp;age=<span class="number">0x16b8c3048</span></span><br><span class="line">修改后</span><br><span class="line">person.age20 &amp;person.age=<span class="number">0x16b8c3048</span></span><br><span class="line">age20 &amp;age=<span class="number">0x16b8c3048</span></span><br></pre></td></tr></table></figure>

<p>可以看到修改<em>age</em>会影响<em>person.age</em>且它们内存地址一样。<strong>即编译器发现<code>auto</code>后面有<code>&amp;</code>或<code>&amp;&amp;</code>时，不会创建匿名对象而是直接将name与age绑定到person对象上</strong>。伪代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; person = std::<span class="built_in">make_pair</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">aliasname name = person.name;  <span class="comment">// aliasname这里表示别名，而不是引用</span></span><br><span class="line">aliasname age = person.age;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-子对象别名是什么"><a href="#1-3-2-子对象别名是什么" class="headerlink" title="1.3.2 子对象别名是什么"></a>1.3.2 子对象别名是什么</h3><p>对于标识符等同于子对象别名又该如何理解呢？可以看下面代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; person = std::<span class="built_in">make_pair</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">auto</span> &amp;[name, age] = person;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&amp;person.name=&quot;</span> &lt;&lt; &amp;person.first &lt;&lt; <span class="string">&quot; &amp;person.age&quot;</span> &lt;&lt; &amp;person.second &lt;&lt; <span class="string">&quot; &amp;name=&quot;</span> </span><br><span class="line">  &lt;&lt; &amp;name &lt;&lt; <span class="string">&quot; &amp;age=&quot;</span> &lt;&lt; &amp;age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;std::string, decltype(person.name)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;std::string, <span class="keyword">decltype</span>(person.first)&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;int, decltype(person.age)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(person.second)&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;std::string, decltype(name)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;std::string, <span class="keyword">decltype</span>(name)&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;int, decltype(age)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(age)&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;std::string&amp;, decltype(name)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;std::string &amp;, <span class="keyword">decltype</span>(name)&gt; &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;std::is_same_v&lt;int&amp;, decltype(age)=&quot;</span></span><br><span class="line">  &lt;&lt; std::is_same_v&lt;<span class="type">int</span> &amp;, <span class="keyword">decltype</span>(age)&gt; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;person.name=<span class="number">0x16b977030</span> &amp;person.age0x16b977048 &amp;name=<span class="number">0x16b977030</span> &amp;age=<span class="number">0x16b977048</span></span><br><span class="line">std::is_same_v&lt;std::string, <span class="keyword">decltype</span>(person.name)=<span class="number">1</span></span><br><span class="line">std::is_same_v&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(person.age)=<span class="number">1</span></span><br><span class="line">std::is_same_v&lt;std::string, <span class="keyword">decltype</span>(name)=<span class="number">1</span></span><br><span class="line">std::is_same_v&lt;<span class="type">int</span>, <span class="keyword">decltype</span>(age)=<span class="number">1</span></span><br><span class="line">std::is_same_v&lt;std::string&amp;, <span class="keyword">decltype</span>(name)=<span class="number">0</span></span><br><span class="line">std::is_same_v&lt;<span class="type">int</span>&amp;, <span class="keyword">decltype</span>(age)=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到这里的别名就是单纯别名，别名的类型和绑定目标对象的子对象类型相同，而不是子对象的引用类型。</strong></p>
<h3 id="1-3-3-绑定不能忽略部分子对象"><a href="#1-3-3-绑定不能忽略部分子对象" class="headerlink" title="1.3.3 绑定不能忽略部分子对象"></a>1.3.3 绑定不能忽略部分子对象</h3><p>学生信息由学号、姓名、性别、年龄、班级五部分组成，并通过<code>std::tuple</code>存储，现需要打印学号和姓名，可以使用<code>std::tie</code>配合<code>std::ignore</code>轻松完成，如果使用结构化绑定，则不支持忽略部分子对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">char</span>, <span class="type">int</span>, std::string&gt; student = &#123;<span class="number">202501</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">18</span>, <span class="string">&quot;class A&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">std::string name;</span><br><span class="line">std::<span class="built_in">tie</span>(id, name, std::ignore, std::ignore, std::ignore) = student;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; name=&quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [id, name, std::ignore, std::ignore, std::ignore] = student; <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>

<p><strong>我们可以通过给不需要的子对象用”占位标识符“来模拟忽略效果，但需确保这个“占位标识符”在当前作用域不会再被使用到</strong>。注意：这种方式也是将子对象绑定到标识符上，只是后面不使用这个标识符，并且在当前作用域中“占位标识符”不能相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; [id, name, _p1, _p2, _p3] = student;</span><br></pre></td></tr></table></figure>

<h1 id="二、可绑定的类型"><a href="#二、可绑定的类型" class="headerlink" title="二、可绑定的类型"></a>二、可绑定的类型</h1><p>结构化绑定可以作用于3种类型，包括原生数组、结构体和类对象、元组和类元组的对象。</p>
<h2 id="2-1-绑定到原生数组"><a href="#2-1-绑定到原生数组" class="headerlink" title="2.1 绑定到原生数组"></a>2.1 绑定到原生数组</h2><p>绑定到原生数组所需条件最简单，标识符的数量等于数组的元素个数。需要注意的是，编译器必须知道原生数组的元素个数，如果数组名退化为指针，则会绑定失败。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = arr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = p; <span class="comment">// 编译错误，编译器无法获取到p指向的数组元素个数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-绑定到结构体和类对象"><a href="#2-2-绑定到结构体和类对象" class="headerlink" title="2.2 绑定到结构体和类对象"></a>2.2 绑定到结构体和类对象</h2><p>绑定到结构体和类对象有如下限制条件：</p>
<ol>
<li><p>结构体(或类)中的非静态成员变量个数必须和标识符列表中标识符的个数相同</p>
</li>
<li><p>非静态成员变量访问权限必须为<code>public</code> (C++20 放宽了该限制规则)</p>
</li>
<li><p>非静态成员变量必须在当前类或基类中</p>
</li>
<li><p>结构体(或类)中不能有匿名联合体</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x, y] = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会编译失败，因为<em>类A</em>的非静态成员变量为<code>private</code>，违反限制条件2。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> _num = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x] = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会编译失败，因为<em>类A</em>的非静态成员变量有2个，而标识符只有1个，违反限制条件1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">double</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">double</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="type">double</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived1 d1;</span><br><span class="line">    Derived2 d2;</span><br><span class="line">    Derived3 d3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>[x1, y1] = d1; </span><br><span class="line">    <span class="keyword">auto</span>[x2, y2] = d2; </span><br><span class="line">    <span class="keyword">auto</span>[x3, y3] = d3; <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<em>d1</em>与<em>d2</em>结构化绑定成功，因为非静态成员变量都在当前类或基类中。<em>d3</em>结构化绑定失败是因为非静态成员变量在当前类与基类中都有定义，违反限制条件3。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> common_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名联合体</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> int_value;</span><br><span class="line">      <span class="type">double</span> double_value;</span><br><span class="line">      <span class="type">char</span> char_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A obj;</span><br><span class="line">    obj.common_data = <span class="number">2025</span>;</span><br><span class="line">    obj.int_value = <span class="number">100</span>;</span><br><span class="line">    obj.name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [common, value, name] = obj;  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会编译失败，因为<em>类A</em>中有匿名联合体，违反限制条件4。</p>
<h2 id="2-3-绑定到元组和类元组"><a href="#2-3-绑定到元组和类元组" class="headerlink" title="2.3 绑定到元组和类元组"></a>2.3 绑定到元组和类元组</h2><p>在上文的示例中已经演示过结构化绑定到<code>std::tuple</code>中 ，即将标识符列表中的标识符分别绑定到元组对象的各个子元素中。那么绑定到类元祖是什么意思呢？有些细心读者注意到上文中已使用结构化绑定到<code>std::pair</code>，但<code>std::pair</code>并不是元祖类型。接下来让迷雾揭晓。</p>
<p><strong>类元祖是指那些不是元组类型，但实现了像<code>std::tuple</code>中为支持结构化绑定一系列限制条件的类型</strong>。例如<code>std::pair</code>就是一个类元祖。</p>
<p>限制条件：对于元祖或类元祖类型T，需要满足以下条件</p>
<ol>
<li><p><code>std::tuple_size&lt;T&gt;::value</code>是一个符合语法的表达式，并且该表达式获得的整数值与标识符列表中的标识符个数相同</p>
</li>
<li><p><code>std::tuple_element&lt;i, T&gt;::type</code>是一个符合语法的表达式，其中<em>i</em>是小于<code>std::tuple_size&lt;T&gt;::value</code>的整数，表示类型T中第i个元素的类型</p>
</li>
<li><p>类型T必须存在合法的成员函数模板<code>get&lt;i&gt;()</code>或者函数模板<code>get&lt;i&gt;(t)</code>，其中i是小于<code>std::tuple_size&lt;T&gt;::value</code>的整数，t是类型T的实例化对象，返回的是实例t中第i个元素的值。</p>
</li>
</ol>
<p>在<em>2.2</em>节中对于<em>Derived3</em>，由于它的非静态成员变量分散在基类与派生类之间，所以不支持结构化绑定，下面将通过让其满足类元组的条件，从而达到支持结构化绑定的目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过模版特化告诉编译器将要绑定的子对象个数，满足条件1</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过模版特化告诉编译器每个子对象类型，满足条件2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">using</span> type = <span class="type">double</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个元素的值。满足条件3</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> Idx&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> &amp;<span class="title">get</span><span class="params">(Derived3 &amp;obj)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">auto</span> &amp;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(Derived3 &amp;obj) &#123; <span class="keyword">return</span> obj._a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">auto</span> &amp;<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(Derived3 &amp;obj) &#123; <span class="keyword">return</span> obj._b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived3 d3;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x3, y3] = d3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>get</em>函数实现有两种，一种是作为类的成员函数，一种是函数摸板。上文中是通过函数摸板方式，并且返回的是子对象的引用，所以需要使用<code>auto &amp;[x3, y3] = d3;</code>，如果使用<code>auto [x3, y3] = d3;</code>则会编译错误。并通过<code>=delete</code>明确告诉编译器不要生成除了特化版本以外的函数，防止<em>get</em>函数模板被滥用。下文展示将<em>get</em>作为类的成员函数的方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _b;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 获取第i个元素的值。满足条件3</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;std::<span class="type">size_t</span> Idx&gt; <span class="keyword">auto</span>&amp; <span class="title">get</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span>&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;() &#123; <span class="keyword">return</span> _a; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span>&amp; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;() &#123; <span class="keyword">return</span> _b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过模版特化告诉编译器将要绑定的子对象个数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过模版特化告诉编译器每个子对象类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Derived3&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">using</span> type = <span class="type">double</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、C-20"><a href="#三、C-20" class="headerlink" title="三、C++ 20"></a>三、C++ 20</h1><p>在<em>2.2</em>节中提到，非静态成员变量访问权限必须为<code>public</code> 。这个限制乍看是合理的，但是在某些场景下是不合理的。例如下面代码中，<em>test</em>函数是类A的友元函数，可以访问类A私有成员变量_a，但是不能结构化绑定，这个就不合理了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">auto</span> x = a._a;</span><br><span class="line">    <span class="keyword">auto</span> [y] = a; <span class="comment">// 违反限制条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，同样问题还出现在类的成员函数想结构化绑定自身的时候：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> [x] = *<span class="keyword">this</span>; <span class="comment">// 违反限制条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了解决这类问题，<strong><code>C++20</code>标准规定结构化绑定的限制不再强调类的非静态成员变量必须为<code>public</code>访问权限，而是由编译器根据当前上下文判断是否允许绑定</strong>。</p>
<p>说明： 在<code>clang</code> 编译器中测试不管是使用<code>C++ 17</code>还是<code>C++ 20</code>标准，上述代码都能编译运行成功。</p>
<p>总结：结构化绑定在许多情况下为我们编写代码提供了极大的便利，通过结构化绑定可以使代码更简洁、可读性更高，很方便从复杂类型中提取子对象并赋予有意义标识符名称。但是它也有一些缺点，例如无法应用于动态数据结构，如<code>std::vector</code>。并且可能带来命名空间污染，不支持忽略部分子对象等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>谢丙堃 &lt;&lt;现代C++语言核心特性解析&gt;&gt;</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
        <tag>C++ 20</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 继承</title>
    <url>/C-%E7%BB%A7%E6%89%BF.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、继承概念与语法"><a href="#一、继承概念与语法" class="headerlink" title="一、继承概念与语法"></a>一、继承概念与语法</h1><h2 id="1-1-继承是什么"><a href="#1-1-继承是什么" class="headerlink" title="1.1 继承是什么"></a>1.1 继承是什么</h2><p>&emsp;继承（Inheritance）是面向对象编程程序设计（OOP）的一个重要特征。<strong>它允许一个类（派生类）继承另一个类（基类）的属性和方法</strong>，并可以在此基础上修改已有的功能或增加新的功能。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程，继承是类设计层次的代码复用。</p>
<span id="more"></span>

<h2 id="1-2-继承语法"><a href="#1-2-继承语法" class="headerlink" title="1.2 继承语法"></a>1.2 继承语法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;: [继承方式] &lt;基类名&gt;    <span class="comment">// 单继承</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// member list</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;: [继承方式] &lt;基类名<span class="number">1</span>&gt;, [继承方式] &lt;基类名<span class="number">2</span>&gt;,...   <span class="comment">// 多继承</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// member list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>单继承：只有一个基类<br>多继承：有两个或两个以上基类</p>
<p>继承方式：<code>public</code>、<code>protected</code>、<code>private</code>三种，不指定时使用默认继承方式（不推荐）。<br>a. 对于class，默认继承方式是<code>private</code><br>b. 对于struct，默认继承方式是<code>public</code></p>
<h2 id="1-3-访问控制"><a href="#1-3-访问控制" class="headerlink" title="1.3 访问控制"></a>1.3 访问控制</h2><p><strong>继承方式与访问限定符共同决定了基类成员在派生类中的可见性</strong>。</p>
<table>
<thead>
<tr>
<th align="left">类成员\继承方式</th>
<th align="left">public继承</th>
<th align="left">protected继承</th>
<th align="left">private继承</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基类的public成员</td>
<td align="left">派生类的public成员</td>
<td align="left">派生类的protected成员</td>
<td align="left">派生类的private成员</td>
</tr>
<tr>
<td align="left">基类的protected成员</td>
<td align="left">派生类的protected成员</td>
<td align="left">派生类的protected成员</td>
<td align="left">派生类的private成员</td>
</tr>
<tr>
<td align="left">基类的private成员</td>
<td align="left">在派生类中不可见</td>
<td align="left">在派生类中不可见</td>
<td align="left">在派生类中不可见</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;eating&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">students_eat</span><span class="params">()</span> </span>&#123; <span class="built_in">eat</span>(); &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s._name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 错误，public继承，但_name在基类为private成员，所以在派生类不可见</span></span><br><span class="line">    s._age = <span class="number">10</span>; <span class="comment">// 错误，同上</span></span><br><span class="line">    s.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 正确，public继承，set_name在基类为public成员，所以在派生类为public</span></span><br><span class="line">    s.<span class="built_in">set_age</span>(<span class="number">18</span>); <span class="comment">// 正确，同上</span></span><br><span class="line">    s.<span class="built_in">print</span>(); <span class="comment">// 正确，同上</span></span><br><span class="line">    s.<span class="built_in">eat</span>(); <span class="comment">// 错误，public继承，但eat在基类为protected成员，所以在派生类为protected,只能在类里面调用该函数</span></span><br><span class="line">    s.<span class="built_in">students_eat</span>(); <span class="comment">// 正确</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/5159b20c1b60490ab1066993967e8013.png" alt="在这里插入图片描述"></p>
<p>问题：不管使用什么继承方式，基类中private的成员在派生类中是不可见的，为什么派生类还要含有这些不可见的成员？</p>
<ol>
<li>虽然派生类不能直接访问基类的private成员，但基类可以提供public或protected的方法（方法里面访问private成员）。当派生类调用基类的这些方法时，它会间接访问或修改基类的private成员，所以派生类要含有这些不可见成员。</li>
<li>为保证对象模型的一致性。如果派生类不包含基类的private成员，那么派生类的对象在内存布局上就会与基类的对象不同，这会导致继承体系中的类型兼容性问题。在派生类中保留基类的私有成员，可以确保派生类对象在内存中包含基类对象的所有部分，这使得基类指针或引用可以安全地指向派生类对象，以及通过派生类对象构造出基类对象。</li>
</ol>
<h2 id="1-4-继承中的作用域"><a href="#1-4-继承中的作用域" class="headerlink" title="1.4 继承中的作用域"></a>1.4 继承中的作用域</h2><p>&emsp;在继承体系中,基类和派生类都有<strong>独立的作用域</strong>，如果派生类定义了与基类同名的成员（变量和函数），则基类的同名成员会被隐藏（shadowed），派生类默认访问的是自身的成员，如要访问基类的成员,需要显式指定基类作用域。</p>
<p>语法: <code>基类名::成员名</code></p>
<p><strong>注意：</strong></p>
<ul>
<li>对于变量来说，同名即构成隐藏。</li>
<li>对于函数来说，如果基类函数不是虚函数，派生类只要函数同名即构成隐藏。如果基类为虚函数，派生类同名函数的参数列表不相同构成隐藏，而不是重写。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f4()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f5(int i)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f5()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::f2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f4()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">f1</span>(); <span class="comment">// 隐藏</span></span><br><span class="line">    b.<span class="built_in">f2</span>(); <span class="comment">// 隐藏</span></span><br><span class="line">    b.<span class="built_in">f3</span>(); <span class="comment">// 隐藏 </span></span><br><span class="line">    b.<span class="built_in">f4</span>(); <span class="comment">// 隐藏，虽然基类f4为虚函数，但派生类f4与基类f4参数列表不相同，所以不构成覆盖(override)</span></span><br><span class="line">    b.<span class="built_in">f5</span>(); <span class="comment">// 基类有2个f5函数，处于同一作用域，构成函数重载</span></span><br><span class="line">    b.<span class="built_in">f5</span>(<span class="number">1</span>); <span class="comment">// 基类有2个f5函数，处于同一作用域，构成函数重载</span></span><br><span class="line">	</span><br><span class="line">	b.A::<span class="built_in">f1</span>(); <span class="comment">// 使用作用域解析运算符访问基类f1函数</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码运行后输出内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">B::f1()</span><br><span class="line">B::f2()</span><br><span class="line">B::f3()</span><br><span class="line">B::f4()</span><br><span class="line">A::f5(int i)</span><br><span class="line">A::f5()</span><br><span class="line">A::f1()</span><br></pre></td></tr></table></figure>
<h2 id="1-5-继承下的类型转换"><a href="#1-5-继承下的类型转换" class="headerlink" title="1.5 继承下的类型转换"></a>1.5 继承下的类型转换</h2><h3 id="1-5-1-向下类型转换"><a href="#1-5-1-向下类型转换" class="headerlink" title="1.5.1 向下类型转换"></a>1.5.1 向下类型转换</h3><p>将基类的指针、引用、对象转换为派生类指针、引用、对象称为向下类型转换。<br>说明：</p>
<ol>
<li>将基类对象转换为派生类对象时，实际上参照基类对象创建了一个新的派生类对象，所以派生类要提供一个<code>Derived(const Base&amp;)</code>拷贝构造函数。</li>
<li>将基类指针、引用转换为派生类指针、引用时没有创建新的对象，编译器只是对这个起始内存空间从按基类类型解释变为按派生类类型解释，所以有内存越界风险。</li>
<li>对于使用<code>protected/private</code>继承方式，向下类型转换没有什么实际意义，因为基类很多成员对派生类是不可见的。</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/ec6275a13d6643e9a7bddfb311941549.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Person &amp;obj) &#123;&#125; <span class="comment">// 对象的向下类型转换必须提供该拷贝构造函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; _id = id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(p)</span></span>; <span class="comment">// 调用Student(const Person &amp;obj)拷贝构造函数</span></span><br><span class="line">    Student *point = (Student *) &amp;p; <span class="comment">// 将p对象的内存空间按Student类型解释</span></span><br><span class="line">    Student &amp;ref = (Student &amp;) p; <span class="comment">// 将p对象的内存空间按Student类型解释</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非法访问内存，point指向的区域实际是Person类型，现在将它按Student类型解释，调用set_id函数会修改p对象后面的内存区域</span></span><br><span class="line">	point-&gt;<span class="built_in">set_id</span>(<span class="number">10</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-向上类型转换"><a href="#1-5-2-向上类型转换" class="headerlink" title="1.5.2 向上类型转换"></a>1.5.2 向上类型转换</h3><p>将派生类的指针、引用、对象转换为基类指针、引用、对象称为向上类型转换。<br>说明：</p>
<ol>
<li>将派生类对象转换为基类对象时，实际上根据派生类对象裁剪出创建了一个新的基类对象。</li>
<li>将派生类指针、引用转换为基类指针、引用时没有创建新的对象，编译器只是对这个起始内存空间从按派生类类型解释变为按基类类型解释。</li>
<li>对于使用<code>protected/private</code>继承方式，向上类型转换没有什么实际意义，且需要通过强制类型转换实现。<br><img src="https://i-blog.csdnimg.cn/direct/0c064e0602a143cfb9e1e3de351868a4.png" alt="在这里插入图片描述"></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repair</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change_color</span><span class="params">(<span class="type">int</span> color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">private</span> Bike </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_race</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end_race</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cur_strength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _max_strength;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    Bike *p = (Bike *) &amp;player; <span class="comment">// 使用protected/private继承时，需要强制类型转换</span></span><br><span class="line">    Bike &amp;ref = (Bike &amp;) player; <span class="comment">// 使用protected/private继承时，需要强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; _id = id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    Person *point = &amp;s; <span class="comment">// 将s对象的内存空间按Person类型解释</span></span><br><span class="line">    Person &amp;ref = s; <span class="comment">// 将s对象的内存空间按Person类型解释</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-继承下的友元"><a href="#1-6-继承下的友元" class="headerlink" title="1.6 继承下的友元"></a>1.6 继承下的友元</h2><p><strong>友元关系不能继承</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">   	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Base</span>;  <span class="comment">// 声明 Base 为 A 的友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secret = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessSecret</span><span class="params">(A&amp; a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base can access secret: &quot;</span> &lt;&lt; a.secret &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessSecret</span><span class="params">(A&amp; a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试访问 A 的私有成员,编译错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived can access secret: &quot;</span> &lt;&lt; a.secret &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Base base;</span><br><span class="line">    Derived derived;</span><br><span class="line"></span><br><span class="line">    base.<span class="built_in">accessSecret</span>(a);      <span class="comment">// 正常工作，Base 可以访问 A 的私有成员</span></span><br><span class="line">    derived.<span class="built_in">accessSecret</span>(a);   <span class="comment">// 编译错误，Derived 无法访问 A 的私有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-继承下的static成员变量"><a href="#1-7-继承下的static成员变量" class="headerlink" title="1.7 继承下的static成员变量"></a>1.7 继承下的static成员变量</h2><p><strong>static成员变量在类中是共享的</strong>，这意味着类的所有实例共享同一个变量，无论派生出多少个类，都只有一个static成员变量 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印出的地址相同</span></span><br><span class="line">    cout &lt;&lt; &amp;a._a &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; &amp;b._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;c._a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、派生类的成员函数"><a href="#二、派生类的成员函数" class="headerlink" title="二、派生类的成员函数"></a>二、派生类的成员函数</h1><h2 id="2-1-派生类构造与析构函数"><a href="#2-1-派生类构造与析构函数" class="headerlink" title="2.1 派生类构造与析构函数"></a>2.1 派生类构造与析构函数</h2><h3 id="2-1-1-派生类构造函数"><a href="#2-1-1-派生类构造函数" class="headerlink" title="2.1.1 派生类构造函数"></a>2.1.1 派生类构造函数</h3><p>在派生类中不显式定义构造函数，编译器自动生成构造函数。这个构造函数会先调用基类的默认构造函数，然后调用派生类中自定义类型成员变量的默认构造函数。</p>
<p>派生类显式定义构造函数说明：</p>
<ul>
<li>构造顺序：先基类，再派生类</li>
<li>若没在派生类的初始化列表中显式指定基类构造函数，编译器会隐式调用基类的无参构造函数</li>
<li>多重继承时，基类按先后顺序构造</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> b) : _b(b) &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">A</span>(a), <span class="built_in">B</span>(b), _c(c) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 依次输出 A() 、B() 、C()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-派生类析构函数"><a href="#2-1-2-派生类析构函数" class="headerlink" title="2.1.2 派生类析构函数"></a>2.1.2 派生类析构函数</h3><p>在派生类中不显式定义析构函数，编译器自动生成析构函数。这个析构函数会先调用派生类中自定义类型成员变量的析构函数，然后调用基类的析构函数。</p>
<p>派生类显式定义析构函数说明：</p>
<ul>
<li>析构顺序：先派生类，再基类</li>
<li>不要显式调用基类析构函数：为了保证析构顺序,编译器会在派生类的析构函数结束前自动调用基类析构函数。如果用户显式调用了,则会对基类析构两次。</li>
<li>多重继承时，基类析构顺序与基类构造顺序相反</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() <span class="comment">// 基类的析构函数建议为虚函数，通过基类指针或引用删除一个派生类对象，virtual确保能调用派生类的析构函数，后续多态章节会详细讲解</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        A::~<span class="built_in">A</span>(); <span class="comment">// 不应该显式调用基类的析构函数，这样基类会析构两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b; <span class="comment">// 依次输出 ~B() 、~A() 、~A()， 基类调用了两次析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-派生类拷贝构造与赋值函数"><a href="#2-2-派生类拷贝构造与赋值函数" class="headerlink" title="2.2 派生类拷贝构造与赋值函数"></a>2.2 派生类拷贝构造与赋值函数</h2><h3 id="2-2-1-派生类拷贝构造函数"><a href="#2-2-1-派生类拷贝构造函数" class="headerlink" title="2.2.1 派生类拷贝构造函数"></a>2.2.1 派生类拷贝构造函数</h3><p>在派生类中不显式定义拷贝构造函数，编译器自动生成拷贝构造函数。这个拷贝构造函数会先调用基类的拷贝构造函数，然后对派生类对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的拷贝构造函数。</p>
<p>派生类显式定义析构函数说明：</p>
<ul>
<li>拷贝构造顺序：先基类，再派生类</li>
<li>若没在派生类的初始化列表中显式指定基类拷贝构造函数，编译器会隐式调用基类的拷贝构造函数</li>
<li>多重继承时，基类按先后顺序拷贝构造</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) : _a(a) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;obj):_a(obj._A)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(const &amp;A)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;obj) : <span class="built_in">A</span>(obj) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B(const &amp;B)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 依次输出 A(const &amp;A)、B(const &amp;B)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-派生类赋值函数"><a href="#2-2-2-派生类赋值函数" class="headerlink" title="2.2.2 派生类赋值函数"></a>2.2.2 派生类赋值函数</h3><p>在派生类中不显式定义赋值函数，编译器自动生成赋值函数。这个赋值函数会先调用基类的赋值函数，然后对派生类对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的赋值函数。</p>
<p>派生类显式定义赋值函数说明：</p>
<ul>
<li>赋值顺序：先基类，再派生类</li>
<li>多重继承时，基类按先后顺序赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) : _a(a) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A=()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="type">const</span> B &amp;obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) </span><br><span class="line">        &#123;</span><br><span class="line">            A::<span class="keyword">operator</span>=(obj); <span class="comment">// 调用基类的赋值函数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B=()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    B b2;</span><br><span class="line">    b2 = b1; <span class="comment">// 依次输出 A=()、B=()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、菱形继承"><a href="#三、菱形继承" class="headerlink" title="三、菱形继承"></a>三、菱形继承</h1><h2 id="3-1-什么是菱形继承"><a href="#3-1-什么是菱形继承" class="headerlink" title="3.1 什么是菱形继承"></a>3.1 什么是菱形继承</h2><p>多个子类继承同一个父类而又有子类同时继承这几个子类或其子孙类。<br><img src="https://i-blog.csdnimg.cn/direct/f2dec37c960149259e6d5ca09036d630.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _num; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _id; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _majorCourse; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-菱形继承带来的问题"><a href="#3-2-菱形继承带来的问题" class="headerlink" title="3.2 菱形继承带来的问题"></a>3.2 菱形继承带来的问题</h2><p>菱形继承带来了<strong>二义性</strong>和<strong>数据冗余</strong>的问题。</p>
<p>二义性：<code>Student</code>和<code>Teacher</code>类都继承<code>Person</code>类，所以它们继承了_name属性，<code>Assistant</code>类继承<code>Student</code>和<code>Teacher</code>类，所以在<code>Assistant</code>类中访问_name时会有歧义，编译器不知道是访问<code>Student</code>类的_name还是<code>Teacher</code>类的_name。</p>
<p>数据冗余：对于<code>Assistant</code>对象来说存放两份_name。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Assistant a;</span><br><span class="line">    a._name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 错误，二义性</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 指定基类作用域解决二义性问题，但是无法解决数据冗余问题。</span></span><br><span class="line">    a.Student::_name = <span class="string">&quot;张三&quot;</span>; </span><br><span class="line">    a.Teacher::_name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定基类作用域解决二义性问题，但是用起来很奇怪，对<code>Assistant</code>类来说_name属性应该只有一个才对，不能我学生身份时有一个名字，教师身份时又有一个名字，而且没有解决数据冗余问题。</p>
<h2 id="3-3-菱形继承内存布局"><a href="#3-3-菱形继承内存布局" class="headerlink" title="3.3 菱形继承内存布局"></a>3.3 菱形继承内存布局</h2><p>为了便于观察菱形继承的内存布局，下面使用简化的类结构。<br>测试环境： MSVC编译器 32位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/7bf69cccfc3e46e284385799c85141ed.png" alt="在这里插入图片描述"></p>
<h2 id="3-4-虚继承解决方案"><a href="#3-4-虚继承解决方案" class="headerlink" title="3.4 虚继承解决方案"></a>3.4 虚继承解决方案</h2><h3 id="3-4-1-虚继承原理"><a href="#3-4-1-虚继承原理" class="headerlink" title="3.4.1 虚继承原理"></a>3.4.1 虚继承原理</h3><p>&emsp;虚继承（虚拟继承） 是面向对象编程中的一种技术，是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。通过虚继承可以解决菱形继承带来的二义性与数据冗余问题。</p>
<p>语法：<br><code>class Derive: virtual public Base&#123;&#125;;</code></p>
<p><font color=red >注意：只有直接继承基类的派生类需要进行虚继承,间接继承的派生类不需要。</font><br>测试环境： MSVC编译器 32位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/c06e042aa55e46338e3c31442e7ea45a.png" alt="在这里插入图片描述"><br>观察d对象内存视图可以发现，使用虚继承后，将同属于B和C的A存放到对象最下面， 将 B空间位置原来存放基类A的地方现在存放了一个指针，C空间位置原来存放基类A的地方现在也变为存放了一个指针，这两个指针为虚基表指针，虚基表中存放了A的偏移量。查看B的虚基表（0x00bfbb40）可以看到有一个值0x14000000(补码)，转换为源码后对应的值为20，B空间首地址加上偏移量20刚好是A中成员_a的地址。查看C的虚基表（0x00bfbb48）可以看到有一个值0x0c000000(补码)，转换为源码后对应的值为12，C空间首地址加上偏移量12刚好是A中成员_a的地址。这就是虚继承解决二义性与数据冗余的原理。</p>
<p>说明：</p>
<ul>
<li>虚基表中起始全0的4个字节空间是为了实现多态的虚表指针预留的。</li>
<li>虚继承的基类只会调用一次构造.</li>
<li>菱形继承没有虚基表,菱形虚拟继承才有虚基表</li>
</ul>
<p><strong>同一派生类的所有对象共享一份虚基表</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D d1, d2 ,d3;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/direct/df3a23cb8b6144eb9a4340296d57e6bc.png" alt="在这里插入图片描述"></p>
<h3 id="3-4-2-虚继承缺点"><a href="#3-4-2-虚继承缺点" class="headerlink" title="3.4.2 虚继承缺点"></a>3.4.2 虚继承缺点</h3><ol>
<li>参照前文部分，虚继承对于B类与C类的开发者提出更高要求，能预言出未来会被多继承而引发的菱形继承问题。</li>
<li>在<code>public</code>继承下向上类型转换是安全的，但是虚继承改变了对象内存布局，类型转换时编译器要做很多额外操作，效率低下。</li>
</ol>
<h1 id="四、继承与组合的选择"><a href="#四、继承与组合的选择" class="headerlink" title="四、继承与组合的选择"></a>四、继承与组合的选择</h1><p><strong>组合：</strong></p>
<ul>
<li>具有”has-a”或”contain-a”的关系</li>
<li>子对象所属类的源代码可有可无</li>
<li>类间是水平关系，相比继承可减少类的层次</li>
<li>黑盒复用，功能复用</li>
</ul>
<p><strong>继承：继承方式不同，目的不同</strong></p>
<ul>
<li>基类源代码必须有</li>
<li>白盒复用，代码复用</li>
<li>public继承表示“is-a”关系</li>
<li>private继承表示“has-a”，”contain-a”，”implement of”关系，完全可以换成组合</li>
<li>protected继承同private，同时便于在多层继承中保持这种关系</li>
</ul>
<p>总结：除了”is-a”关系使用public继承以外其它都使用组合。</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
  </entry>
  <entry>
    <title>C语言 内存函数</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>前言：C语言提供了许多与内存相关函数，可以在头文件&lt;string.h&gt;中查看函数声明，本章将会自行编写相关内存函数</p>
<span id="more"></span>

<h1 id="一、内存复制函数"><a href="#一、内存复制函数" class="headerlink" title="一、内存复制函数"></a>一、内存复制函数</h1><h2 id="1-1-memcpy函数"><a href="#1-1-memcpy函数" class="headerlink" title="1.1 memcpy函数"></a>1.1 memcpy函数</h2><p><strong>功能：<br>将num字节的值从source指向的位置直接拷贝到destination指向的内存块，该函数不检查源中是否有’\0’字符——它总是精确地复制num字节。但是source与destination发生内存重叠，结果是未定义的</strong><br>库函数memcpy声明<br><code>void * memcpy ( void * destination, const void * source, size_t num );</code><br>返回值：返回目标起始位置<br>destination ：目标指向内存块起始地址<br>source：源指向内存块起始地址<br>num :需要复制的字节数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* destination, <span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//检查destination与source是否为空指针</span></span><br><span class="line">	<span class="type">char</span> * des = (<span class="type">char</span> *)destination; <span class="comment">//将void * 类型转换为char *类型，便于后面指针算术运算</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * src = (<span class="type">char</span>*)source;</span><br><span class="line">	<span class="keyword">while</span> (num--)</span><br><span class="line">	&#123;</span><br><span class="line">		*des++ = *src++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>警告：<br>如果源与目标以任何形式发生内存重叠，它的结果是未定义的。当发生内存重叠应该使用memmove函数而不是memcpy函数</strong></p>
<p>例：<br><code>int arr[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;</code><br>将数组下标0-3对应元素值依次复制到下标2-5对应元素<br>预想复制后数组为<code>int arr[10] = &#123;1,2,1,2,3,4,7,8,9,10&#125;</code>，但实际数组为<code>int arr[10] = &#123;1,2,1,2,1,2,7,8,9,10&#125;</code>。<br><strong>因为从下标第2-3元素发生内存重叠</strong>。复制后下标2元素为1，下标3元素为2，所以下标为4元素值变为1，下标为5元素值变为2</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d8c2b73e0b91e29c7208984b61ee0ff7.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* destination, <span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//检查destination与source是否为空指针</span></span><br><span class="line">	<span class="type">char</span> * des = (<span class="type">char</span> *)destination; <span class="comment">//将void * 类型转换为char *类型，便于后面指针算术运算</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * src = (<span class="type">char</span>*)source;</span><br><span class="line">	<span class="keyword">while</span> (num--)</span><br><span class="line">	&#123;</span><br><span class="line">		*des++ = *src++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	my_memcpy(arr + <span class="number">2</span>, arr, <span class="number">16</span>);<span class="comment">//destination为arr[2]地址,source为arr[0]地址，复制16，即4个int类型大小</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-memmove函数"><a href="#1-2-memmove函数" class="headerlink" title="1.2 memmove函数"></a>1.2 memmove函数</h2><p><strong>功能：<br>将num字节的值从source指向的位置直接拷贝到destination指向的内存块，该函数不检查源中是否有’\0’字符——它总是精确地复制num字节。source与destination可以发生内存重叠</strong><br>库函数memmove声明<br><code>void * memmove ( void * destination, const void * source, size_t num );</code><br>返回值：返回目标起始位置<br>destination ：目标指向内存块起始地址<br>source：源指向内存块起始地址<br>num :需要复制的字节数</p>
<p><strong>memmove函数允许source与destination可以发生内存重叠。那么在复制时有三种处理方式</strong><br>情况1： source地址 <strong>&lt;** destination地址 时将**从后向前**复制<br>情况2： source地址 **&gt;</strong> destination地址 时将<strong>从前向后</strong>复制<br>情况3： source地址 <strong>&#x3D;&#x3D;</strong> destination地址时，从前向后或从后向前复制都可以，本案例会采用<strong>从前向后</strong>复制<br><img src="https://i-blog.csdnimg.cn/blog_migrate/abe3f1a0e534b4331a68121669c4f20f.png#pic_center" alt="在这里插入图片描述"></p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">my_memmove</span><span class="params">(<span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source); <span class="comment">//检查destination与source是否为空指针</span></span><br><span class="line">	<span class="type">char</span> * des = (<span class="type">char</span> *)destination; <span class="comment">//将void * 类型转换为char *类型，便于后面指针算术运算</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * src = (<span class="type">char</span> *)source;</span><br><span class="line">	<span class="keyword">if</span> (src &lt; des) <span class="comment">//从后向前复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (num--)</span><br><span class="line">		&#123;</span><br><span class="line">			*(des+num) = *(src+num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//从前向后复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (num--)</span><br><span class="line">		&#123;</span><br><span class="line">			*des++ = *src++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">my_memmove</span><span class="params">(<span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source); <span class="comment">//检查destination与source是否为空指针</span></span><br><span class="line">	<span class="type">char</span> * des = (<span class="type">char</span> *)destination; <span class="comment">//将void * 类型转换为char *类型，便于后面指针算术运算</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * src = (<span class="type">char</span> *)source;</span><br><span class="line">	<span class="keyword">if</span> (src &lt; des) <span class="comment">//从后向前复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (num--)</span><br><span class="line">		&#123;</span><br><span class="line">			*(des+num) = *(src+num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//从前向后复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (num--)</span><br><span class="line">		&#123;</span><br><span class="line">			*des++ = *src++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> arr2[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	my_memmove(arr1 + <span class="number">2</span>, arr1, <span class="number">16</span>);<span class="comment">//destination为arr[2]地址,source为arr[0]地址，复制16，即4个int类型大小</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr1:&gt;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	my_memmove(arr2, arr2+<span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr2:&gt;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr1:&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">arr2:&gt;</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="二、内存比较函数-memcmp"><a href="#二、内存比较函数-memcmp" class="headerlink" title="二、内存比较函数 memcmp"></a>二、内存比较函数 memcmp</h1><p><strong>功能：<br>memcmp对两段内存中的内容进行比较，两段内存分别起始ptr1和ptr2，共比较num个字节。当num个字节内容相等返回0，ptr1大于ptr2返回大于0值，ptr1小于ptr2返回小于0的值</strong></p>
<p>库函数memcmp声明<br><code>int memcmp ( const void * ptr1, const void * ptr2, size_t num );</code><br>ptr1 ： 第一段内存起始地址<br>ptr2： 第二段内存起始地址<br>num： 比较字节个数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(ptr1 &amp;&amp; ptr2); <span class="comment">//检查ptr1与ptr2是否为空指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * p1 = (<span class="type">char</span> *)ptr1; <span class="comment">//将void * 类型转换为char *类型</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * p2 = (<span class="type">char</span> *)ptr2; <span class="comment">//将void * 类型转换为char *类型</span></span><br><span class="line">	<span class="keyword">while</span> (num--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p1 == *p2)</span><br><span class="line">		&#123;</span><br><span class="line">			p1++;</span><br><span class="line">			p2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *p1 - *p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、内存查找字符函数-memchr"><a href="#三、内存查找字符函数-memchr" class="headerlink" title="三、内存查找字符函数 memchr"></a>三、内存查找字符函数 memchr</h1><p><strong>功能：<br>从ptr开始向后查找字符value第1次出现的位置，并返回一个指向该位置的指针，它最多向后搜寻num个字节。如果未找到，返回NULL指针</strong><br>库函数memchr声明<br><code>const void * memchr ( const void * ptr, int value, size_t num );</code><br>ptr:待搜索内存起始位置<br>value :需要查找字符<br>num :要搜寻的字节个数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> * <span class="title function_">my_memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(ptr);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * p = (<span class="type">char</span>*)ptr;</span><br><span class="line">	<span class="keyword">while</span> (num--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="type">void</span>*)p;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、内存设置函数-memset"><a href="#四、内存设置函数-memset" class="headerlink" title="四、内存设置函数 memset"></a>四、内存设置函数 memset</h1><p><strong>功能<br>把从ptr开始的num个字节都设置为字符值value</strong><br>库函数memset声明<br><code>void * memset ( void * ptr, int value, size_t num );</code><br>ptr： 待设置内存起始位置<br>value :设置字符值<br>num :要设置字节的个数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memset</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">int</span> value, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(ptr);</span><br><span class="line">	<span class="type">char</span> * p = ptr;</span><br><span class="line">	<span class="keyword">while</span> (num--)</span><br><span class="line">	&#123;</span><br><span class="line">		*p++ = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 函数</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h1><h2 id="1-1-什么是函数"><a href="#1-1-什么是函数" class="headerlink" title="1.1 什么是函数"></a>1.1 什么是函数</h2><p>函数：完成特定功能的程序段<br>维基百科对函数的定义：子程序<br>&emsp;&emsp;1.在计算机科学中，子程序是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，<strong>具有相对独立性</strong>。<br>&emsp;&emsp;2.一般会有输入参数并有返回值，提供了对<strong>实现过程的封装和细节的隐藏</strong>。</p>
<span id="more"></span>

<h2 id="1-2-C语言中函数分类"><a href="#1-2-C语言中函数分类" class="headerlink" title="1.2 C语言中函数分类"></a>1.2 C语言中函数分类</h2><p>函数主要分为两大类：库函数和自定义函数</p>
<p><strong>库函数</strong>：编译器提供的可在C源程序中调用的函数。库函数又分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数（如：MSVC编译器提供的scanf_s函数）。由于版权原因，库函数的源代码一般不可见，但在头文件中可以看到它对外提供的接口)</p>
<p>使用库函数需要引用对应头文件： #include&emsp; &lt;文件名&gt;<br>库函数参考手册网址：</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tLw==">http://www.cplusplus.com/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>自定义函数</strong>：程序员根据需要编写的函数，也是本文谈论的重点</p>
<h1 id="二、函数定义与声明"><a href="#二、函数定义与声明" class="headerlink" title="二、函数定义与声明"></a>二、函数定义与声明</h1><h2 id="2-1函数的定义"><a href="#2-1函数的定义" class="headerlink" title="2.1函数的定义"></a>2.1函数的定义</h2><p>函数的定义：一个函数的具体实现<br>语法：<br><strong>返回类型&emsp;函数名(形参列表){<br>&emsp;&emsp;功能代码；<br>}</strong></p>
<p>返回类型：一个函数执行完后可以返回特定的值给主程序，返回类型就是指定返回值的数据类型，<strong>如果不需要返回值，此时写上void</strong>。<strong>如果有返回值，在功能代码部分必要要有return语句</strong>;</p>
<p>函数名：一个标识符，应该尽量使用能表明函数功能的名字，比如一个求和的函数可以使用sum命名</p>
<p>形参列表：什么是形参后面会讲到，这里先理解成参数列表。指需要传入到函数内的参数，当不要参数时为空，需要参数时要写上参数类型和参数名</p>
<p>功能代码：大括号内是函数的功能代码，是函数功能具体的实现代码</p>
<p>return: 终止当前函数执行，并返回return后面的值（<strong>类型必须与返回类型相同</strong>）。如果函数中没有return语句，那么只有遇到函数反大括号才会结束函数的执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个求两值相加和的函数，函数返回类型是int，所以只能求整数相加。</span></span><br><span class="line"><span class="comment">//函数名为sum,函数需要两个形式参数，分别是x、y且都为int类型</span></span><br><span class="line"><span class="comment">//函数最后返回 x+y的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个打印函数，函数没有返回值，不需要传入参数，函数名为print</span></span><br><span class="line"><span class="comment">//执行此函数输出欢迎访问我的博客，由于没有返回值，所以不需要使用return语句</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎访问我的博客\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1函数的声明"><a href="#2-1函数的声明" class="headerlink" title="2.1函数的声明"></a>2.1函数的声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	result = sum(a, b);名叫sum的函数  <span class="comment">//编译是从上到下的顺序，编译时此处会报错或警告，因为此时找不到一个名为sum的函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数声明：<br>1.告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但是具体是不是存在，函数声明决定不了<br>2.函数的声明一般在函数使用之前出现，<strong>要满足先声明后使用</strong><br>3.函数声明一般要放在头文件内<br>4.<strong>函数定义出现在函数调用（使用）之前，可以省略函数声明</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//函数定义在使用之前，这种情况可以不进行函数声明</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	result = sum(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数声明语法</strong>： 返回类型 函数名(参数列表);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	result = sum(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、写函数小技巧"><a href="#三、写函数小技巧" class="headerlink" title="三、写函数小技巧"></a>三、写函数小技巧</h1><p>写函数时候，首先要了解需求，即这个函数是干什么的、要解决什么问题。是否需要返回值，如果需要返回值类型是怎样的。是否需要传入参数。要做到<strong>高内聚低耦合</strong>。</p>
<h2 id="3-1判断质数的函数"><a href="#3-1判断质数的函数" class="headerlink" title="3.1判断质数的函数"></a>3.1判断质数的函数</h2><p>分析：质数就是只能被1和本身整除的数字。如果被其他数字整除就不是质数。假设一个数n，那在<br> [2，n-1]的范围内用n对它们取余数都必须不等于0。但是我们可以继续优化，减少计算。我们对n开平方根。那么范围可以是[2，√n]。另外如果是1或2那么本身就是质数所以不需要计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime_number</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">//1 代表是质数  0 代表 不是质数</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) <span class="comment">// sqrt是开平方根的库函数，需要引用头文件math.h</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="comment">//如果在[2,√n]范围内的某个数被n取余数是0，就不是质数，终止函数的后续判断</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个数：》&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span> (prime_number(n))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d是质数\n&quot;</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d不是质数\n&quot;</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>不是质数</span><br></pre></td></tr></table></figure>
<h2 id="3-2-求第n个斐波那契数"><a href="#3-2-求第n个斐波那契数" class="headerlink" title="3.2 求第n个斐波那契数"></a>3.2 求第n个斐波那契数</h2><p>分析：斐波那契数列为： 1、1、2、3、5、8、13……，从第三个数开始，每个数的值等于前两个斐波那契数相加的值<br>f(x) &#x3D;  1  &emsp;  [1，2]<br>f(x) &#x3D;  f(x-2)  +  f(x-1)   &emsp; x&gt;2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci_number</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">//从第三个数开始，每个数的值等于前两个斐波那契数相加的值</span></span><br><span class="line">	<span class="comment">//定义三个变量，n1代表第一个数,n2代表第二个数,n3代表第三个数即我们所求的数</span></span><br><span class="line">	<span class="type">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n3 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> n3; <span class="comment">//当求第1个或第2个斐波那契数时直接返回n3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= n; i++) <span class="comment">//i代表需要循环次数，由于前2个斐波那契数不需要求，所以i从3开始</span></span><br><span class="line">		&#123;</span><br><span class="line">			n3 = n1 + n2; </span><br><span class="line">			n1 = n2;</span><br><span class="line">			n2 = n3;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入需要求的第几个斐波那契数：》&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;第%d个斐波那契数为：%d&quot;</span>, n, fibonacci_number(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第<span class="number">7</span>个斐波那契数为：<span class="number">13</span></span><br></pre></td></tr></table></figure>

<h1 id="四、函数调用"><a href="#四、函数调用" class="headerlink" title="四、函数调用"></a>四、函数调用</h1><p><strong>函数的调用就是函数的使用</strong>。函数调用通过使用函数调用运算符构成函数调用表达式实现。函数调用操作符是 ( )，函数调用表达式的一般形式：<br>&emsp; <strong>函数名(参数列表);</strong><br>函数没有参数时，( )内为空就行</p>
<h2 id="4-1实参与形参"><a href="#4-1实参与形参" class="headerlink" title="4.1实参与形参"></a>4.1实参与形参</h2><p><strong>实参</strong>：函数调用操作符中的参数称为实际参数，简称实参，每个实参前面没有类型说明符，传入实参类型与个数必要与对应函数定义里面的相同</p>
<p><strong>形参</strong>：函数定义中（）内的参数叫做形式参数，简称形参。<strong>形式参数只有在函数调用的过程中才会分配内存空间</strong>。形参在函数调用完成后<strong>就会自动销毁</strong>。因此形参只会在函数中有效。本质上形参只是实参的一份临时拷贝</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	result = sum(a, b);  <span class="comment">//这里的a和b是实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//函数这里传入的x和y是形参</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2传值调用与传址调用"><a href="#4-2传值调用与传址调用" class="headerlink" title="4.2传值调用与传址调用"></a>4.2传值调用与传址调用</h2><p>以下通过这个案例演示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;<span class="comment">//交换x和y的值</span></span><br><span class="line">	<span class="type">int</span> tmp = x;  </span><br><span class="line">	x = y; </span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a与b交换前：a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">	swap(a, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a与b交换后：a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a与b交换前：a=<span class="number">10</span> b=<span class="number">20</span></span><br><span class="line">a与b交换后：a=<span class="number">10</span> b=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现，调用swap函数，a和b的值却没有交换。这是因为此时我们是传值调用。<br><strong>传值调用</strong>：形参和实参分别占用不同的内存区域，对形参的改变不会影响实参<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cdb6167dc50a354053d2c6ce25c2a67c.png#pic_center" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/961413cb50183671bb788daee8e1746c.png#pic_center" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/5c336de62b01f1b2c377d219a58545b1.png#pic_center" alt="在这里插入图片描述"></p>
<p>我们可以发现，实参a和b  与 形参x和y占用不同内存地址，通过传入实参a、b对形参x、y赋值后，实参a、b和形参x、y就没有任何关系了，所以对x、y的值的修改并不会影响实参a和b</p>
<p><strong>传址调用</strong>：<strong>把函数外部创建变量的内存地址传递给函数的形参</strong>。这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是通过函数内部可以操作函数外部的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span> &#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;   <span class="comment">//整形指针变量px存的是a的地址,整形指针变量py存的是b的地址</span></span><br><span class="line">	*px = *py;     <span class="comment">//通过*号 解引用操作符找到pa变量所指向地址空间（a的空间）并更改存储的值</span></span><br><span class="line">	*py = tmp;		 <span class="comment">//通过*号 解引用操作符找到py变量所指向地址空间（b的空间）并更改存储的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a与b交换前：a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">	swap(a, b); <span class="comment">//传入的是a与b的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a与b交换后：a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a与b交换前：a=<span class="number">10</span> b=<span class="number">20</span></span><br><span class="line">a与b交换后：a=<span class="number">20</span> b=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/d349c0c223fc172031b19f7cfeedd535.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>简单来说，如果传入的是变量的地址就是传址调用，否则就是传值调用。当需要在函数内部改变外部变量的值时要使用传址调用</strong></p>
<h2 id="4-3嵌套调用和链式访问"><a href="#4-3嵌套调用和链式访问" class="headerlink" title="4.3嵌套调用和链式访问"></a>4.3嵌套调用和链式访问</h2><p>嵌套调用：函数和函数之间可以根据实际的需求进行组合，即在函数内部调用另外一个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎访问我的博客\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		test1(); <span class="comment">//嵌套调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	test2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">欢迎访问我的博客</span><br><span class="line">欢迎访问我的博客</span><br><span class="line">欢迎访问我的博客</span><br><span class="line">欢迎访问我的博客</span><br><span class="line">欢迎访问我的博客</span><br></pre></td></tr></table></figure>
<p>链式访问：把一个函数返回值作为一个函数的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="comment">//返回x与y的较大值</span></span><br><span class="line">	<span class="keyword">if</span> (x &gt; y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	result = max(<span class="number">100</span>, max(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">//链式访问，将max(10,20)的返回值20作为参数传入max函数，即max(100,20)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><strong>函数可以嵌套调用，但是不能嵌套定义（不能在一个函数内定义另外一个函数）</strong></p>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 初级指针讲解</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E5%88%9D%E7%BA%A7%E6%8C%87%E9%92%88%E8%AE%B2%E8%A7%A3.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、指针是什么"><a href="#一、指针是什么" class="headerlink" title="一、指针是什么"></a>一、指针是什么</h1><h2 id="1-1-地址是什么"><a href="#1-1-地址是什么" class="headerlink" title="1.1 地址是什么"></a>1.1 地址是什么</h2><p>&emsp;在计算机中，为了对内存空间进行管理，将内存空间划分成若干个存储单元。每个存储单元大小为1字节，并对每个存储单元编号，这个编号被称为地址（内存地址）。可以把内存想象成一个大的教学楼，为了对教学楼管理，分成了许多教室，这里教室等同于存储单元，为了方便找到某一个教室，可以对教室进行编号，如：301教室，这里的教室编号等同于地址。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c04d9ce5535534115244fe3c485d3687.png#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>

<h2 id="1-2-指针与指针变量"><a href="#1-2-指针与指针变量" class="headerlink" title="1.2 指针与指针变量"></a>1.2 指针与指针变量</h2><p><strong>指针：指针就是内存地址</strong><br><strong>指针变量：用来存放内存地址的变量</strong>，存储的地址对应了内存中某个存储单元，通过解引用可以访问到对应存储单元里面的值。</p>
<p>程序执行时会为变量分配存储单元存储变量的值，根据变量类型的不同，分配的存储单元数量（空间大小）也不一样。<br>char类型 1字节&emsp;short类型 2字节&emsp;int类型 4字节<br><img src="https://i-blog.csdnimg.cn/blog_migrate/16518245e4ac96ec823e7df245d17bd9.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>指针变量的声明：</strong><br><strong>类型 * 变量名;</strong><br>  如 ： int * p;<br>“变量名” 前 * 表示其后的变量是指针变量，该变量只能存储地址<br>”类型“ 表示该指针变量类型，如： int *代表整形指针类型，也代表是为了存放 int 类型变量的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;i; <span class="comment">//这里 &amp; 是取地址运算符即取出变量n的所占存放单元起始地址，这里 * 是指针类型声明的标志，int 代表指针变量p所存储是一个int类型变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p); <span class="comment">// %p   指以指针方式打印</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0135F</span>E10</span><br></pre></td></tr></table></figure>
<p><strong>说明：&amp;取出的是一个变量在内存中起始存储单元的地址，比如：int类型所占4个存储单元，但只会取出4个存储单元中最小的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;i;<span class="comment">//指针p存放变量i的地址</span></span><br><span class="line">    *p = <span class="number">20</span>; <span class="comment">//这里*指访问指针变量p存储地址对应的存储单元，并将值修改为20 等同于 i = 20;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cb627686cb67453fecbac400ec6ea385.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、指针类型意义"><a href="#二、指针类型意义" class="headerlink" title="二、指针类型意义"></a>二、指针类型意义</h1><p>我们知道变量有不同类型，比如：int、char、float、double等，那么指针变量也是有不同类型的<br><strong>说明：为了讲解方便，后续的指针指的是指针变量，后面不再阐述</strong></p>
<p>指针是一个变量，那么它也会占内存空间，在32位平台里面，指针所占内存空间大小为4字节。在64位平台里面，指针所占内存空间大小为8字节。<strong>指针所占内存空间大小与指针类型无关</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//此例子是在32位平台演示</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char * = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short * = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int * = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long * = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double * = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>*));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * = <span class="number">4</span></span><br><span class="line"><span class="type">short</span> * = <span class="number">4</span></span><br><span class="line"><span class="type">int</span> * = <span class="number">4</span></span><br><span class="line"><span class="type">long</span> * = <span class="number">4</span></span><br><span class="line"><span class="type">double</span> * = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>既然指针所占内存空间大小与指针类型无关那么为什么还要不同的指针类型呢，比如： int *、char *、double *等指针类型，下面会逐渐讲解</p>
<h2 id="2-1-指针-整数"><a href="#2-1-指针-整数" class="headerlink" title="2.1 指针+-整数"></a>2.1 指针+-整数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span>* pa = &amp;i; <span class="comment">//使用char*类型指针存储i的地址</span></span><br><span class="line">    <span class="type">short</span>* pb = &amp;i; <span class="comment">//使用short*类型指针存储i的地址</span></span><br><span class="line">    <span class="type">int</span>* pc = &amp;i;	<span class="comment">//使用int*类型指针存储i的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa = %p\n&quot;</span>, pa); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pb = %p\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>, pc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa+1 = %p\n&quot;</span>, pa+<span class="number">1</span>); <span class="comment">//地址向后移动1个字节，因为char大小为1字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pb+1 = %p\n&quot;</span>, pb+<span class="number">1</span>);<span class="comment">//地址向后移动2个字节，因为short大小为1字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pc+1 = %p\n&quot;</span>, pc+<span class="number">1</span>); <span class="comment">//地址向后移动4个字节，因为int大小为1字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa = <span class="number">006F</span>F804</span><br><span class="line">pb = <span class="number">006F</span>F804</span><br><span class="line">pc = <span class="number">006F</span>F804</span><br><span class="line">--------------</span><br><span class="line">pa+<span class="number">1</span> = <span class="number">006F</span>F805 </span><br><span class="line">pb+<span class="number">1</span> = <span class="number">006F</span>F806</span><br><span class="line">pc+<span class="number">1</span> = <span class="number">006F</span>F808</span><br></pre></td></tr></table></figure>

<p><strong>指针的类型决定了指针向前或者向后走一步有多大</strong></p>
<h2 id="2-2-指针的解引用"><a href="#2-2-指针的解引用" class="headerlink" title="2.2 指针的解引用"></a>2.2 指针的解引用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1127</span>; <span class="comment">//0x代表16进制</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000100 01100111  1127的补码</span></span><br><span class="line">    <span class="type">char</span>* pa = &amp;i;</span><br><span class="line">    <span class="type">int</span>* pb = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pa); <span class="comment">//这里*指访问指针变量pa存储的地址对应的存储单元</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *pb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">1127</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/200632d165e4e88eb94b67d624e7d2e7.png#pic_center" alt="在这里插入图片描述"><br><strong>指针类型决定了，对指针解引用的时候有多大的操作权限</strong><br>char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。</p>
<h1 id="三、野指针"><a href="#三、野指针" class="headerlink" title="三、野指针"></a>三、野指针</h1><p>野指针：就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
<h2 id="3-1-野指针成因"><a href="#3-1-野指针成因" class="headerlink" title="3.1 野指针成因"></a>3.1 野指针成因</h2><h3 id="3-1-1-指针未初始化"><a href="#3-1-1-指针未初始化" class="headerlink" title="3.1.1 指针未初始化"></a>3.1.1 指针未初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p;<span class="comment">//指针未初始化，存储的值（地址）默认为随机值</span></span><br><span class="line">    *p = <span class="number">30</span>; <span class="comment">//修改一个未知空间的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-指针越界访问"><a href="#3-1-2-指针越界访问" class="headerlink" title="3.1.2 指针越界访问"></a>3.1.2 指针越界访问</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">//当i=5时，越界访问，访问了数组最后一个元素后面的空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-3-指针指向的空间已经释放"><a href="#3-1-3-指针指向的空间已经释放" class="headerlink" title="3.1.3 指针指向的空间已经释放"></a>3.1.3 指针指向的空间已经释放</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//i是局部变量，函数结束后所在存储空间会被系统回收</span></span><br><span class="line">    <span class="keyword">return</span> &amp;i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">//指针p存储空间已经不属于程序了，此时访问非法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-避免野指针方法"><a href="#3-2-避免野指针方法" class="headerlink" title="3.2 避免野指针方法"></a>3.2 避免野指针方法</h2><ol>
<li>指针初始化</li>
<li>小心指针越界</li>
<li>指针指向空间释放即使置NULL</li>
<li>避免返回局部变量的地址</li>
<li>指针使用之前检查有效性</li>
</ol>
<h1 id="四、指针运算"><a href="#四、指针运算" class="headerlink" title="四、指针运算"></a>四、指针运算</h1><h2 id="4-1-指针-整数"><a href="#4-1-指针-整数" class="headerlink" title="4.1 指针+-整数"></a>4.1 指针+-整数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>可以通过对指针+-整数，访问指针指向的存储单元后面或前面内存区域</strong></p>
<h2 id="4-2-指针-指针"><a href="#4-2-指针-指针" class="headerlink" title="4.2 指针-指针"></a>4.2 指针-指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>* pb = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针pa与指针pb中间间隔%d个元素\n&quot;</span>, pb - pa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针pa与指针pb中间间隔<span class="number">3</span>个元素</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f627a041f2e9657aced5787f8165a5d7.png#pic_center" alt="在这里插入图片描述"><br><strong>指针-指针得到数字的绝对值是指针和指针之间元素的个数<br>前提：两个指针指向的是同一个数组</strong></p>
<h2 id="4-3-指针的关系运算"><a href="#4-3-指针的关系运算" class="headerlink" title="4.3 指针的关系运算"></a>4.3 指针的关系运算</h2><p> 将int arr[5]数组5个元素赋值为0<br><strong>方法一：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>* vp;</span><br><span class="line">    <span class="keyword">for</span> (vp = &amp;arr[<span class="number">5</span>]; vp &gt; &amp;arr[<span class="number">0</span>];)</span><br><span class="line">    &#123;</span><br><span class="line">        *--vp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>* vp;</span><br><span class="line">    <span class="keyword">for</span> (vp = &amp;arr[<span class="number">4</span>]; vp &gt;= &amp;arr[<span class="number">0</span>]; vp--)</span><br><span class="line">    &#123;</span><br><span class="line">        *vp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>C语言标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</strong></p>
<h1 id="五、指针与数组"><a href="#五、指针与数组" class="headerlink" title="五、指针与数组"></a>五、指针与数组</h1><h2 id="5-1-数组名意义"><a href="#5-1-数组名意义" class="headerlink" title="5.1 数组名意义"></a>5.1 数组名意义</h2><p><strong>在一般情况下数组名就是数组首元素地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span>DFFC20</span><br><span class="line"><span class="number">00</span>DFFC20</span><br></pre></td></tr></table></figure>
<p>我们可以将数组名当成地址存放到指针中去，然后对指针+整数，访问数组后续元素的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* p = arr; <span class="comment">//指针存放数组首元素的地址</span></span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//求数组元素大小</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d] = %p   &lt;====&gt; p+%d = %p\n&quot;</span>, i, &amp;arr[i], i, p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr[<span class="number">0</span>] = <span class="number">00</span>EFFB7C   &lt;====&gt; p+<span class="number">0</span> = <span class="number">00</span>EFFB7C</span><br><span class="line">&amp;arr[<span class="number">1</span>] = <span class="number">00</span>EFFB80   &lt;====&gt; p+<span class="number">1</span> = <span class="number">00</span>EFFB80</span><br><span class="line">&amp;arr[<span class="number">2</span>] = <span class="number">00</span>EFFB84   &lt;====&gt; p+<span class="number">2</span> = <span class="number">00</span>EFFB84</span><br><span class="line">&amp;arr[<span class="number">3</span>] = <span class="number">00</span>EFFB88   &lt;====&gt; p+<span class="number">3</span> = <span class="number">00</span>EFFB88</span><br><span class="line">&amp;arr[<span class="number">4</span>] = <span class="number">00</span>EFFB8C   &lt;====&gt; p+<span class="number">4</span> = <span class="number">00</span>EFFB8C</span><br><span class="line">&amp;arr[<span class="number">5</span>] = <span class="number">00</span>EFFB90   &lt;====&gt; p+<span class="number">5</span> = <span class="number">00</span>EFFB90</span><br><span class="line">&amp;arr[<span class="number">6</span>] = <span class="number">00</span>EFFB94   &lt;====&gt; p+<span class="number">6</span> = <span class="number">00</span>EFFB94</span><br><span class="line">&amp;arr[<span class="number">7</span>] = <span class="number">00</span>EFFB98   &lt;====&gt; p+<span class="number">7</span> = <span class="number">00</span>EFFB98</span><br><span class="line">&amp;arr[<span class="number">8</span>] = <span class="number">00</span>EFFB9C   &lt;====&gt; p+<span class="number">8</span> = <span class="number">00</span>EFFB9C</span><br><span class="line">&amp;arr[<span class="number">9</span>] = <span class="number">00</span>EFFBA0   &lt;====&gt; p+<span class="number">9</span> = <span class="number">00</span>EFFBA0</span><br></pre></td></tr></table></figure>
<h2 id="5-2-数组名两个例外"><a href="#5-2-数组名两个例外" class="headerlink" title="5.2 数组名两个例外"></a>5.2 数组名两个例外</h2><p><strong>sizeof(数组名) ：sizeof内部单独放一个数组名，数组名代表整个数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//arr数组有5个元素，每个元素4字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>&amp;数组名  ：取出的是数组地址，数组名表示整个数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* pa = arr; <span class="comment">//取出数组首元素地址</span></span><br><span class="line">    <span class="type">int</span>* pb = &amp;arr;<span class="comment">//取出整个数组地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, pa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr = %p\n&quot;</span>, pb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr +1 = %p\n&quot;</span>, pa+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr +1 = %p\n&quot;</span>, pb+<span class="number">1</span>); <span class="comment">//数组有5个元素，每个元素4字节，所以数组后面的第一片空间地址为 数组首元素地址+元素个数*元素大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr = <span class="number">00</span>DBFE24</span><br><span class="line">&amp;arr = <span class="number">00</span>DBFE24</span><br><span class="line">---------------</span><br><span class="line">arr +<span class="number">1</span> = <span class="number">00</span>DBFE28</span><br><span class="line">&amp;arr +<span class="number">1</span> = <span class="number">00</span>DBFE38</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 动态内存分配</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>&emsp;前言：之前学习了数组，数组的元素储存在内存中连续位置。在声明数组时必须要指定数组的元素个数，即数组空间大小在声明时已经确定了。但是需存放的元素个数常常在运行时才能知道（取决于输入的数据）。这会有几个缺点：<strong>1. 当输入元素个数大于数组声明的元素个数时会带来意想不到错误 2. 当输入元素个数小于数组声明的元素个数时会带来内存空间的浪费 3. 数组大小不能动态调整。</strong></p>
<p><font color=#0000FF >C语言提供了相关的动态内存分配函数，需要多大内存空间就分配多大内存空间，并且可以动态调整已分配的内存空间大小</font></p>
<h1 id="一、动态内存分配函数"><a href="#一、动态内存分配函数" class="headerlink" title="一、动态内存分配函数"></a>一、动态内存分配函数</h1><p>使用下面相关动态内存函数需要引用头文件 <code>&lt;stdlib.h&gt;</code></p>
<h2 id="1-1-malloc和free函数"><a href="#1-1-malloc和free函数" class="headerlink" title="1.1 malloc和free函数"></a>1.1 malloc和free函数</h2><span id="more"></span>

<p><strong>malloc函数功能：<br>向内存申请指定大小的连续内存空间，申请成功返回该空间起始地址，申请失败返回NULL指针</strong><br>库函数malloc声明<br><code>void* malloc (size_t size);</code><br>返回值：申请成功返回该空间起始地址，申请失败返回NULL指针，因为不知道申请的空间要存放什么类型数据所以返回void*类型<br>size: 申请分配的内存大小，单位为字节</p>
<p>注意：</p>
<ol>
<li><p>malloc返回值有可能是NULL指针，使用前需要检查</p>
</li>
<li><p>malloc申请的空间并没有被初始化</p>
</li>
</ol>
<p><strong>free函数功能：<br>释放申请的动态内存分配的空间（即malloc、calloc、realloc函数申请的空间）</strong></p>
<p>库函数free声明<br><code>void free (void* ptr);</code><br>ptr : 指向先前用malloc、calloc或realloc分配的内存块的指针</p>
<p>注意：<br><font color=#FF0000 >1.如果 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的<br>2. 如果ptr 是NULL指针，则函数什么事都不做<br>3. 只会释放ptr指向空间的值，但ptr本身不会被置空</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请10个int类型大小空间,10 * sizeof(int)相对于sizeof(40)更具有移植性</span></span><br><span class="line">	<span class="comment">//由于malloc返回值为void*类型，所以强制类型转换为int*类型</span></span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//空间申请失败则退出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//打印这10个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//对数组元素赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		*(p + i) = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//打印这10个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">//释放p所指向动态内存分配的空间</span></span><br><span class="line">	p = <span class="literal">NULL</span>;<span class="comment">//将p置为NULL指针，防止访问一个已释放的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span> <span class="number">-842150451</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-calloc函数"><a href="#1-2-calloc函数" class="headerlink" title="1.2 calloc函数"></a>1.2 calloc函数</h2><p><strong>calloc函数功能：<br>calloc函数与malloc函数功能一样，区别主要在于calloc会对分配的空间初始化为0，另外它们请求内存大小的方式不同</strong></p>
<p>库函数calloc声明<br><code>void* calloc (size_t num, size_t size);</code><br>返回值：申请成功返回该空间起始地址，申请失败返回NULL指针，因为不知道申请的空间要存放什么类型数据所以返回void*类型<br>num：元素个数<br>size: 元素大小<br><code>申请内存空间大小=num*size</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//空间申请失败则退出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//打印这10个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//对数组元素赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		*(p + i) = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//打印这10个元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">//释放p所指向动态内存分配的空间</span></span><br><span class="line">	p = <span class="literal">NULL</span>;<span class="comment">//将p置为NULL指针，防止访问一个已释放的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><font color=#008000 >使用malloc还是calloc函数取决是否要对动态内存分配的空间初始化</font></p>
<h2 id="1-3-realloc函数"><a href="#1-3-realloc函数" class="headerlink" title="1.3 realloc函数"></a>1.3 realloc函数</h2><p><strong>realloc函数功能：<br>realloc对动态内存空间大小进行扩大或缩小</strong></p>
<p>库函数realloc声明<br><code>void* realloc (void* ptr, size_t size);</code><br>返回值：返回调整后空间的起始地址，调整失败返回NULL指针<br>ptr:指向先前用malloc、calloc或realloc分配的内存块的指针<br>size:动态内存空间新大小，单位为字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//空间申请失败则退出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//对数组元素赋值</span></span><br><span class="line">	&#123;</span><br><span class="line">		*(p + i) = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//对动态内存大小进行调整</span></span><br><span class="line">	<span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="comment">//调整失败并不影响原本p指向空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空间调整失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = ptr; <span class="comment">//调整成功，p指向调整后空间起始地址</span></span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) <span class="comment">//对数组元素赋值</span></span><br><span class="line">		&#123;</span><br><span class="line">			*(p + i) = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) <span class="comment">//打印数组元素</span></span><br><span class="line">	    &#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p + i));</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">//释放p所指向动态内存分配的空间</span></span><br><span class="line">	p = <span class="literal">NULL</span>;<span class="comment">//将p置为NULL指针，防止访问一个已释放的空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3904e10bf2af612ce895775e5b61e9e.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、常见的动态内存错误"><a href="#二、常见的动态内存错误" class="headerlink" title="二、常见的动态内存错误"></a>二、常见的动态内存错误</h1><h2 id="2-1-对NULL指针进行解引用操作"><a href="#2-1-对NULL指针进行解引用操作" class="headerlink" title="2.1 对NULL指针进行解引用操作"></a>2.1 对NULL指针进行解引用操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100000000000000000</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	*p = <span class="number">10</span>; <span class="comment">//没有对p是否非NULL检查</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >申请动态内存分配失败，p为NULL指针，对p解引用修改存储的值会错误</font></p>
<h2 id="2-2-动态内存分配空间的越界访问"><a href="#2-2-动态内存分配空间的越界访问" class="headerlink" title="2.2 动态内存分配空间的越界访问"></a>2.2 动态内存分配空间的越界访问</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		*(p+i) = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >当i&#x3D;10,*(p+i)越界访问了</font></p>
<h2 id="2-3-对非动态内存分配的空间free释放"><a href="#2-3-对非动态内存分配的空间free释放" class="headerlink" title="2.3 对非动态内存分配的空间free释放"></a>2.3 对非动态内存分配的空间free释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* p = &amp;i;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >p指向空间不是动态内存分配的空间</font></p>
<h2 id="2-4-对动态内存分配的空间的一部分free释放"><a href="#2-4-对动态内存分配的空间的一部分free释放" class="headerlink" title="2.4 对动态内存分配的空间的一部分free释放"></a>2.4 对动态内存分配的空间的一部分free释放</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p+<span class="number">5</span>);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >p+5指向空间是动态内存分配的空间的一部分</font></p>
<h2 id="2-5-对已经free的动态内存分配空间访问或再次free"><a href="#2-5-对已经free的动态内存分配空间访问或再次free" class="headerlink" title="2.5 对已经free的动态内存分配空间访问或再次free"></a>2.5 对已经free的动态内存分配空间访问或再次free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	*p = <span class="number">10</span>; <span class="comment">//对已经free的动态内存分配空间访问</span></span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//对动态内存分配空间多次free释放</span></span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-内存泄漏"><a href="#2-6-内存泄漏" class="headerlink" title="2.6 内存泄漏"></a>2.6 内存泄漏</h2><p>当申请的动态内存空间不需要时应该被释放，这样可以重新分配使用。申请的空间在使用完毕后不free释放将引起内存泄漏。<strong>内存泄漏将一点点榨干可用内存，最终导致系统崩溃</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		test();</span><br><span class="line">		<span class="comment">//业务处理,满足条件则退出while循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >当业务处理没有满足条件则while为死循环，每次循环都会申请内存空间，最终将系统崩溃</font></p>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 字符串函数</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>前言：字符串是一种重要的数据类型，但是<strong>C语言没有显式的字符串数据类型</strong>，字符串通过<strong>字符串常量</strong>或<strong>字符数组</strong>方式储存。C语言提供了许多与字符串相关函数，可以在头文件<code>&lt;string.h&gt;</code>中查看函数声明，本章将会<strong>自行编写相关字符串函数</strong></p>
<span id="more"></span>

<h1 id="一、字符串长度函数-strlen"><a href="#一、字符串长度函数-strlen" class="headerlink" title="一、字符串长度函数 strlen"></a>一、字符串长度函数 strlen</h1><p><strong>功能</strong>：字符串以 ‘\0’ 作为结束标志，strlen函数返回的是在字符串中 ‘\0’ 前面出现的字符个数（不包<br>含 ‘\0’ )<br>库函数strlen函数声明：<br><code>size_t  strlen(char const *string);</code><br>返回值 :无符号整形,返回字符串长度<br>string:字符串起始位置指针</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">	assert(<span class="built_in">string</span>); <span class="comment">//检查是否为空指针</span></span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*<span class="built_in">string</span>++ != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//首先将string解引用看是否等于&#x27;\0&#x27;,并将string指向后面一个字符地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		len++; <span class="comment">//字符串长度+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>警告：</strong><br><strong>由于strlen返回类型是size_t类型即一个无符号整数类型，无符号整数绝不可能为负。在表达式中使用无符号整数可能造成不可预料后果</strong></p>
<p><strong>例1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(<span class="built_in">string</span>); <span class="comment">//检查是否为空指针</span></span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*<span class="built_in">string</span>++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* c1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="type">char</span>* c2 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (my_strlen(c1) - my_strlen(c2) &gt;= <span class="number">0</span>) <span class="comment">//返回无符号整数，恒大于等于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;c1 &gt; c2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;c1 &lt; c2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c1 &gt; c2</span><br></pre></td></tr></table></figure>

<h1 id="二、不受限制的字符串函数"><a href="#二、不受限制的字符串函数" class="headerlink" title="二、不受限制的字符串函数"></a>二、不受限制的字符串函数</h1><p><strong>有些字符串函数是“不受限制的”，也就是说它们只是通过寻找字符串结束标志’\0’来判断字符串长度，在使用这些函数时，程序员必须保证字符串不会溢出所在内存</strong></p>
<h2 id="2-1-复制字符串函数-strcpy"><a href="#2-1-复制字符串函数-strcpy" class="headerlink" title="2.1 复制字符串函数 strcpy"></a>2.1 复制字符串函数 strcpy</h2><p><strong>功能：将源指向的字符串复制到目标指向的数组中，包括’\0’，并返回目标数组起始地址</strong><br>库函数strlcpy函数声明：<br><code>char * strcpy ( char * destination, const char * source );</code><br>返回值：返回目标数组起始地址<br>destination:目标数组起始地址<br>source：源字符串起始地址</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">my_strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	将souce指向空间存放的字符复制到destination指向空间，并将source与destination指向后一个字符位置</span></span><br><span class="line"><span class="comment">	当souce解引用是&#x27;\0&#x27;时循环停止</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//destination 与 source不能是空指针</span></span><br><span class="line">	<span class="type">char</span>* des = destination;</span><br><span class="line">	<span class="keyword">while</span> ((*destination++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>警告：</strong><br><strong>1. 如果source与destination指向空间在内存中出现重叠，结果是未定义的</strong><br><strong>2. 如果源字符串比目标数组长，多余的字符仍将复制，将会出现非法访问内存的问题</strong></p>
<h2 id="2-2-字符串连接函数-strcat"><a href="#2-2-字符串连接函数-strcat" class="headerlink" title="2.2 字符串连接函数 strcat"></a>2.2 字符串连接函数 strcat</h2><p><strong>功能：<br>将源字符串的副本追加到目标字符串尾部。目标字符串中的’\0’被源字符串的第一个字符覆盖，并且在目标字符串中由这两个字符串联而成的新字符串的末尾添加’\0’</strong><br>库函数strcat声明：<br><code>char * strcat ( char * destination, const char * source );</code><br>返回值：返回目标字符串起始地址<br>destination:目标字符串起始地址<br>source：要追加的字符串起始地址</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">my_strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//destination 与 source不能是空指针</span></span><br><span class="line">	<span class="type">char</span>* des = destination;<span class="comment">//记录目标字符串起始地址</span></span><br><span class="line">	<span class="keyword">while</span> (*destination != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//找到目标字符串&#x27;\0&#x27;位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		destination++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ( (*destination++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//开始追加复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例1：将c2字符串追加到c1字符串中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">my_strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//destination 与 source不能是空指针</span></span><br><span class="line">	<span class="type">char</span>* des = destination;<span class="comment">//记录目标字符串起始地址</span></span><br><span class="line">	<span class="keyword">while</span> (*destination != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//找到目标字符串&#x27;\0&#x27;位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		destination++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ( (*destination++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//开始追加复制</span></span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="type">char</span> c2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,my_strcat(c1, c2));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>
<p><strong>警告：</strong><br><strong>1. 如果source与destination指向空间在内存中出现重叠，结果是未定义的</strong><br><strong>2.程序员必须保证目标字符数组剩余空间能够保存整个源字符串</strong></p>
<h2 id="2-3-字符串比较函数strcmp"><a href="#2-3-字符串比较函数strcmp" class="headerlink" title="2.3 字符串比较函数strcmp"></a>2.3 字符串比较函数strcmp</h2><p><strong>功能：<br>对两个字符串的每一个对应字符逐一比较，直到发现不相等为止。标准规定：第一个字符串大于第二个字符串，则返回大于0的数字<br>。第一个字符串等于第二个字符串，则返回0。第一个字符串小于第二个字符串，则返回小于0的数字。</strong></p>
<p>库函数strcmp声明<br><code>int strcmp ( const char * str1, const char * str2 );</code><br>str1:第一个字符串起始地址<br>str2:第二个字符串起始地址</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(str1 &amp;&amp; str2);<span class="comment">//str1 与 str2不能是空指针</span></span><br><span class="line">	<span class="keyword">while</span> (*str1 == *str2) <span class="comment">//当str1与str2指向空间对应字符相等时循环继续</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*str1 == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//当str1解引用是&#x27;\0&#x27;时，两个字符串对应字符全部比较完毕，都是相等的</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *str1 - *str2; <span class="comment">//返回str1与str2对应字符相差的ASCII值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>警告：</strong><br><strong>1.初学者常常会写<code>if(strcmp(str1,str2))</code>表达式，以为两个字符串相等，它的结果将是真。但是，这个结果恰恰相反，因为两个字符串相等返回0</strong><br><strong>2.一个常见错误是以为第一个字符串大于第二个字符串返回1，小于则返回-1</strong></p>
<h1 id="三、长度受限制的字符串函数"><a href="#三、长度受限制的字符串函数" class="headerlink" title="三、长度受限制的字符串函数"></a>三、长度受限制的字符串函数</h1><p><strong>标准库包含一些受限制的函数，这些函数接受一个显式的长度参数，用于限定进行复制或比较的字符数，防止难以预料的非法访问内存</strong></p>
<h2 id="3-1-复制字符串函数-strncpy"><a href="#3-1-复制字符串函数-strncpy" class="headerlink" title="3.1  复制字符串函数 strncpy"></a>3.1  复制字符串函数 strncpy</h2><p>功能：将源字符串len个字符复制到目标字符串。如果strlen(source)小于len，destination用额外的’\0’填充到len长度。如果strlen(source)大于等于len，那么只有len个字符复制到destination中<br>库函数strncpy声明<br><code>char * strncpy ( char * destination, const char * source, size_t num )；</code><br>返回值：返回目标数组起始地址<br>destination:目标数组起始地址<br>source：源字符串起始地址<br>num:需要复制字符个数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strncpy</span><span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//destination 与 source不能是空指针</span></span><br><span class="line">	<span class="type">char</span>* des = destination;</span><br><span class="line">	<span class="keyword">while</span> (num) <span class="comment">//需要复制字符个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">if</span> ((*destination++ = *source++) != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//如果source解引用等于&#x27;\0&#x27;,代表strlen(source)小于len，需要用NULL填充到len长度</span></span><br><span class="line">			;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num) <span class="comment">//用&#x27;\0&#x27;填充到len长度</span></span><br><span class="line">	&#123;</span><br><span class="line">		num--;</span><br><span class="line">		*destination++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>警告：<br><strong>1. 如果source与destination指向空间在内存中出现重叠，结果是未定义的</strong><br><strong>2. 当strlen(source)大于等于len并且strlen(destination)&lt;&#x3D;len,destination将不会以’\0’结尾</strong></p>
<h2 id="3-2-字符串连接函数-strncat"><a href="#3-2-字符串连接函数-strncat" class="headerlink" title="3.2  字符串连接函数 strncat"></a>3.2  字符串连接函数 strncat</h2><p><strong>功能：从字符串source的开头拷贝n 个字符到destination字符串尾部，并追加’\0’字符。destination要有足够的空间来容纳要拷贝的字符串。如果n大于字符串source的长度，那么仅将src指向的字符串内容追加到dest的尾部。字符追加完成后，再追加’\0’。</strong><br>库函数strncat声明<br><code>char * strncat ( char * destination, const char * source, size_t num );</code><br>返回值：返回目标字符串起始地址<br>destination:目标字符串起始地址<br>source：要追加的字符串起始地址<br>num:要追加字符个数</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strncat</span><span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	assert(destination &amp;&amp; source);<span class="comment">//destination 与 source不能是空指针</span></span><br><span class="line">	<span class="type">char</span>* des = destination;</span><br><span class="line">	<span class="keyword">while</span>(*destination != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//找到目标字符串&#x27;\0&#x27;位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		destination++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num) <span class="comment">//需要追加字符个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">if</span> ((*destination = *source) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			destination++;</span><br><span class="line">			source++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*destination = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-比较字符串函数-strncmp"><a href="#3-3-比较字符串函数-strncmp" class="headerlink" title="3.3  比较字符串函数 strncmp"></a>3.3  比较字符串函数 strncmp</h2><p><strong>功能：比较两个字符串，但最多比较len个字节。如果两个字符串前len个字符相等返回0，str1大于str2返回大于0值，str1小于str2返回小于0的值</strong></p>
<p>库函数strncmp声明<br><code>int strncmp ( const char * str1, const char * str2, size_t num );</code><br>str1:第一个字符串起始地址<br>str2:第二个字符串起始地址<br>num:比较len个字节（字符）</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(str1 &amp;&amp; str2);<span class="comment">//str1 与 str2不能是空指针</span></span><br><span class="line">	<span class="keyword">while</span> (num--) <span class="comment">//需要比较字符个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*str1 == *str2) <span class="comment">//如果对应位置字符相等，向后一个字符继续比较</span></span><br><span class="line">		&#123;</span><br><span class="line">			str1++;</span><br><span class="line">			str2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *str1 - *str2; <span class="comment">//返回str1与str2对应字符相差的ASCII值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//前num个字符都相等返回相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、-字符串查找函数"><a href="#四、-字符串查找函数" class="headerlink" title="四、 字符串查找函数"></a>四、 字符串查找函数</h1><h2 id="4-1-查找一个子字符串函数-strstr"><a href="#4-1-查找一个子字符串函数-strstr" class="headerlink" title="4.1 查找一个子字符串函数 strstr"></a>4.1 查找一个子字符串函数 strstr</h2><p><strong>功能：<br>在str1查找整个str2第一次出现位置，并返回一个指向该位置的指针。如果str2没有完整地出现在str1的任何地方，函数返回NULL指针。如果str2是一个空字符串，函数返回str1指针</strong><br>库函数声明<br><code>const char * strstr ( const char * str1, const char * str2 );</code><br>返回值：str1中查找整个str2第一次出现位置或NULL<br>str1:需要扫描的字符串<br>str2:需要查找字符串(子串)</p>
<p>模拟实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">my_strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//找到str1中出现str2第一个字符的位置</span></span><br><span class="line">	<span class="comment">//判断相等</span></span><br><span class="line">	assert(str1 &amp;&amp; str2);<span class="comment">//str1 与 str2不能是空指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* p1 = str1; </span><br><span class="line">	<span class="keyword">if</span> (*str2 == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//当str2是空字符串返回str1</span></span><br><span class="line">		<span class="keyword">return</span> p1;</span><br><span class="line">	<span class="keyword">while</span>(*p1 != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//当p1是空字符串返回NULL，否则进入循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* p2 = str2; <span class="comment">//存放str2中需匹配的字符地址</span></span><br><span class="line">		<span class="keyword">while</span> (*p1 != *p2 &amp;&amp; *p1 != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//在str1中找到与str2第一个字符相同的字符地址，如果p1解引用等于&#x27;\0&#x27;，表示str1中没有与str2第一个字符相同的字符</span></span><br><span class="line">		&#123;</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*p1 == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* tmp = p1; </span><br><span class="line">		<span class="keyword">while</span> (*tmp == *p2 &amp;&amp; *p2 != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//检查是否与str2对应字符都相等</span></span><br><span class="line">		&#123;</span><br><span class="line">			tmp++;</span><br><span class="line">			p2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (*p2 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			<span class="keyword">return</span> p1;</span><br><span class="line">		p1++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 数组</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>数组：<strong>一组相同类型元素的集合</strong></p>
<h1 id="一、一维数组"><a href="#一、一维数组" class="headerlink" title="一、一维数组"></a>一、一维数组</h1><h2 id="1-1-一维数组的声明"><a href="#1-1-一维数组的声明" class="headerlink" title="1.1 一维数组的声明"></a>1.1 一维数组的声明</h2><p>元素类型&emsp;数组名[元素个数]<br>说明：<strong>元素个数一般为常量表达式</strong>，c99标准支持可变长数组，即元素个数可以使用变量表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]; <span class="comment">//声明一个整形数组，数组有10个元素，数组名为arr</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可变长数组</span></span><br><span class="line"><span class="comment">int n = 10;</span></span><br><span class="line"><span class="comment">int arr[n]; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="1-2-一维数组的初始化"><a href="#1-2-一维数组的初始化" class="headerlink" title="1.2 一维数组的初始化"></a>1.2 一维数组的初始化</h2><p>初始化：在数组声明时为数组赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">char</span> arr4[] = <span class="string">&quot;abc&quot;</span> <span class="comment">//等同于 arr4[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\0&#x27;&#125;;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>1.在数组声明时为数组赋值，可省略数组元素个数，此时元素个数为初始值个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//元素个数为：3</span></span><br></pre></td></tr></table></figure>
<p>2.如果初始值个数小于元素个数时，剩余数组元素值被初始化为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 等同于 int arr1[5] = &#123;1,2,3,0,0&#125;;</span></span><br></pre></td></tr></table></figure>
<p>3.只能在数组声明时为<strong>数组</strong>赋值，其他时候只能为<strong>数组元素</strong>赋值，不能为数组赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>];</span><br><span class="line">arr3 = arr2;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-引用数组元素"><a href="#1-3-引用数组元素" class="headerlink" title="1.3 引用数组元素"></a>1.3 引用数组元素</h2><p><strong>数组名[下标]</strong><br><strong>说明：</strong><br>1.数组元素通过下标来访问<br>2.数组下标从0开始，下标范围为[0,size-1]<br>3.<code>size = sizeof(arr) / sizeof(arr[0]);</code> <strong>函数内此公式不适用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组每个元素值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//size为数组元素个数</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i; <span class="comment">//对数组元素赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);<span class="comment">//打印数组元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="1-4-一维数组在内存中存储"><a href="#1-4-一维数组在内存中存储" class="headerlink" title="1.4 一维数组在内存中存储"></a>1.4 一维数组在内存中存储</h2><p><strong>一维数组在内存中是连续存放的，地址使用是从低地址到高地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 32位环境测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//size为数组元素个数</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr[i]); <span class="comment">//打印对应元素在内存中地址 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">010F</span>FD80</span><br><span class="line"><span class="number">010F</span>FD84</span><br><span class="line"><span class="number">010F</span>FD88</span><br><span class="line"><span class="number">010F</span>FD8C</span><br><span class="line"><span class="number">010F</span>FD90</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ba23c43298f24c8bd290c44d117b158.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、二维数组"><a href="#二、二维数组" class="headerlink" title="二、二维数组"></a>二、二维数组</h1><h2 id="2-1-二维数组声明"><a href="#2-1-二维数组声明" class="headerlink" title="2.1 二维数组声明"></a>2.1 二维数组声明</h2><p>元素类型&emsp;数组名[行数][列数]<br>数组元素个数&#x3D;行数*列数，<strong>在声明时行数可以省略（但必须初始化）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">2</span>]; <span class="comment">//声明一个二维数组，数组名为arr，数组有3行2列，元素个数为3*2，元素类型为int</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-二维数组的初始化"><a href="#2-2-二维数组的初始化" class="headerlink" title="2.2 二维数组的初始化"></a>2.2 二维数组的初始化</h2><p>初始化：在数组声明的时候为其赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> arr3[][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>说明：<br>1.初始值个数少于行数与列数乘积，剩余数组元素被初始化为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 等同于 int arr1[3][3] = &#123; &#123;1,2,3&#125;,&#123;0,0,0&#125;,&#123;0,0,0&#125; &#125;;</span></span><br><span class="line"><span class="comment">//或等同于 int arr1[3][3] = &#123;1,2,3,0,0,0,0,0,0&#125;;</span></span><br></pre></td></tr></table></figure>
<p>2 只能在数组声明时为<strong>数组赋值</strong>，其他时候只能为<strong>数组元素赋值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr2 = arr1;<span class="comment">//错误</span></span><br><span class="line">arr2[<span class="number">0</span>] = arr1[<span class="number">0</span>] <span class="comment">//错误</span></span><br><span class="line">arr2[<span class="number">0</span>][<span class="number">0</span>] = arr1[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-引用数组元素"><a href="#2-3-引用数组元素" class="headerlink" title="2.3 引用数组元素"></a>2.3 引用数组元素</h2><p>数组名[行下标][列下标]<br>行下标：范围为  [0,行号-1]<br>列下标：范围为  [0,列号-1]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//控制行下标</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) <span class="comment">//控制列下标</span></span><br><span class="line">		&#123;</span><br><span class="line">			arr[i][j] = flag; <span class="comment">//对数组元素赋值</span></span><br><span class="line">			flag++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//控制行下标</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) <span class="comment">//控制列下标</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;arr[%d][%d] = %d &quot;</span>, i, j, arr[i][j]); <span class="comment">//打印对应数组元素值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//打印完一行数组就换行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-二维数组在内存中存储"><a href="#2-4-二维数组在内存中存储" class="headerlink" title="2.4 二维数组在内存中存储"></a>2.4 二维数组在内存中存储</h2><p><strong>二维数组在内存中是连续存放的，地址使用是从低地址到高地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//控制行下标</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) <span class="comment">//控制列下标</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d][%d] = %p\n&quot;</span>,i,j,&amp;arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">00B</span>8FE6C</span><br><span class="line">&amp;arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">00B</span>8FE70</span><br><span class="line">&amp;arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">00B</span>8FE74</span><br><span class="line">&amp;arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">00B</span>8FE78</span><br><span class="line">&amp;arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">00B</span>8FE7C</span><br><span class="line">&amp;arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">00B</span>8FE80</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f75cf634e63f504fc6f35952607cb76.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="三、多维数组"><a href="#三、多维数组" class="headerlink" title="三、多维数组"></a>三、多维数组</h1><p>多维数组：维数大于1个称为多维数组，如：二维数组、三维数组、四位数组等</p>
<h2 id="3-1-多维数组声明"><a href="#3-1-多维数组声明" class="headerlink" title="3.1 多维数组声明"></a>3.1 多维数组声明</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>];<span class="comment">//声明1个三维数组，数组名为arr,数组为3排、4行、5列，元素个数=3*4*5,元素类型为int</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-多维数组初始化"><a href="#3-2-多维数组初始化" class="headerlink" title="3.2 多维数组初始化"></a>3.2 多维数组初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span> = &#123; &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;,&#123; &#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125; &#125; &#125;; </span><br></pre></td></tr></table></figure>
<p>说明：多维数组中，只有第一维才能根据初始化列表缺省的提供，剩余的几维必修显式地写出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[][<span class="number">2</span>][<span class="number">2</span> = &#123; &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;,&#123; &#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125; &#125; &#125;; <span class="comment">//第一维度省略不写，通过计算子数组的个数，得到第一维度为2</span></span><br></pre></td></tr></table></figure>
<h1 id="四、数组下标越界"><a href="#四、数组下标越界" class="headerlink" title="四、数组下标越界"></a>四、数组下标越界</h1><p>数组的下标是有范围的，<strong>下标范围为[0,元素个数-1</strong>],当下标不在此范围时就超出数组合法空间的访问，即数组下标越界。<strong>C语言标准并不规定数组下标越界检查</strong>，下标越界检查涉及开销比想象的多（涉及到指针指向空间是否在数组空间内），<strong>所以大部分编译器不做下标越界检查</strong></p>
<h2 id="4-1-下标越界访问"><a href="#4-1-下标越界访问" class="headerlink" title="4.1 下标越界访问"></a>4.1 下标越界访问</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, <span class="number">-1</span>, arr[<span class="number">-1</span>]); <span class="comment">//访问数组之前内存空间</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, <span class="number">5</span>, arr[<span class="number">5</span>]); <span class="comment">//访问数组之后内存空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">-1</span>] = <span class="number">-858993460</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">-858993460</span></span><br></pre></td></tr></table></figure>

<p><strong>大部分编译器对越界访问只会报警告，程序仍旧可以运行</strong></p>
<h2 id="4-2-下标越界修改"><a href="#4-2-下标越界修改" class="headerlink" title="4.2 下标越界修改"></a>4.2 下标越界修改</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	arr[<span class="number">-1</span>] = <span class="number">2</span>; <span class="comment">//修改数组之前内存空间存放的值</span></span><br><span class="line">	arr[<span class="number">5</span>] = <span class="number">3</span>; <span class="comment">//修改数组之后内存空间存放的值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>程序错误，Run-Time Check Failure #2 - Stack around the variable ‘arr’ was corrupted.</strong></p>
<p>结论：<strong>我们要自己对数组下标是否越界做检查，不要指望编译器</strong></p>
<h1 id="五、数组与指针"><a href="#五、数组与指针" class="headerlink" title="五、数组与指针"></a>五、数组与指针</h1><h2 id="5-1-数组名"><a href="#5-1-数组名" class="headerlink" title="5.1 数组名"></a>5.1 数组名</h2><h3 id="5-1-1数组名是什么"><a href="#5-1-1数组名是什么" class="headerlink" title="5.1.1数组名是什么"></a>5.1.1数组名是什么</h3><p>在C中，<strong>几乎所有使用数组名的表达式，数组名是数组首元素地址，是一个指针常量</strong></p>
<p>例1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, arr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//arr++; 此代码错误，因为arr是数组首元素地址，是一个指针常量，常量不能更改</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="number">008F</span>FE64</span><br><span class="line">&amp;arr[<span class="number">0</span>] = <span class="number">008F</span>FE64</span><br></pre></td></tr></table></figure>
<p>例2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr1[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">5</span>];</span><br><span class="line">	arr2 = arr1;<span class="comment">//此代码错误，因为arr2是arr2数组首元素地址，一个指针常量,不能被修改</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-数组名两个例外"><a href="#5-1-2-数组名两个例外" class="headerlink" title="5.1.2 数组名两个例外"></a>5.1.2 数组名两个例外</h3><p>只有在两种情况下，数组名不是数组首元素地址<br><strong>例外1：sizeof(数组名)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	在sizeof内部单独放一个数组名，数组名表示整个数组大小，int类型大小为4,元素个数为5，数组大小为20字节</span></span><br><span class="line"><span class="comment">	而不是当作一个地址大小计算（32位平台地址大小为4字节）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><strong>例外2：&amp;数组名</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr = %p\n&quot;</span>, &amp;arr); <span class="comment">// &amp;数组名，取出的是数组地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]); <span class="comment">// &amp;arr[0]，取出数组首元素地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr); <span class="comment">// 数组名表示首元素地址，取出数组首元素地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr+1 = %p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0]+1 = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr+1 = %p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;arr = <span class="number">004F</span>F924</span><br><span class="line">&amp;arr[<span class="number">0</span>] = <span class="number">004F</span>F924</span><br><span class="line">arr = <span class="number">004F</span>F924</span><br><span class="line">---------------</span><br><span class="line">&amp;arr+<span class="number">1</span> = <span class="number">004F</span>F938</span><br><span class="line">&amp;arr[<span class="number">0</span>]+<span class="number">1</span> = <span class="number">004F</span>F928</span><br><span class="line">arr+<span class="number">1</span> = <span class="number">004F</span>F928</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/8c7a7ece899982bb46c6f82f4365424c.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-2-下标引用与指针表达式"><a href="#5-2-下标引用与指针表达式" class="headerlink" title="5.2 下标引用与指针表达式"></a>5.2 下标引用与指针表达式</h2><p>我们之前访问（修改）数组元素时是使用下标引用，但我们知道数组名一般情况下就是数组首元素的地址，是一个指针常量，所以<strong>本质上下标引用是指针表达式的伪装</strong>。</p>
<p><code>array[subscript ]</code>  等同于 <code>*(array + subscript )</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;使用下标引用方式打印元素值\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>* p = arr; <span class="comment">//整形指针变量p存放arr数组首元素地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n使用指针表达式方式打印元素值\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i)); <span class="comment">// *(p+i) 等同于 *(arr+i)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用下标引用方式打印元素值</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">使用指针表达式方式打印元素值</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>当指针在表达式左边时，修改指针指向空间存放的值<br>当指针在表达式右边时，访问指针指向空间存放的值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = arr;</span><br><span class="line">	*p = <span class="number">10</span>; <span class="comment">//指针在表达式左边，修改p指向空间存放值，等同于 arr[0] = 10;</span></span><br><span class="line">	<span class="type">int</span> i = *p;  <span class="comment">//指针在表达式右边，访问p指向空间存放值，等同于 int i = arr[0]</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;arr[0] = %d\n&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p = <span class="number">10</span></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>说明：<br><strong>1.下标引用相对于指针表达式可读性更强<br>2.下标引用绝不会比指针更有效率，但指针有时会比下标引用更有效率</strong></p>
<h2 id="5-3-数组与指针区别"><a href="#5-3-数组与指针区别" class="headerlink" title="5.3 数组与指针区别"></a>5.3 数组与指针区别</h2><p><strong>数组和指针并不是相等的</strong></p>
<ol>
<li>声明一个数组时，<strong>编译器根据声明所指定的元素个数为数组分配内存空间</strong>，然后再创建数组名，它的值是一个常量，指向这片空间的起始位置。</li>
<li>声明一个指针变量时，<strong>编译器只为指针本身分配内存空间</strong>，如果指针变量是一个全局变量则默认初始化为NULL，如果是局部变量不会被初始化，存放的是一个随机地址值</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0e59efd56caa0e80fd9e8a951fe82f67.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="六、数组与函数"><a href="#六、数组与函数" class="headerlink" title="六、数组与函数"></a>六、数组与函数</h1><h2 id="6-1-一维数组传参的函数设计"><a href="#6-1-一维数组传参的函数设计" class="headerlink" title="6.1 一维数组传参的函数设计"></a>6.1 一维数组传参的函数设计</h2><p><strong>一位数组数组名是数组首元素地址</strong><br>当在一个函数内部使用外部某个一维数组时，需要将该一维数组传入函数内，我们之前一般设计为数组形式</p>
<p>例1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> arr[<span class="number">5</span>])</span> <span class="comment">//形式参数设计为数组形式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	print1(arr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2 ：<br>我们发现例1设计时，函数写死了，数组元素个数只能为5，当外部数组元素个数不是5的时候，函数需要修改,<strong>有些人会想到在函数内部通过 <code>sizeof(arr) / sizeof(arr[0])</code>求元素个数，这是一种错误设计方法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入实参arr是数组名，本质是数组首元素地址，是一个指针类型,形参应该设计为int* p,但也可以写成int arr[]</span></span><br><span class="line"><span class="comment">[]内元素个数可以不指定，因为编译器都会当作指针来处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> arr[])</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	arr是一个指针,sizeof(arr)是求指针大小，32位指针大小为4字节，64位为8字节，本机是32位环境</span></span><br><span class="line"><span class="comment">	所以sizeof(arr) = 4。</span></span><br><span class="line"><span class="comment">	sizeof(arr[0]) 由于arr[0]是int类型，所以sizeof(arr[0])等同于sizeof(int) = 4。</span></span><br><span class="line"><span class="comment">	即sizeof(arr) / sizeof(arr[0]) 等同于 4 /4 =1,即 int size = 1;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	print2(arr);<span class="comment">//传入实参</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3：<br>通过例2我们知道，如果在函数内部需要知道外部数组元素个数，可通过一个显式的参数传递给函数，指明数组元素个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span> <span class="comment">//形式参数设计为数组形式,size为数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	print3(arr,size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例4<br>我们知道一维数组的数组名为数组首元素地址，所以函数参数设计时应该用指针类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print4</span><span class="params">(<span class="type">int</span>* p,<span class="type">int</span> size)</span> <span class="comment">//形式参数设计为指针形式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	print4(arr,size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：<br>1.<strong>一维数组传参传递的是数组首元素地址，本质是指针</strong><br>2.我们推荐使用例3、例4的方式进行函数设计，尤其是例4</p>
<h2 id="6-2-二维数组传参的函数设计"><a href="#6-2-二维数组传参的函数设计" class="headerlink" title="6.2 二维数组传参的函数设计"></a>6.2 二维数组传参的函数设计</h2><p>二维数组的数组名是首元素地址，首元素是一个一维数组,即数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = arr; <span class="comment">//p存放数组arr首元素地址 </span></span><br><span class="line"><span class="comment">//  下标引用运算符优先级高于间接访问运算符，但是由于小括号存在，p首先与*匹配，即p是指针。接下来与</span></span><br><span class="line"><span class="comment">//  下标引用运算符匹配，表明p指向某种类型的数组，最后与int匹配，所以p是一个指向数组的指针，数组有10个</span></span><br><span class="line"><span class="comment">//  元素，每个元素为int类型</span></span><br></pre></td></tr></table></figure>

<p>当在一个函数内部使用外部某个二维数组时，需要将该二维数组传入函数内，我们之前一般设计为数组形式<br>例1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">2</span>])</span> <span class="comment">//数组形式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;arr[%d][%d] = %d &quot;</span>, i, j, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;</span><br><span class="line">	print1(arr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：<br>我们发现例1设计时，函数写死了，数组的行和列只能为2，其他情况函数需要修改。可通过2个显式的参数传递给函数，指明行和列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维数组的数组名是一维数组的地址，本质是一个指针，使用数组形式传参，列的大小无法省略，这一点只能写死</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> arr[][<span class="number">2</span>],<span class="type">int</span> row,<span class="type">int</span> col)</span> <span class="comment">//数组形式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;arr[%d][%d] = %d &quot;</span>, i, j, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;</span><br><span class="line">	<span class="type">int</span> row = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//算出行</span></span><br><span class="line">	<span class="type">int</span> col = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//算出列</span></span><br><span class="line">	print2(arr,row,col);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3<br>我们知道二维数组的数组名为数组首元素地址，即1个一维数组的地址，所以函数参数设计时应该用指针类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//32位环境测试</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">2</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span> <span class="comment">//指针形式</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;arr[%d][%d] = %d &quot;</span>, i, j, *(*(p+i)+j)); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125; &#125;;</span><br><span class="line">	<span class="type">int</span> row = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//算出行</span></span><br><span class="line">	<span class="type">int</span> col = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//算出列</span></span><br><span class="line">	print3(arr,row,col);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例4<br>前三种方式列的个数只能为2，在设计这个函数时候我们可能并不知道这个二维数组的行数，只有调用者最清楚该二维数组行数，由于多维数组每个元素在内存中是连续存储，我们可以将二维数组作为一个一维数组使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print4</span><span class="params">(<span class="type">int</span>* p,<span class="type">int</span> row,<span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;col;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i*row+j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="type">int</span> row = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">//算出行</span></span><br><span class="line">	<span class="type">int</span> col = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">//算出列</span></span><br><span class="line">    print4((<span class="type">int</span>*)arr,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 文件</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h1><h2 id="1-1-什么是文件"><a href="#1-1-什么是文件" class="headerlink" title="1.1 什么是文件"></a>1.1 什么是文件</h2><p>&emsp;磁盘文件在DOS管理中被定义为存贮在外部介质上的程序或数据的集合,是一批逻辑上有联系的数据。每个文件都有个文件名作为标识,每个文件在磁盘中的具体存放位置、格式都由操作系统中的文件系统管理,也就是说,操作系统是以文件为单位对程序或数据进行管理的。<br>&emsp;在C语言中文件的含义更为广泛,不仅包含以上所述的磁盘文件,还包括一切能进行输入&#x2F;输出的终端设备,它们被看成是设备文件。如键盘常称为标准输入文件,显示器称为标准输出文件。<font color=#0000FF >即在C语言中文件是由磁盘文件和设备文件组成的，磁盘文件根据功能又分为程序文件和数据文件</font></p>
<span id="more"></span>

<h2 id="1-2-文件名"><a href="#1-2-文件名" class="headerlink" title="1.2 文件名"></a>1.2 文件名</h2><p>一个文件要有一个唯一的文件标识，以便用户识别和引用，文件名包含3部分：<strong>文件路径+文件名主干+文件后缀</strong><br>例如Windows下：   c:\code\test.txt<br>Linux下： &#x2F;tmp&#x2F;file.txt    （Linux系统不识别文件后缀名，后缀名是给用户看的）</p>
<h1 id="二、-文件流的打开与关闭"><a href="#二、-文件流的打开与关闭" class="headerlink" title="二、 文件流的打开与关闭"></a>二、 文件流的打开与关闭</h1><h2 id="2-1-流"><a href="#2-1-流" class="headerlink" title="2.1 流"></a>2.1 流</h2><p><strong>流是一个高度抽象概念</strong><br>&emsp;当前计算机具有大量不同设备，很多与I&#x2F;O操作有关。如:软盘、硬盘、通信端口、视屏适配器等。每种设备具有不同的特性和操作协议，操作系统负责与这些不同设备的I&#x2F;O细节，并向程序员提供一个更为简单和统一的I&#x2F;O接口<br><strong>&emsp;C语言进一步对I&#x2F;O接口进行抽象引入流的概念。根据流的方向分为输入流和输出流。程序要输入数据只需从输入流中读入;输出数据只需向输出流中写即可。特定I&#x2F;O设备的细节对程序员是隐藏的。</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c8875e0261e2d06ea5d0962462e558e.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>说明：每个C语言程序运行时默认打开3个流，分别为标准输入流（stdin）、标准输出流（stdout）、标准错误流（stderr）。标准输入默认是键盘，标准输出默认是显示器</strong></p>
<h2 id="2-2-文件指针类型（FILE-）"><a href="#2-2-文件指针类型（FILE-）" class="headerlink" title="2.2 文件指针类型（FILE *）"></a>2.2 文件指针类型（FILE *）</h2><p>每个被使用的文件都会在内存中开辟了一个对应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。<strong>这些信息是保存在一个结构体变量中的。该结构体类型是FILE类型</strong>，在<code>&lt;stdio.h&gt;</code>中定义，<strong>我们也将这个结构体变量称为文件流</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VS2013 IDE中&lt;stdio.h&gt;头文件对FILE的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *_ptr;</span><br><span class="line">        <span class="type">int</span>   _cnt;</span><br><span class="line">        <span class="type">char</span> *_base;</span><br><span class="line">        <span class="type">int</span>   _flag;</span><br><span class="line">        <span class="type">int</span>   _file;</span><br><span class="line">        <span class="type">int</span>   _charbuf;</span><br><span class="line">        <span class="type">int</span>   _bufsiz;</span><br><span class="line">        <span class="type">char</span> *_tmpfname;</span><br><span class="line">       &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>不同的C编译器中FILE类型结构体包含的内容不完全相同，但是大同小异</strong></p>
<p><font color=#0000FF >每当打开一个文件的时候，系统会根据文件的信息自动创建一个FILE类型结构体变量，并填充其中的内容，<br>使用者不必关心细节。为了使用方便，一般都是通过一个FILE * 的指针来维护这个FILE类型结构体变量，所以FILE * 指针指向一个文件流</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* pf;<span class="comment">//文件指针变量</span></span><br></pre></td></tr></table></figure>

<p>pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量），通过该文件信息区中的信息就能够访问该文件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d9995cfef642915bae0a35f86445f318.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-文件流的打开和关闭"><a href="#2-3-文件流的打开和关闭" class="headerlink" title="2.3 文件流的打开和关闭"></a>2.3 文件流的打开和关闭</h2><p><strong>fopen函数功能：<br>打开一个指定文件，并返回一个指向该文件流（文件信息区）的FILE * 指针</strong></p>
<p>库函数fopen函数声明<br><code>FILE * fopen ( const char * filename, const char * mode );</code><br>返回值：打开文件成功返回指向该文件流（文件信息区）的FILE * 指针，打开失败返回NULL指针，<strong>所以应该检查fopen函数的返回值</strong><br>filename ：需打开文件或设备名字，可以是绝对路径或相对路径写法<br>mode：文件打开模式</p>
<p>常用模式说明：<br>r    ：以只读方式打开文件，该文件必须存在<br>w  ：以只写方式打开文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。<br>a  ：以追加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件末尾<br>b  ：打开二进制文件，配合上面r、w、a使用</p>
<p><strong>fclose函数功能：<br>刷新文件缓冲区，关闭一个指定文件（释放文件流）</strong></p>
<p>库函数fclose函数声明<br><code>int fclose ( FILE * stream );</code><br>返回值：关闭成功返回0，失败返回EOF<br>stream：指向文件流的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//以只读方式打开一个文件file.txt</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf) <span class="comment">//打开失败</span></span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fopen&quot;</span>); <span class="comment">//打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读操作</span></span><br><span class="line">	fclose(pf); <span class="comment">//关闭文件</span></span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、-顺序读写"><a href="#三、-顺序读写" class="headerlink" title="三、 顺序读写"></a>三、 顺序读写</h1><p>顺序读写：对文件的输入和输出只能按照顺序读写</p>
<h2 id="3-1-字符函数"><a href="#3-1-字符函数" class="headerlink" title="3.1 字符函数"></a>3.1 字符函数</h2><h3 id="3-1-1-字符输入-fgetc函数"><a href="#3-1-1-字符输入-fgetc函数" class="headerlink" title="3.1.1 字符输入  fgetc函数"></a>3.1.1 字符输入  fgetc函数</h3><p><strong>fgetc函数功能：<br>返回指定流的位置指示器指向的字符，然后位置指示器向前移动一个字符，简单理解就是从指定流读取1个字符</strong></p>
<p>库函数fgetc函数声明<br><code>int fgetc ( FILE * stream );</code><br>返回值：读取成功返回对应字符的ascii码值。读取到文件结束标志时，则函数返回EOF并设置流的文件结束指示符(feof)。如果发生读错误，该函数返回EOF并设置流的错误指示符(ferror)<br>stream：指向输入流（文件流、标准输入流）的指针</p>
<p>测试1：从文件中读取字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//file.txt存在，内容为hello</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, fgetc(pf)); <span class="comment">//输出读取第1个字符</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, fgetc(pf)); <span class="comment">//输出读取第2个字符</span></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br></pre></td></tr></table></figure>


<p>测试2：从标准输入中读取字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-字符输出-fputc函数"><a href="#3-1-2-字符输出-fputc函数" class="headerlink" title="3.1.2 字符输出  fputc函数"></a>3.1.2 字符输出  fputc函数</h3><p><strong>fputc函数功能：<br>将一个字符写入流并使位置指示器向前移动，即字符被写入到流的位置指示器所指示的位置，然后该位置指示器自动前进1，简单理解就是写1个字符到流中</strong></p>
<p>库函数fputc函数声明<br><code>int fputc ( int character, FILE * stream );</code><br>返回值：如果成功，则返回所写的字符。如果发生写错误，则返回EOF并设置错误指示符(ferror)。<br>character :待写入字符<br>stream：指向输出流（文件流、标准输出流）的指针</p>
<p>测试1：输出字符到文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将字符&#x27;a&#x27;  &#x27;b&#x27;  &#x27;c&#x27; 写入到文件</span></span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fputc(<span class="string">&#x27;a&#x27;</span>, pf);</span><br><span class="line">	fputc(<span class="string">&#x27;b&#x27;</span>, pf);</span><br><span class="line">	fputc(<span class="string">&#x27;c&#x27;</span>, pf);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试2：输出字符到标准输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c = fputc(<span class="string">&#x27;h&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	c = fputc(<span class="string">&#x27;e&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	c = fputc(<span class="string">&#x27;l&#x27;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>屏幕上显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hel</span><br></pre></td></tr></table></figure>

<h2 id="3-2-未格式化文本行函数"><a href="#3-2-未格式化文本行函数" class="headerlink" title="3.2 未格式化文本行函数"></a>3.2 未格式化文本行函数</h2><h3 id="3-2-1-未格式化文本行输入-fgets函数"><a href="#3-2-1-未格式化文本行输入-fgets函数" class="headerlink" title="3.2.1 未格式化文本行输入 fgets函数"></a>3.2.1 未格式化文本行输入 fgets函数</h3><p><strong>fgets函数功能：<br>从流中读取num-1个字符到字符数组str中，或者遇到换行符或文件结束符停止(以最先发生的为准)。换行符会使fgets停止读取，但函数会认为它是一个有效的字符读取到str，并添加’\0’使成为一个字符串</strong></p>
<p>库函数fgets函数声明<br><code>char * fgets ( char * str, int num, FILE * stream );</code><br>返回值：读取成功，函数返回str。如果在读取中时遇到文件结束符，返回NULL指针并设置流的文件结束指示符(feof)。  如果发生读错误，返回NULL指针则设置错误指示符(ferror)<br>str ：字符数组的数组名<br>num：最多复制num个字符到str数组<br>stream：指向输入流（文件流、标准输入流）的指针</p>
<p>测试1：从文件中读取未格式文本行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//文件file.txt内容为：Hello World</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> arr[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	fgets(arr, <span class="number">5</span>, pf); <span class="comment">//读取(5-1)个字符到arr数组,并添加&#x27;\0&#x27;到数组,即&quot;Hell&quot;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr); <span class="comment">//打印Hell</span></span><br><span class="line">	fgets(arr, <span class="number">5</span>, pf); <span class="comment">////读取(5-1)个字符到arr数组,并添加&#x27;\0&#x27;到数组,即&quot;o Wo&quot;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr); <span class="comment">//打印o Wo</span></span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello Wo</span><br></pre></td></tr></table></figure>
<p>测试2：从标准输入中读取未格式化文本行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> arr[] = <span class="string">&quot;##########&quot;</span>;</span><br><span class="line">	fgets(arr, <span class="number">6</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">abcdef</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">abcde</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-未格式化文本行输出-fputs函数"><a href="#3-2-2-未格式化文本行输出-fputs函数" class="headerlink" title="3.2.2 未格式化文本行输出 fputs函数"></a>3.2.2 未格式化文本行输出 fputs函数</h3><p><strong>fputs函数功能：<br>将str指向的字符串写入流。函数从指定的地址(str)开始复制，遇到’\0’停止。’\0’不会复制到流中</strong></p>
<p>库函数fputs函数声明<br><code>int fputs ( const char * str, FILE * stream );</code><br>返回值：如果成功，将返回一个非负值。出错时函数返回EOF并设置流的错误指示符(ferror)<br>str :需写入的字符串起始地址<br>stream：指向输出流（文件流、标准输出流）的指针</p>
<p>测试1 ：输出未格式化文本行到文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Hello World&quot;</span>, pf);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Hello WuHan&quot;</span>, pf);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开file.txt文件发现内容为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello WorldHello WuHan</span><br></pre></td></tr></table></figure>
<p>所以当要写入多行时需要在字符串中加入换行符，即  fputs(“Hello World\n”, pf);</p>
<p>测试2 ：输出未格式化文本行到标准输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> arr1[] = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">	<span class="built_in">fputs</span>(arr1, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;Hello Wuhan\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>屏幕上显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello Wuhan</span><br></pre></td></tr></table></figure>
<h2 id="3-3-格式化文本行函数"><a href="#3-3-格式化文本行函数" class="headerlink" title="3.3 格式化文本行函数"></a>3.3 格式化文本行函数</h2><h3 id="3-3-1-格式化文本行输入函数-fscanf"><a href="#3-3-1-格式化文本行输入函数-fscanf" class="headerlink" title="3.3.1 格式化文本行输入函数 fscanf"></a>3.3.1 格式化文本行输入函数 fscanf</h3><p><strong>fscanf函数功能：<br>功能与scanf一样，区别：scanf是从标准输入流读取格式化数据，fscanf从输入流读取格式化数据。<br>从流中读取数据，并根据参数格式将其存储到附加参数所指向的位置。附加的参数应该指向已经分配的变量，其类型由格式字符串中相应的格式说明符指定</strong></p>
<p>库函数fscanf声明<br><code>int fscanf ( FILE * stream, const char * format, ... );</code><br>返回值：返回参数列表中成功填充的个数。如果填充任何数据之前遇到文件结束或读错误返回EOF。读取时遇到文件结束符设置流的文件结束指示符(feof)，读取时发生错误设置流的错误指示符(ferror)<br>stream：指向输入流（文件流、标准输入流）的指针<br>format：格式化字符串<br>… :待填充变量的地址</p>
<p>测试1：从文件中读取格式文本行<br>file.txt文件内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">张三 <span class="number">18</span> 男</span><br><span class="line">李芳 <span class="number">16</span> 女</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">//创建结构体变量s1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">//创建结构体变量s2</span></span><br><span class="line">	<span class="built_in">fscanf</span>(pf, <span class="string">&quot;%s %d %s&quot;</span>, s1.name, &amp;s1.age, s1.sex); <span class="comment">//读取文件中格式化数据并填充到结构体变量中，name、sex是数组名，所以s1.name、s1.sex没有用&amp;运算符</span></span><br><span class="line">	<span class="built_in">fscanf</span>(pf, <span class="string">&quot;%s %d %s&quot;</span>, s2.name, &amp;s2.age, s2.sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s1.name, s1.age, s1.sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s2.name, s2.age, s2.sex);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span> 性别：男</span><br><span class="line">姓名：李芳 年龄：<span class="number">16</span> 性别：女</span><br></pre></td></tr></table></figure>

<p>测试2 ：输出格式化文本行到标准输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">fscanf</span>(<span class="built_in">stdin</span>, <span class="string">&quot;姓名：%s 年龄：%d 性别：%s&quot;</span>, s1.name, &amp;s1.age, s1.sex); <span class="comment">//从标准输入流读取格式化数据并填充到变量s1中</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s1.name, s1.age, s1.sex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 年龄：<span class="number">18</span> 性别：男</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 年龄：<span class="number">18</span> 性别：男</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-格式化文本行输出函数-fprintf"><a href="#3-3-2-格式化文本行输出函数-fprintf" class="headerlink" title="3.3.2 格式化文本行输出函数 fprintf"></a>3.3.2 格式化文本行输出函数 fprintf</h3><p><strong>fprintf函数功能：<br>功能与printf一样，区别：printf将格式化数据输出到标准输出流，fprintf将格式化数据输出到输出流</strong></p>
<p>库函数fprintf声明<br><code>int fprintf ( FILE * stream, const char * format, ... );</code><br>返回值：如果成功返回写入的字符总数。如果发生写错误，返回一个负数并设置流的错误指示符(ferror)<br>stream：指向输出流（文件流、标准输出流）的指针<br>format：格式化字符串<br>… :变量</p>
<p>测试1 ：输出格式化文本行到文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;小明&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123; <span class="string">&quot;李芳&quot;</span>,<span class="number">20</span>,<span class="string">&quot;女&quot;</span> &#125;;</span><br><span class="line">	<span class="built_in">fprintf</span>(pf, <span class="string">&quot;%s %d %s\n&quot;</span>, s1.name, s1.age, s1.sex);</span><br><span class="line">	<span class="built_in">fprintf</span>(pf, <span class="string">&quot;%s %d %s&quot;</span>, s2.name, s2.age, s2.sex);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>file.txt文件内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">小明 <span class="number">18</span> 男</span><br><span class="line">李芳 <span class="number">20</span> 女</span><br></pre></td></tr></table></figure>

<p>测试2 ：输出格式化文本行到标准输出流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;小明&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s1.name, s1.age, s1.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 年龄：<span class="number">18</span> 性别：男</span><br></pre></td></tr></table></figure>

<h1 id="四、随机读写"><a href="#四、随机读写" class="headerlink" title="四、随机读写"></a>四、随机读写</h1><p>随机读写：以任意顺序读写文件的不同位置，文件的读写位置是由文件信息区（文件流）中位置指示器决定。可以理解成记事本中的光标</p>
<h2 id="4-1-获取文件当前位置-ftell函数"><a href="#4-1-获取文件当前位置-ftell函数" class="headerlink" title="4.1 获取文件当前位置  ftell函数"></a>4.1 获取文件当前位置  ftell函数</h2><p><strong>ftell函数功能：<br>返回流的位置指示器的当前值(文件当前位置)</strong></p>
<p>库函数ftell声明<br><code>long int ftell ( FILE * stream );</code><br>返回值：对于二进制流，这是当前位置距离文件起始位置之间字节数。对于文本流，数值可能没有意义（因为不同系统换行符不一样，如：windwos换行符为\r\n &emsp;linux换行符为\n）。失败返回-1L<br>stream：指向流的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> position = ftell(pf); <span class="comment">//获取文件当前位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件当前位置：%d\n&quot;</span>, position);</span><br><span class="line">	fgetc(pf); <span class="comment">//读取位置指示器的字符，读完后位置指示器向前移动</span></span><br><span class="line">	position = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件当前位置：%d\n&quot;</span>, position);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">文件当前位置：<span class="number">0</span></span><br><span class="line">文件当前位置：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-改变文件当前位置-fseek函数"><a href="#4-2-改变文件当前位置-fseek函数" class="headerlink" title="4.2 改变文件当前位置 fseek函数"></a>4.2 改变文件当前位置 fseek函数</h2><p><strong>fseek函数功能：<br>将流的位置指示器(当前位置)设置为指定位置，成功调用该函数后，清除流的文件结束指示符(feof)</strong></p>
<p>库函数fseek声明<br><code>int fseek ( FILE * stream, long int offset, int origin );</code><br>返回值：如果成功返回0。否则返回非0。如果发生读或写错误，则设置流的错误指示符(ferror)。<br>stream：指向流的指针<br>offset：距origin的偏移量<br>origin：有3个值。SEEK_SET ：表示文件开头位置   SEEK_CUR ：文件当前位置 SEEK_END：文件结束位置</p>
<p>测试<br>file.txt文件内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> c = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); <span class="comment">//读取第一个字符&#x27;h&#x27;,读完后位置指示器向前移动1字符</span></span><br><span class="line">	c = fgetc(pf); <span class="comment">//读取第二个字符&#x27;e&#x27;,读完后位置指示器向前移动1字符</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c); </span><br><span class="line">	fseek(pf, <span class="number">-1</span>, SEEK_CUR); <span class="comment">//将位置指示器从当前位置向后移动1字符，即倒退1个字符，位置指示器指向字符&#x27;e&#x27;</span></span><br><span class="line">	c = fgetc(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<h2 id="4-3-设置文件当前位置为起始位置-rewind函数"><a href="#4-3-设置文件当前位置为起始位置-rewind函数" class="headerlink" title="4.3 设置文件当前位置为起始位置  rewind函数"></a>4.3 设置文件当前位置为起始位置  rewind函数</h2><p><strong>rewind函数功能：<br>将流的位置指示器(当前位置)设置为文件的起始位置，成功调用该函数后，清除流的文件结束指示符（feof）和错误指示符（ferror）</strong></p>
<p>库函数rewind声明<br><code>void rewind ( FILE * stream );</code><br>stream：指向流的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> position = ftell(pf); <span class="comment">//获取文件当前位置</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件当前位置：%d\n&quot;</span>, position);</span><br><span class="line">	fseek(pf, <span class="number">3</span>, SEEK_SET);</span><br><span class="line">	position = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件当前位置：%d\n&quot;</span>, position);</span><br><span class="line">	rewind(pf);</span><br><span class="line">	position = ftell(pf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;文件当前位置：%d\n&quot;</span>, position);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">文件当前位置：<span class="number">0</span></span><br><span class="line">文件当前位置：<span class="number">3</span></span><br><span class="line">文件当前位置：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="五、二进制读写"><a href="#五、二进制读写" class="headerlink" title="五、二进制读写"></a>五、二进制读写</h1><p>上面的顺序读写和随机读写都是对字符进行操作，在C语言中称为文本流（JAVA中称为字符流），但把数据写入到文件中效率最高的方法是用二进制写入，二进制写入可以避免在数值转换为字符串过程中所涉及的开销和精度丢失，但二进制并非人眼可以阅读。这种二进制读写在C语言称为二进制流（JAVA中称为字节流）</p>
<h2 id="5-1-二进制写-fwrite函数"><a href="#5-1-二进制写-fwrite函数" class="headerlink" title="5.1 二进制写  fwrite函数"></a>5.1 二进制写  fwrite函数</h2><p> <strong>fwrite函数功能：<br>将包含count个元素的数组从ptr指向的内存块写入到流中的当前位置，每个元素的大小为size字节</strong></p>
<p>库函数fread声明<br><code>size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</code><br>返回值：返回成功写入的元素总数。如果此数字与count值不同，则写入错误并设置流的错误指示符( ferror ) 。 如果size或count为零，则该函数返回零并且错误指示符保持不变。<br>ptr： 指向要写入的元素数组起始地址<br>size ：元素的大小（单位为字节）<br>count：元素的数量<br>stream：指向输出流（文件流、标准输出流）的指针</p>
<p>测试1：将数据以二进制方式写入到文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>); <span class="comment">//w为写模式，b为二进制</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;小明&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	fwrite(&amp;s1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, pf); <span class="comment">//将结构体变量s1起始内存地址，元素个数为1，大小为sizeof(struct student)数据写入到文件</span></span><br><span class="line">	fwrite(&amp;s2, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, pf);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试2：将数据以二进制方式写入标准输出流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="string">&quot;小明&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">	fwrite(&amp;s1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, <span class="built_in">stdout</span>);  <span class="comment">//输出到显示器上内容看不懂，因为是二进制数据</span></span><br><span class="line">	fwrite(&amp;s2, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-二进制读-fread函数"><a href="#5-2-二进制读-fread函数" class="headerlink" title="5.2 二进制读  fread函数"></a>5.2 二进制读  fread函数</h2><p> <strong>fread函数功能：<br>从流中读取count个元素，每个元素的大小为size字节，并将它们存储在ptr指定的内存块中</strong></p>
<p>库函数fread声明<br><code>size_t fread ( const void * ptr, size_t size, size_t count, FILE * stream );</code><br>返回值：返回成功读取的元素总数。如果size或count为零，则函数返回0。如果返回值与size值不同，则在读取时发生了读取错误或遇到文件结束符,在这两种情况下，设置流的错误指示符(ferror)或文件结束指示符(feof)<br>ptr： 存放读入数据的内存块地址<br>size ：元素的大小（单位为字节）<br>count：元素的个数<br>stream：指向输入流（文件流、标准输入流）的指针</p>
<p>测试：从文件读取二进制数据（<strong>该file.txt文件为5.1 测试1写入的文件</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">		<span class="type">int</span> age;</span><br><span class="line">		<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		FILE * pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">//r以只读模式打开，b 二进制</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123; <span class="number">0</span>&#125;;</span><br><span class="line">		fread(&amp;s1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, pf);</span><br><span class="line">		fread(&amp;s2, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> student), <span class="number">1</span>, pf);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s1.name, s1.age, s1.sex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d 性别：%s\n&quot;</span>, s2.name, s2.age, s2.sex);</span><br><span class="line">		fclose(pf);</span><br><span class="line">		pf = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 年龄：<span class="number">18</span> 性别：男</span><br><span class="line">姓名：张三 年龄：<span class="number">20</span> 性别：男</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
  </entry>
  <entry>
    <title>C语言 查看库函数执行失败原因</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E6%9F%A5%E7%9C%8B%E5%BA%93%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0.html</url>
    <content><![CDATA[<h1 id="一、-errno-是什么"><a href="#一、-errno-是什么" class="headerlink" title="一、 errno 是什么"></a>一、 errno 是什么</h1><p>C语言提供了许多库函数方便我们使用。<strong>当一个库函数执行失败时候，可以查看errno对应的错误信息了解库函数执行失败准确原因</strong>。<br>errno:错误代码，一个int类型变量，在<code>&lt;errno.h&gt;</code>中定义，每个错误代码值对应一个错误信息字符串，任何库函数都可以将其值修改为不同于零的某个值，通常用于指示特定类别的错误信息</p>
<p><font color=#FF0000 >注意：只有当一个库函数执行失败时，才会设置errno。当库函数成功执行时，errno的值不会被修改。这意味我们不能通过测试errno的值判断是否有错误发生，而只有库函数执行失败时检查errno的值才有意义</font></p>
<span id="more"></span>

<h1 id="二、-strerror函数"><a href="#二、-strerror函数" class="headerlink" title="二、 strerror函数"></a>二、 strerror函数</h1><p><strong>strerror函数功能：<br>打印错误代码对应的错误信息</strong></p>
<p>库函数strerror函数声明<br><code>char * strerror ( int errnum );</code><br>返回值：返回错误信息字符串的起始地址<br>errnum :错误代码值或errno</p>
<p>测试1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//打开文件,文件file.txt本身不存在，函数执行会错误返回NULL指针，并修改errno值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno)); <span class="comment">//打印errno对应错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">	fclose(pf); <span class="comment">//关闭文件</span></span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">No such file or directory</span><br></pre></td></tr></table></figure>
<p>测试2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(<span class="number">1</span>)); <span class="comment">//打印错误代码值1对应错误信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(<span class="number">2</span>)); <span class="comment">//打印错误代码值2对应错误信息</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(<span class="number">3</span>)); <span class="comment">//打印错误代码值3对应错误信息</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Operation not permitted</span><br><span class="line">No such file or directory</span><br><span class="line">No such process</span><br></pre></td></tr></table></figure>

<h1 id="三、-perror函数"><a href="#三、-perror函数" class="headerlink" title="三、 perror函数"></a>三、 perror函数</h1><p><strong>perror函数功能：<br>打印errno对应的错误信息</strong></p>
<p>库函数perror函数声明<br><code>void perror ( const char * str );</code><br>str : 当str不是NULL指针并且指向一个非空的字符串，perror函数先打印这个字符串，后面跟一个冒号和一个空格，然后打印errno对应的错误信息</p>
<p>测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* pf = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//打开文件,文件file.txt本身不存在，函数执行会错误返回NULL指针，并修改errno值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pf)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="literal">NULL</span>); <span class="comment">//直接打印errno对应错误信息</span></span><br><span class="line">		perror(<span class="string">&quot;fopen&quot;</span>); <span class="comment">//首先打印fopen字符串，然后打印errno对应错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;打开文件成功\n&quot;</span>);</span><br><span class="line">	fclose(pf); <span class="comment">//关闭文件</span></span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">No such file or directory</span><br><span class="line">fopen: No such file or directory</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>errno</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 程序的编译、链接、执行</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E6%89%A7%E8%A1%8C.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、-程序的环境"><a href="#一、-程序的环境" class="headerlink" title="一、 程序的环境"></a>一、 程序的环境</h1><p>&emsp;<strong>在ANSI C的任何一种实现中，存在两种不同环境</strong>。<strong>第1种是翻译环境</strong>，在这个环境中源代码文件被转换为可执行的机器指令（二进制代码）。<strong>第2种是执行环境（运行环境）</strong>，它用于实际执行代码。<strong>标准规定，这两种环境可以不在同一台计算机上</strong>，即可以在计算机A中编译程序，在计算机B中执行程序。</p>
<span id="more"></span>

<p><strong>对于这两种环境按步骤细节有两种划分方式</strong></p>
<h2 id="1-1-方式一"><a href="#1-1-方式一" class="headerlink" title="1.1 方式一"></a>1.1 方式一</h2><p><strong>方式一将翻译环境按步骤细分为编译、链接两步，运行环境不变</strong>。这就是我们常说的程序的编译、链接、执行三步骤</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/a84da0601e436c7b0c55a157e6f632e1.png" alt="在这里插入图片描述"></p>
<h2 id="1-2-方式二"><a href="#1-2-方式二" class="headerlink" title="1.2 方式二"></a>1.2 方式二</h2><p><strong>方式二将翻译环境按步骤细分为编译、链接两步，编译又细分为预编译、编译、汇编，执行环境不变</strong>。即：预编译、编译、汇编、链接、执行五步骤</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b52f105ed2bd6478e461e77c4bfda9c7.png" alt="在这里插入图片描述"><br><font color=#0000FF >说明：方式一与方式二没有本质区别，方式二相对于方式一步骤划分更加细节，下文中以方式二详细介绍每个步骤所做的事情</font></p>
<h2 id="1-3-函数库"><a href="#1-3-函数库" class="headerlink" title="1.3 函数库"></a>1.3 函数库</h2><p>在链接阶段，会将目标文件和函数库一起链接，这里的函数库指的是在源文件中用到C语言提供的各种库函数，这些函数存放在函数库中，在链接时候需要与目标文件一起链接</p>
<h2 id="1-4-文件后缀名约定"><a href="#1-4-文件后缀名约定" class="headerlink" title="1.4 文件后缀名约定"></a>1.4 文件后缀名约定</h2><p>C语言标准没有对文件后缀名进行规定，但在大多环境下有一套约定的文件后缀名<br><code>.h为后缀名的文件为C语言头文件</code><br>  <code>.c为后缀名的文件为C语言源代码文件</code><br><code>.i为后缀名的文件，是预编译后的C语言文件</code><br><code>.s为后缀名的文件，是编译过后的汇编代码文件</code><br><code>.o为后缀名的文件，是汇编后的目标文件（机器指令文件也称为二进制指令文件）。windows系统中目标文件以.obj为后缀名</code><br><code>.out为后缀名的文件，是多个目标文件与函数库链接之后的可执行程序。windows系统中以.exe为后缀名</code></p>
<h1 id="二、翻译环境"><a href="#二、翻译环境" class="headerlink" title="二、翻译环境"></a>二、翻译环境</h1><p>windows系统下的大多数IDE对于预编译、编译、汇编、链接实现细节进行了隐藏，<strong>为了观察细节，环境使用Linux系统下GCC编译器</strong></p>
<h2 id="2-1-预编译（预处理）"><a href="#2-1-预编译（预处理）" class="headerlink" title="2.1 预编译（预处理）"></a>2.1 预编译（预处理）</h2><p>预编译的详细过程可以查看这篇博客：<code>https://blog.csdn.net/kjl167/article/details/124218564</code><br>预编译：将源代码文件(.c)进行预编译处理生成预编译文件(.i)<br>功能：</p>
<ol>
<li>执行预处理指令，如： #include 、#define </li>
<li>删除所有注释</li>
</ol>
<p><code>gcc -E 源文件 -o 预处理文件名</code><br>-E :预编译阶段结束后停止，将预编译后的数据输出到标准输出<br>-o :将输出到标准输出上的内容输出到指定文件</p>
<p>测试1：#include，将所包含的头文件引入<br><img src="https://i-blog.csdnimg.cn/blog_migrate/305450fc7c76b48207e5780309ab5788.png" alt="在这里插入图片描述"><br>由于<code>&lt;stdio.h&gt;</code>头文件内容太多，所以自定义<code>&lt;add.h&gt;</code>头文件测试</p>
<p>测试2：#define ,标识符常量替换<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5abffe1d9ba3e8ed34674d065c87e1c3.png#pic_center" alt="在这里插入图片描述"></p>
<p>测试3：会删除源文件的注释<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dd5f761d9e73a60e5614bf19641fee74.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h2><p>编译：将预编译后的文件编译为汇编代码<br>功能：</p>
<ol>
<li>语法分析</li>
<li>词法分析</li>
<li>语义分析</li>
<li>符号汇总（汇总全局符号，如全局变量、函数名）</li>
</ol>
<p><code>gcc -S 预处理文件（或源文件） -o 编译文件名</code><br>-S :编译阶段结束后停止，将编译后的数据输出到标准输出<br>-o :将输出到标准输出上的内容输出到指定文件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d6ae571da56c38d7ec29003d429c32f2.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h2><p>汇编：把汇编代码转换为机器指令（二进制指令）的目标文件<br>该机器指令文件为elf格式，可用<code>readelf</code>命令查看内容<br>功能：</p>
<ol>
<li>形成符号表<br><code>gcc -c  编译后文件(或源文件)</code><br>-c :进行汇编<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6c5127a56ce604ecc33732f2c343c6ea.png#pic_center" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/1cefb5f52a09b77ff99ef9efdac42917.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h2><p>可执行程序（机器指令）为elf格式，可用<code>readelf</code>命令查看内容<br>链接：将多个目标文件和函数库链接为可执行程序<br>功能：</p>
<ol>
<li>合并段表</li>
<li>符号表的合并和重定位</li>
</ol>
<p><code>gcc  多个目标文件(或源文件) -o  链接后可执行程序名</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/9dc5e8b3cd60a4036896a8cdfa2e181c.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="三、-执行环境"><a href="#三、-执行环境" class="headerlink" title="三、 执行环境"></a>三、 执行环境</h1><ol>
<li>程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成</li>
<li>调用main函数运行</li>
<li>开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。</li>
<li>终止程序，可以是正常终止main函数；也有可能是运行错误终止</li>
</ol>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
  </entry>
  <entry>
    <title>C语言 结构体与位段</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E4%BD%8D%E6%AE%B5.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h1><h2 id="1-1-结构体是什么"><a href="#1-1-结构体是什么" class="headerlink" title="1.1 结构体是什么"></a>1.1 结构体是什么</h2><p>&emsp;在之前C语言学习中我们接触了整形类型、浮点型类型、指针类型、数组类型等，但是我们发现要描述一个复杂对象的时候，如描述一个人，需要有姓名、身高、年龄、体重等属性，并且每个属性可能是不一样的数据类型。我们发现之前学习的数据类型都无法满足。学过面向对象编程语言的肯定会想到通过定义对象来实现，在C语言中我们通过结构体来实现上述功能。<br><strong>结构体：一些值的集合，这些值称为它的成员，但结构体的各个成员可以具有不一样的数据类型</strong></p>
<p><strong>注意</strong>：结构体的各个成员可能具有不一样的数据类型，即各个成员占内存大小是不一定相同的，因此<strong>无法通过下标进行访问</strong>。相反，每个成员都有自己名字，它们是<strong>通过名字访问的</strong></p>
<span id="more"></span>

<h2 id="1-2-结构体声明"><a href="#1-2-结构体声明" class="headerlink" title="1.2 结构体声明"></a>1.2 结构体声明</h2><p>语法：<br>struct&emsp;<strong>tag</strong><br>{<br>&emsp;<strong>member-list;</strong><br>}<strong>variable-list;</strong><br>tag :可选，结构体标签名<br>member-list:成员列表，成员由数据类型与成员名组成<br>variable-list：可选，结构体变量列表<br><code>结构体类型：struct关键字+tag</code><br>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体为struct person类型，有4个成员变量，分别为姓名、身高、年龄、体重</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;; <span class="comment">//注意一定要;结尾</span></span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >注意：结构体声明并不占用内存空间，只有结构体变量定义时才会跟它分配内存空间，结构体声明相当于画图纸，结构体定义相当于照着图纸做房子</font></p>
<p>小技巧：<br><font color=#008000 >如果一个结构体类型在多个源文件中需要使用，可以把结构体类型放在头文件中，如果源文件需要用到这个结构体，可以使用<code>#include</code>指令把头文件包含进来</font></p>
<h2 id="1-3-结构体的特殊声明"><a href="#1-3-结构体的特殊声明" class="headerlink" title="1.3 结构体的特殊声明"></a>1.3 结构体的特殊声明</h2><p>例一：<br>在声明时并定义结构体变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;s1; <span class="comment">//在声明结构体类型时，并定义全局结构体变量s1</span></span><br></pre></td></tr></table></figure>
<p>例二：<br>在声明时并定义结构体数组及结构体指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;arr[<span class="number">5</span>],*p; <span class="comment">//在声明结构体类型时，并定义结构体数组arr,arr有5个元素，每个元素类型为struct person.并定义结构体指针p</span></span><br></pre></td></tr></table></figure>
<p>例三：<br>声明匿名结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> //没有写<span class="title">tag</span>,结构体类型由<span class="keyword">struct</span>关键字+<span class="title">tag</span>组成，除了声明时能创建结构体变量外，其他地方不能创建结构体变量，因为无法写结构体类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;s1; <span class="comment">//定义全局结构体变量s1</span></span><br></pre></td></tr></table></figure>
<p>例四：<br>结构体类型重定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //类型重定义，<span class="title">person</span>现在是结构体类型名而不是结构体变量</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-结构体的成员"><a href="#1-4-结构体的成员" class="headerlink" title="1.4 结构体的成员"></a>1.4 结构体的成员</h2><p>在之前结构体声明例子中，只使用了简单类型的结构体成员，但结构体成员类型可以是：数组、指针甚至是其他结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> ch[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> //结构体类型<span class="keyword">struct</span> <span class="title">B</span>中有4个成员，分别是浮点数、整形指针、整形数组、一个结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span>* p;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-结构体变量的定义和初始化"><a href="#1-5-结构体变量的定义和初始化" class="headerlink" title="1.5 结构体变量的定义和初始化"></a>1.5 结构体变量的定义和初始化</h2><p>结构体变量的定义可以在结构体声明时定义，也可以在其他位置定义，<strong>它们的区别在于结构体变量是全局变量还是局部变量</strong><br><strong>结构体变量定义后，内存会根据结构体类型大小跟它分配空间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;s1; <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s2</span>;</span> <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s3</span>;</span> <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化：<strong>在结构体变量定义时对其赋值</strong>。一个位于一对花括号内部，由逗号分隔的初始值列表，这些值根据结构体成员顺序写出。如果初始列表的值不够，剩余结构体成员被赋值为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> weight;</span><br><span class="line">&#125;s1 = &#123;<span class="string">&quot;小明&quot;</span>,<span class="number">1.78</span>,<span class="number">20</span>,<span class="number">100</span>&#125;; <span class="comment">//定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s2</span> =</span> &#123;<span class="string">&quot;小红&quot;</span>,<span class="number">1</span>,<span class="number">62</span>,<span class="number">18</span>,<span class="number">90</span>&#125;; <span class="comment">//定义并初始化</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-结构体的自引用"><a href="#1-6-结构体的自引用" class="headerlink" title="1.6 结构体的自引用"></a>1.6 结构体的自引用</h2><p><font color=#FF0000 >警告：在一个结构体内部包含一个类型为该结构体本身的成员是非法的</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种结构体自引用是非法的，成员a是另一个完整结构体，其内部还将包含它自己的成员吧，这第二个成员又是另一个完整结构体，它还将包含自己成员a，这样无限套娃下去，没有任何意义。</p>
<p><strong>在一个结构体内部包含一个类型为该结构体指针类型的成员是合法的。因为指针大小是确认的，32位为4字节（64位8字节）。高级数据结构如链表、树都是这种自引用实现的</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> * <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font color=#FF0000 >警告：警惕下面这种声明陷阱</font><br>这个声明的目的是创建一个类型名为A的结构体，但是它失败了。类型名直到声明的末尾才定义，所以在结构声明的内部它尚未定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	A * a; <span class="comment">//此时A没有定义 </span></span><br><span class="line">&#125;A;</span><br></pre></td></tr></table></figure>
<p><strong>正确声明</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_TAG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A_TAG</span> * <span class="title">a</span>;</span> </span><br><span class="line">&#125;A;</span><br></pre></td></tr></table></figure>
<h2 id="1-7-结构体成员访问"><a href="#1-7-结构体成员访问" class="headerlink" title="1.7 结构体成员访问"></a>1.7 结构体成员访问</h2><h3 id="1-7-1-结构体成员直接访问（通过结构体变量实现）"><a href="#1-7-1-结构体成员直接访问（通过结构体变量实现）" class="headerlink" title="1.7.1  结构体成员直接访问（通过结构体变量实现）"></a>1.7.1  结构体成员直接访问（通过结构体变量实现）</h3><p><strong>结构体变量</strong>的成员可以通过<strong>点运算符</strong>访问。点运算符接受两个操作数；左操作数是<strong>结构体变量</strong>的名字，右操作数是需要访问的<strong>成员名字</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;小明&quot;</span>,<span class="number">1.78f</span>,<span class="number">20</span>,<span class="number">100</span>&#125;; <span class="comment">//定义并初始化结构体变量s1</span></span><br><span class="line">	<span class="comment">//直接访问，通过.运算符，左操作数是结构体变量s1，右操作数是成员名</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, s1.name, s1.height, s1.age, s1.weight);</span><br><span class="line">	s1.age = <span class="number">18</span>;</span><br><span class="line">	s1.height = <span class="number">1.80f</span>;</span><br><span class="line">	s1.weight = <span class="number">120</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, s1.name, s1.height, s1.age, s1.weight);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 身高：<span class="number">1.78</span> 年龄：<span class="number">20</span> 体重：<span class="number">100</span></span><br><span class="line">姓名：小明 身高：<span class="number">1.80</span> 年龄：<span class="number">18</span> 体重：<span class="number">120</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-2-结构体成员间接访问（通过结构体指针变量实现）"><a href="#1-7-2-结构体成员间接访问（通过结构体指针变量实现）" class="headerlink" title="1.7.2  结构体成员间接访问（通过结构体指针变量实现）"></a>1.7.2  结构体成员间接访问（通过结构体指针变量实现）</h3><p>当拥有一个指向<strong>结构体变量的指针</strong>，可以通过对指针解引用间接访问结构体变量，并通过点运算符访问它的成员。由于<strong>点运算符优先级高于间接访问运算符</strong>，所以要在<strong>表达式中使用括号</strong>，确保间接访问运算符先执行。<font color=#008000 >但是这种访问方式比较繁琐，不推荐</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;小明&quot;</span>,<span class="number">1.78f</span>,<span class="number">20</span>,<span class="number">100</span>&#125;; <span class="comment">//定义并初始化结构体变量s1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span> =</span> &amp;s1; <span class="comment">//声明结构体指针变量p并指向结构体变量s1的地址</span></span><br><span class="line">	<span class="comment">//(*p)获取结构体变量s1，并通过点运算符访问成员</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, (*p).name, (*p).height, (*p).age, (*p).weight);</span><br><span class="line">	(*p).age = <span class="number">18</span>;</span><br><span class="line">	(*p).height = <span class="number">1.80f</span>;</span><br><span class="line">	(*p).weight = <span class="number">120</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, (*p).name, (*p).height, (*p).age, (*p).weight);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 身高：<span class="number">1.78</span> 年龄：<span class="number">20</span> 体重：<span class="number">100</span></span><br><span class="line">姓名：小明 身高：<span class="number">1.80</span> 年龄：<span class="number">18</span> 体重：<span class="number">120</span></span><br></pre></td></tr></table></figure>


<p>当拥有一个指向<strong>结构体变量的指针</strong>，可以通过<strong>箭头运算符</strong>访问它指向的结构体变量的成员,，<font color=#008000 >这种是推荐访问方式</font>。箭头运算符接受两个操作数，<strong>左操作数必须是一个结构体指针</strong>，箭头运算符对左操作数执行间接访问取得指针指向结构体变量，然后和点运算符一样，<strong>右操作数是一个结构体成员名</strong>。本质上箭头运算符《&#x3D;》间接访问运算符+点运算符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">float</span> height;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;小明&quot;</span>,<span class="number">1.78f</span>,<span class="number">20</span>,<span class="number">100</span>&#125;; <span class="comment">//定义并初始化结构体变量s1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">person</span> * <span class="title">p</span> =</span> &amp;s1; <span class="comment">//声明结构体指针变量p并指向结构体变量s1的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, p-&gt;name, p-&gt;height, p-&gt;age, p-&gt;weight);</span><br><span class="line">	p-&gt;age = <span class="number">18</span>; <span class="comment">//首先对p解引用找到指向结构体变量并通过箭头运算符内置的点运算符访问成员名</span></span><br><span class="line">	p-&gt;height = <span class="number">1.80f</span>;</span><br><span class="line">	p-&gt;weight = <span class="number">120</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, p-&gt;name, p-&gt;height, p-&gt;age, p-&gt;weight);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：小明 身高：<span class="number">1.78</span> 年龄：<span class="number">20</span> 体重：<span class="number">100</span></span><br><span class="line">姓名：小明 身高：<span class="number">1.80</span> 年龄：<span class="number">18</span> 体重：<span class="number">120</span></span><br></pre></td></tr></table></figure>
<h2 id="1-8-结构体传参"><a href="#1-8-结构体传参" class="headerlink" title="1.8 结构体传参"></a>1.8 结构体传参</h2><h3 id="1-8-1-传递结构体变量"><a href="#1-8-1-传递结构体变量" class="headerlink" title="1.8.1 传递结构体变量"></a>1.8.1 传递结构体变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> person s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, s.name, s.height, s.age, s.weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当使用传值调用时，结构体变量的一份副本做为参数传递给函数，当这个结构体变量比较大时，会有时间和空间上较大开销</strong></p>
<h3 id="1-8-2-传递结构体指针"><a href="#1-8-2-传递结构体指针" class="headerlink" title="1.8.2 传递结构体指针"></a>1.8.2 传递结构体指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> person * p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 身高：%.2f 年龄：%d 体重：%d\n&quot;</span>, p-&gt;name, p-&gt;height, p-&gt;age, p-&gt;weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这次传递给函数的是一个指向结构体的指针，指针大小比结构体变量小的多，所以开销较小。向函数传递结构体指针的缺陷在于函数可以修改指向的结构体变量，如果不希望如此，函数形参应该用const关键字来防止被修改，如：<code>const struct person  * p</code></strong></p>
<p><font color=#008000 ><strong>说明</strong>：对于结构体传参我们推荐使用传递结构体指针方式，只有当结构体变量大小小于指针时，使用传递结构体变量效率更高，但这种情况非常少见</font></p>
<h2 id="1-9-结构体大小（内存对齐）"><a href="#1-9-结构体大小（内存对齐）" class="headerlink" title="1.9 结构体大小（内存对齐）"></a>1.9 结构体大小（内存对齐）</h2><p>当问你<code>struct A</code>类型结构体大小时，你可以会脱口而出是6个字节，因为char类型为1字节，int类型为4字节。但其实<strong>结果是12字节</strong>。你可能会很诧异，但你学习了结构体内存对齐规则后就不感到意外了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="1-9-1-结构体内存对齐"><a href="#1-9-1-结构体内存对齐" class="headerlink" title="1.9.1 结构体内存对齐"></a>1.9.1 结构体内存对齐</h3><p><font color=#008000 >偏移量：当前地址距离结构体变量内存起始地址相差的字节数</font></p>
<p><strong>结构体内存对齐规则：</strong><br><strong>1. 结构体第一个成员存放在偏移量为0的地址处。<br>2. 其他成员存放在偏移量为对齐数的整数倍的地址处。</strong><br><font color=#008000 >对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值</font><br><strong>3. 结构体总大小为最大对齐数（每个成员有一个对齐数）的整数倍<br>4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整<br>体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍</strong></p>
<p><strong>例1</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/e83ac008572c6346d7ddddd6d83680c8.png#pic_center" alt="在这里插入图片描述"><br><font color=#FF0000 >测试环境编译器默认对齐数为8</font></p>
<p><strong>根据对齐规则1</strong>：c1是结构体的第一个成员，所以存放在偏移量0位置，并且c1是char类型所以占1字节<br><strong>根据对齐规则2</strong>：编译器默认对齐数为8，int类型大小为4，所以对齐数为4，即成员i存放在偏移量为4的倍数地址处，并且i是int类型所以占4字节<br><strong>根据对齐规则2</strong>：编译器默认对齐数为8，char大小类型为1，所以对齐数为1，即成员c2存放在偏移量为1的倍数地址处，并且c2是char类型所以占1字节<br>当前结构体已占9字节大小，<strong>根据对齐规则3</strong>：结构体总大小为最大对齐数（即i的对齐数4）的整数倍，所以还要用3个字节大小空间，即<strong>结构体struct A类型大小为12字节</strong></p>
<p>例2<br><img src="https://i-blog.csdnimg.cn/blog_migrate/97292b455c0ce1c376d1f739e5bd60ea.png#pic_center" alt="在这里插入图片描述"><br><font color=#FF0000 >测试环境编译器默认对齐数为8</font></p>
<p><strong>根据对齐规则1</strong>：d是结构体的第一个成员，所以存放在偏移量0位置，并且d是double类型所以占8字节<br><strong>根据对齐规则2</strong>：编译器默认对齐数为8，char类型大小为1，所以对齐数为1，即成员c存放在偏移量为1的倍数地址处，并且c是char类型所以占1字节<br><strong>根据对齐规则2</strong>：编译器默认对齐数为8，int类型大小为4，所以对齐数为4，即成员i存放在偏移量为4的倍数地址处，并且i是int类型所以占4字节<br>当前结构体已占16字节大小，<strong>根据对齐规则3</strong>：结构体总大小为最大对齐数（即d的对齐数8）的整数倍，所以<strong>结构体struct B类型大小为16字节</strong></p>
<p>例3<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d8bb2084e7ab43bbb3210f7951688fc5.png#pic_center" alt="在这里插入图片描述"></p>
<p><font color=#FF0000 >测试环境编译器默认对齐数为8</font></p>
<p><strong>根据对齐规则1</strong>：d是struct B 结构体的第一个成员，所以存放在偏移量0位置，并且d是float类型所以占4字节<br><strong>根据对齐规则4</strong>：a一个结构体变量，a中c成员的对齐数为1，a中i成员对齐数为8。所以结构体变量a最大对齐数为8，所以存放在偏移量为8的倍数地址处，并且a是struct A结构体类型所以占16字节<br>当前结构体struct B 已占24字节大小，<strong>根据对齐规则3</strong>：结构体总大小为最大对齐数（即成员a中的成员i的对齐数8）的整数倍，所以<strong>结构体struct B类型大小为24字节</strong></p>
<h3 id="1-9-2-为什么需要结构体内存对齐"><a href="#1-9-2-为什么需要结构体内存对齐" class="headerlink" title="1.9.2 为什么需要结构体内存对齐"></a>1.9.2 为什么需要结构体内存对齐</h3><p><strong>1. 性能原因</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/a84c1b6af077be1afbdd252f5bc8c1e6.png" alt="在这里插入图片描述"><br>&emsp;尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以2字节,4字节,8字节,16字节甚至32字节为单位来存取内存，当一个处理器以4字节存取int类型变量，该处理器只能从地址为4的倍数的内存开始读取数据。<br>假如没有内存对齐机制，数据可以在任意地址处存放，现在一个int变量假设从内存地址1处开始存放，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作。现在有了内存对齐的，int类型只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p><strong>2. 移植原因</strong><br>&emsp;不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。比如一个硬件只能访问内存地址为4的倍数处地址，不使用内存对齐有些数据访问不到<br><font color=#008000 >结构体的内存对齐是拿空间来换取时间的做法</font></p>
<h3 id="1-9-3-设计结构体时节省空间小技巧"><a href="#1-9-3-设计结构体时节省空间小技巧" class="headerlink" title="1.9.3 设计结构体时节省空间小技巧"></a>1.9.3 设计结构体时节省空间小技巧</h3><p>在设计结构体的时候，我们既要满足对齐，又要节省空间，<strong>让占用空间小的成员尽量集中在结构体内的前面</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A：%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;B：%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> B));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A：<span class="number">12</span></span><br><span class="line">B：<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看到结构体类型struct A与struct B内的成员一模一样，但是struct B中将成员大小较小的c1、c2放在前面，较大的i放在后面就省下4字节大小</p>
<h3 id="1-9-4-修改编译器默认对齐数"><a href="#1-9-4-修改编译器默认对齐数" class="headerlink" title="1.9.4 修改编译器默认对齐数"></a>1.9.4 修改编译器默认对齐数</h3><p><strong>虽然使用1.9.3的小技巧可以节省空间，但由于结构体内存对齐或多或少会浪费一些空间，我们可以通过修改编译器默认对齐数方式继续节省空间</strong><br><strong>可以使用<code>#pragma pack()</code>预处理指令更改编译器默认对齐数</strong><br>说明：<br><code>#pragma pack()</code> 使用编译器的默认对齐数<br><code>#pragma pack(value)</code>将编译器默认对齐数改为value</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1) <span class="comment">//将编译器默认对齐数设置为1</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">//将编译器的对齐数从1恢复到默认值</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> A)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>因为struct A变量在内存分配空间时，<strong>默认对齐数设置为1，所以不存在为了对齐而浪费空间情况</strong>，此时struct A大小为6字节</p>
<h3 id="1-9-5-查看成员在结构体中的偏移量-offsetof"><a href="#1-9-5-查看成员在结构体中的偏移量-offsetof" class="headerlink" title="1.9.5 查看成员在结构体中的偏移量 offsetof"></a>1.9.5 查看成员在结构体中的偏移量 offsetof</h3><p>虽然通过结构体内存对齐规则可以手动计算出一个成员在结构体中的偏移量，但是非常麻烦。C语言标准提供了一个宏 <code>offsetof</code>用于计算一个成员在结构体的偏移量，需要引用头文件<code>stddef.h</code><br><strong>功能：<br>该宏以函数形式返回成员在结构体或联合类型中的字节偏移值。返回的值是size_t类型的无符号整型值，包含指定成员与其结构体开头之间的字节数</strong><br><strong>offsetof (type,member)</strong><br>type :<strong>结构体类型，不能是结构体变量</strong><br>member :成员名<br>返回值：返回成员在结构体（或联合体）中的偏移量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;成员 c1 在结构体中偏移量为: %u\n&quot;</span>, offsetof(<span class="keyword">struct</span> A, c1));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;成员 i 在结构体中偏移量为: %u\n&quot;</span>, offsetof(<span class="keyword">struct</span> A, i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;成员 c2 在结构体中偏移量为: %u\n&quot;</span>, offsetof(<span class="keyword">struct</span> A, c2));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成员 c1 在结构体中偏移量为: <span class="number">0</span></span><br><span class="line">成员 i 在结构体中偏移量为: <span class="number">4</span></span><br><span class="line">成员 c2 在结构体中偏移量为: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h1 id="二、位段"><a href="#二、位段" class="headerlink" title="二、位段"></a>二、位段</h1><h2 id="2-1-什么是位段"><a href="#2-1-什么是位段" class="headerlink" title="2.1 什么是位段"></a>2.1 什么是位段</h2><p>&emsp;<strong>信息的存取一般以字节为单位。实际上，有时存储一个信息不必用一个或多个字节，例如，“真”或“假”用0或1表示，只需1位（二进制位，1 bit大小）即可。但是C语言数据类型最小的char类型也有1字节大小，剩余的7位被浪费掉了。C语言允许在一个结构体中以位为单位来指定其成员所占内存大小，这种以位为单位的成员称为“位段”或称“位域”( bit field) 。利用位段能够用较少的位数存储数据。</strong></p>
<p><font color=#008000 >位段优点：</font><br><strong>1. 可以节省储存数据的空间，当一个成员可以用1 位（bit）存取时就不需要用char类型（1 字节）储存<br>2. 位段可以很方便访问一个整形值的部分内容，而避免使用移位运算符实现</strong></p>
<h2 id="2-2-位段声明"><a href="#2-2-位段声明" class="headerlink" title="2.2 位段声明"></a>2.2 位段声明</h2><p>位段的声明和结构体是类似的，但有两个不同：<br>1.位段的成员必须是 int、unsigned int 或signed int、char<br>2.位段的成员名后边有一个冒号和一个数字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> a:<span class="number">3</span>;</span><br><span class="line"> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line"> <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line"> <span class="type">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-位段的内存分配"><a href="#2-3-位段的内存分配" class="headerlink" title="2.3 位段的内存分配"></a>2.3 位段的内存分配</h2><ol>
<li>位段的空间是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的</li>
<li>位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。</li>
<li>当一个字节包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，编译器舍弃剩余的位还是利用，标准尚未定义</li>
</ol>
<p><font color=#008000 >本例中编译器是从左向右分配。当一个字节包含两个位段，第2个位段成员比较大，无法容纳于第一个位段剩余的位时，此字节剩余位舍弃，开辟1个新的字节存放第2个位段</font></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/217d46eefa25c30a36af873d4a14caf9.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-4-位段的移植性（跨平台）"><a href="#2-4-位段的移植性（跨平台）" class="headerlink" title="2.4 位段的移植性（跨平台）"></a>2.4 位段的移植性（跨平台）</h2><ol>
<li><code>int</code> 位段被当成有符号数还是无符号数是不确定的，需要显著声明为<code>signed int</code>或<code>unsigned int</code></li>
<li>位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。</li>
<li>位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义</li>
<li>当一个字节包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，编译器舍弃剩余的位还是利用，标准尚未定义</li>
</ol>
<p><font color=#008000 >相对于结构体，位段可以达到同样的效果，并且可以节省空间，但是由于C语言标准对于位段具体实现细节没有定义，所以不同编译器实现可能有所不同，所以不具有移植性</font></p>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>位段</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 运算符</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E8%BF%90%E7%AE%97%E7%AC%A6.html</url>
    <content><![CDATA[<h1 id="一、算数运算符"><a href="#一、算数运算符" class="headerlink" title="一、算数运算符"></a>一、算数运算符</h1><p>算数运算符有： <strong>+&emsp;  - &emsp;  *  &emsp; &#x2F;  &emsp; %</strong> 五种。由于运算符有两个操作数。也被称为双目运算符</p>
<p><strong>对于 &#x2F; 运算符，两个操作数都是整数执行的是整数除法。至少有一个操作数是浮点时执行浮点除法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">double</span> i = <span class="number">5.0</span> / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2.500000</span></span><br></pre></td></tr></table></figure>

<p><strong>%运算符的两个操作数必须为整数，返回的是整除后的余数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">20</span> % <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>对于 a &#x2F; b  ，运算符两个操作数有一个是负数时。如果左操作数是负数，结果为：-((-a) &#x2F; b)。如果右操作数是负数,结果为：-(a &#x2F; (-b))</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-7</span> / <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">5</span> / <span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-7 / 3 = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5 / -2 = %d\n&quot;</span>, j);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-7</span> / <span class="number">3</span> = <span class="number">-2</span></span><br><span class="line"><span class="number">5</span> / <span class="number">-2</span> = <span class="number">-2</span></span><br></pre></td></tr></table></figure>
<p><strong>对于 a % b  ，运算符两个操作数有一个是负数时。如果左操作数是负数，结果为：-((-a) % b)。如果右操作数是负数,结果为：a % (-b)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-7</span> % <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">5</span> % <span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-7 %% 2 = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5 %% -2 = %d\n&quot;</span>, j);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-7</span> % <span class="number">2</span> = <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> % <span class="number">-2</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="二、移位运算符"><a href="#二、移位运算符" class="headerlink" title="二、移位运算符"></a>二、移位运算符</h1><p>前言：整数在内存中<strong>存储的是二进制</strong>。存储有符号整数时将二进制最高位设定为符号位，<strong>1表示负数，0表示正数</strong>。一个整数二进制表示形式有原码、反码、补码。<strong>正整数的原码、反码、补码都相同</strong>。<strong>负整数的原码、反码、补码需要计算</strong>。<strong>使用、打印整数时使用原码，计算时使用补码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//正整数的原码、反码、补码都相同</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001010</span>  <span class="comment">//10的原码</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001010</span>  <span class="comment">//10的反码</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00001010</span>  <span class="comment">//10的补码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span> </span><br><span class="line"><span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span>  <span class="comment">//-1的原码,即将-1化为二进制，最高位用1表示负数</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111110</span> <span class="comment">//-1的反码，符号位不变，原码其他位按位取反</span></span><br><span class="line"><span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="comment">//-1的补码，反码+1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-1左移运算符"><a href="#2-1左移运算符" class="headerlink" title="2.1左移运算符  &lt;&lt;"></a>2.1左移运算符  &lt;&lt;</h2><p>语法： 数字 &lt;&lt; n<br><strong>对数字的补码向左边移动n位,即左边抛弃，右边补0</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001001   原码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001001   反码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001001   补码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00100100  对补码左移2位，右边补2个0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000001   -1原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111110   -1反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111111   -1补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100  对补码左移2位，右边补2个0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111011 反码，对上面补码-1</span></span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000100 原码，对反码符号位不变，其他位按位取反</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-4</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-右移运算符"><a href="#2-2-右移运算符" class="headerlink" title="2.2 右移运算符  &gt;&gt;"></a>2.2 右移运算符  &gt;&gt;</h2><p>语法：数字 &gt;&gt; n<br><strong>对数字的补码右移n位，即右边抛弃，左边填充</strong><br>根据填充规则分为两种：<strong>逻辑移位与算数移位</strong><br>逻辑移位：左边用0填充<br>算数移位：左边用该数字符号位填充<br><strong>标准规定：无符号类型的所有移位操作都是逻辑移位。对于有符号类型采用逻辑移位还是算数移位由编译器决定，大部分编译器采用算数移位，下面的演示环境采用的是算数移位。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-1</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000001   -1原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111110   -1反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111111   -1补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111111  对补码右移动2位，左边全部补符号位1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算后结果还是-1的补码，所以还原成原码不再写</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i =<span class="number">10</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010   10原码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010   10反码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010   10补码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00000010  对补码右移动2位，左边全部补符号位0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>对于移位运算符，不要移动负数位，这个是C语言标准未定义的</strong><br>如 int i &#x3D; 10 &gt;&gt; -1 ;</p>
<h1 id="三、位运算符"><a href="#三、位运算符" class="headerlink" title="三、位运算符"></a>三、位运算符</h1><p>位运算符有：按位与 &amp;  按位或 |  按位异或 ^ 三种</p>
<h2 id="3-1-按位与"><a href="#3-1-按位与" class="headerlink" title="3.1 按位与 &amp;"></a>3.1 按位与 &amp;</h2><p>语法： num1 &amp; num2<br><strong>将两个数的补码计算出来，两个数对应的二进位都为1时，结果为1，否则为0</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span> &amp; <span class="number">-3</span>;</span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010   10 的原码、反码、补码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000011    -3 的原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100    -3 的反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101  -3 的补码</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010  10补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101  -3 补码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001000  对应二进制位都为1，结果为1，否则为0 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-按位或"><a href="#3-2-按位或" class="headerlink" title="3.2 按位或 |"></a>3.2 按位或 |</h2><p>语法： num1 | num2<br><strong>将两个数的补码计算出来，两个数对应的二进位至少有1个为1时，结果为1，否则为0</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-4</span> | <span class="number">-3</span>;</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000100   -4 的原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111011   -4 的反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100   -4 的补码</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000011    -3 的原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100    -3 的反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101  -3 的补码</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100   -4补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101   -3 补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101  对应二进制位至少1个为1时，结果为1，否则为0 （此结果为补码）</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100  反码，补码-1</span></span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000011  原码，反码符号位不变，其他位按位取反</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-3</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-按位异或"><a href="#3-3-按位异或" class="headerlink" title="3.3 按位异或 ^"></a>3.3 按位异或 ^</h2><p>语法： num1 ^ num2<br><strong>将两个数的补码计算出来，两个数对应的二进位相同时，结果为0，否则为1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">-4</span> ^ <span class="number">-3</span>;</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000100   -4 的原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111011   -4 的反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100   -4 的补码</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00000011    -3 的原码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100    -3 的反码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101  -3 的补码</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111100   -4补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11111101   -3 补码</span></span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00000001  对应二进制位相同时，结果为0，否则为1 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4-经典笔试题"><a href="#3-4-经典笔试题" class="headerlink" title="3.4 经典笔试题"></a>3.4 经典笔试题</h2><p>题目：有两个整数类型变量a、b，不创建临时变量交换a与b的值</p>
<p>方法一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//当两个数相加和大于int类型时，存在溢出，此方法就不能使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换前 a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">	a = a + b; </span><br><span class="line">	b = a - b;</span><br><span class="line">	a = a - b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换后 a = %d b = %d\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">交换前 a = <span class="number">10</span> b = <span class="number">20</span></span><br><span class="line">交换后 a = <span class="number">20</span> b = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">//此方法只适用两个整数之间交换</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换前 a = %d b = %d\n&quot;</span>,a,b);</span><br><span class="line">	a = a ^ b;</span><br><span class="line">	b = a ^ b;</span><br><span class="line">	a = a ^ b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;交换前 a = %d b = %d\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">交换前 a = <span class="number">10</span> b = <span class="number">20</span></span><br><span class="line">交换前 a = <span class="number">20</span> b = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="四、赋值运算符"><a href="#四、赋值运算符" class="headerlink" title="四、赋值运算符 &#x3D;"></a>四、赋值运算符 &#x3D;</h1><p>将赋值运算符右侧的值赋给左侧的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;stdio.h》</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	a = <span class="number">30</span>; <span class="comment">//使用赋值运算符将30赋给变量i</span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	z = y = x+<span class="number">1</span>; <span class="comment">//连续赋值 等同于 y = x+1; z=y;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复合赋值运算符： +&#x3D;&emsp;  -&#x3D; &emsp;*&#x3D;&emsp; &#x2F;&#x3D; &emsp;%&#x3D; &emsp;&gt;&gt;&#x3D; &emsp;&lt;&lt;&#x3D;&emsp; &amp;&#x3D;&emsp; |&#x3D; &emsp;^&#x3D;</p>
<p>等同于将复合赋值运算符左侧的变量与右侧的值通过运算符计算得到的结果赋值给左侧变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	i += <span class="number">30</span> ;  <span class="comment">// 等同于 i = i + 30;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<h1 id="五、单目运算符"><a href="#五、单目运算符" class="headerlink" title="五、单目运算符"></a>五、单目运算符</h1><h2 id="5-1-逻辑非运算符"><a href="#5-1-逻辑非运算符" class="headerlink" title="5.1  逻辑非运算符 !"></a>5.1  逻辑非运算符 !</h2><p>在c语言中，0为假，非0为真。 逻辑非运算符逆转逻辑状态，<br>!真  -&gt; 假 &emsp; !假 -&gt;真</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;!i = %d\n&quot;</span>,!i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;!j = %d\n&quot;</span>, !j);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!i = <span class="number">0</span></span><br><span class="line">!j = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!i)  <span class="comment">//当i为假时候输出哈哈哈</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;哈哈哈\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">哈哈哈</span><br></pre></td></tr></table></figure>
<h2 id="5-2-取地址运算符-与-间接寻址运算符"><a href="#5-2-取地址运算符-与-间接寻址运算符" class="headerlink" title="5.2  取地址运算符 &amp;  与 间接寻址运算符 *"></a>5.2  取地址运算符 &amp;  与 间接寻址运算符 *</h2><p>&amp;变量名  : 取出变量在内存的地址   &emsp; * 指针变量  ：访问指针变量存储的地址所对应内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* p = &amp;i;<span class="comment">//取出i在内存中地址并存储在指针变量p中，这里 * 代表指针类型</span></span><br><span class="line">	*p = <span class="number">20</span>;  <span class="comment">//通过指针p间接访问变量i的内存空间，并修改i的值为20，这里* 代表间接寻址访问，即找到指针存储的地址对应的空间</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-sizeof-运算符"><a href="#5-3-sizeof-运算符" class="headerlink" title="5.3  sizeof 运算符"></a>5.3  sizeof 运算符</h2><p>sizeof是运算符而不是一个函数，求变量(类型)所占内存空间大小，单位为字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i所占空间大小为:%d\n&quot;</span>, <span class="keyword">sizeof</span>(i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int类型所占空间大小为:%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i所占空间大小为:%d\n&quot;</span>, <span class="keyword">sizeof</span> i); <span class="comment">//这里 sizeof 求i的大小没有使用（），可以说明sizeof不是一个函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i所占空间大小为:<span class="number">4</span></span><br><span class="line"><span class="type">int</span>类型所占空间大小为:<span class="number">4</span></span><br><span class="line">i所占空间大小为:<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-取反运算符"><a href="#5-4-取反运算符" class="headerlink" title="5.4 取反运算符 ~"></a>5.4 取反运算符 ~</h2><p> 取反运算符 ：  对一个数的二进制位(补码)取反 。 1变0，0变1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = ~<span class="number">10</span>;</span><br><span class="line">	<span class="comment">//00000000 00000000 00000000 00001010  10的原码、反码、补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11110101  按位取反后的补码</span></span><br><span class="line">	<span class="comment">//11111111 11111111 11111111 11110100  反码</span></span><br><span class="line">	<span class="comment">//10000000 00000000 00000000 00001011  原码</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-11</span></span><br></pre></td></tr></table></figure>
<h2 id="5-5-自增运算符-自减运算符"><a href="#5-5-自增运算符-自减运算符" class="headerlink" title="5.5 自增运算符 ++ 自减运算符- -"></a>5.5 自增运算符 ++ 自减运算符- -</h2><p>自增运算符分为前置++与后置++两种<br>前置++  即先自增，后使用<br>后置++ 即先使用，后自增</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> j = ++i; <span class="comment">//i先自增+1,此时i=11，将11赋值给j</span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> y = x++; <span class="comment">//先将x赋值给y,此时y=10,然后x自增+1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;y = %d\n&quot;</span>, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">11</span></span><br><span class="line">j = <span class="number">11</span></span><br><span class="line">x = <span class="number">11</span></span><br><span class="line">y = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>自减运算符分为前置- -与后置- -两种<br>前置- -  即先自减，后使用<br>后置- - 即先使用，后自减</p>
<h2 id="5-6-强制类型转换运算符"><a href="#5-6-强制类型转换运算符" class="headerlink" title="5.6 强制类型转换运算符 ( )"></a>5.6 强制类型转换运算符 ( )</h2><p>强制类型转换是把变量从一种类型转换为另一种数据类型<br>语法：(type_name) expression</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = (<span class="type">int</span>)<span class="number">3.14</span>; <span class="comment">//将3.14这个double类型强制转换为int类型,小数位会被丢弃</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h1 id="六、关系运算符"><a href="#六、关系运算符" class="headerlink" title="六、关系运算符"></a>六、关系运算符</h1><p>关系运算符包括： &gt;&emsp;&gt;&#x3D;&emsp;&lt;&emsp;&lt;&#x3D;&emsp;!&#x3D;&emsp;&#x3D;&#x3D;<br><strong>注意： 赋值运算符是 &#x3D;  ， 判断两数是否相等使用 &#x3D;&#x3D;</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">if</span> (i == j)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不相等\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">不相等</span><br></pre></td></tr></table></figure>
<h1 id="七、逻辑运算符"><a href="#七、逻辑运算符" class="headerlink" title="七、逻辑运算符"></a>七、逻辑运算符</h1><h2 id="7-1-逻辑与运算符"><a href="#7-1-逻辑与运算符" class="headerlink" title="7.1 逻辑与运算符 &amp;&amp;"></a>7.1 逻辑与运算符 &amp;&amp;</h2><p>如果&amp;&amp;左右两边表达式都为真，则结果为真，否则为假。<strong>当左边表达式为假，右边表达式不会进行判断执行</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">if</span> (age &gt; <span class="number">12</span> &amp;&amp; age &lt; <span class="number">18</span>) <span class="comment">//只有age大于12且小于18时才会执行</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;青少年\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">青少年</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> c = i++ &amp;&amp; j++; <span class="comment">//i++是后置++，所以&amp;&amp;左边表达式为假，则右边表达式不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d j = %d c = %d\n&quot;</span>,i,j,c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span> j = <span class="number">1</span> c = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="7-2-逻辑或运算符"><a href="#7-2-逻辑或运算符" class="headerlink" title="7.2 逻辑或运算符 ||"></a>7.2 逻辑或运算符 ||</h2><p>如果||左右两边表达式至少有一个为真，则结果为真，否则为假。<strong>当左边表达式为真，右边表达式不会进行判断执行</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> weight = <span class="number">80</span>; </span><br><span class="line">	<span class="keyword">if</span>(weight &lt; <span class="number">90</span> || weight &gt; <span class="number">130</span>) <span class="comment">//当weight小于90或者大于130则执行</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;体重不健康\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">体重不健康</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> z = i++ || j++; <span class="comment">//i是后置++,此时i为1，左侧表达式为真，则右边表达式不会执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d j = %d z = %d\n&quot;</span>, i, j, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">2</span> j = <span class="number">2</span> z = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="八、条件运算符（三目运算符）"><a href="#八、条件运算符（三目运算符）" class="headerlink" title="八、条件运算符（三目运算符）"></a>八、条件运算符（三目运算符）</h1><p>语法：  <strong>条件 ? X :  Y</strong><br>当条件为真时，值为X，否则为Y</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> max = x &gt; y ? x : y;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x与y的较大值为：%d\n&quot;</span>, max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x与y的较大值为：<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h1 id="九、逗号运算符"><a href="#九、逗号运算符" class="headerlink" title="九、逗号运算符"></a>九、逗号运算符</h1><p>逗号运算符：从左向右依次执行。整个表达式的结果是最后一个表达式的结果<br>语法： (exp1, exp2, exp3, …expN)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> x = (<span class="number">10</span>, i++,<span class="number">30</span>);<span class="comment">//括号内多个表达式从左到右依次执行，但最终结果只跟最后一个表达式有关，即 x = 30</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<h1 id="十、下标引用运算符-与-函数调用运算符"><a href="#十、下标引用运算符-与-函数调用运算符" class="headerlink" title="十、下标引用运算符 [ ]  与 函数调用运算符 ( )"></a>十、下标引用运算符 [ ]  与 函数调用运算符 ( )</h1><h2 id="10-1-下标引用运算符"><a href="#10-1-下标引用运算符" class="headerlink" title="10.1 下标引用运算符 [ ]"></a>10.1 下标引用运算符 [ ]</h2><p>需要引用数组某个元素时：   数组名[下标]<br>数组下标从0开始，所以数组最后一个元素下标为数组元素个数-1<br> 下标引用运算符 [ ]  有两个操作数，一个是数组名，一个是下标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[<span class="number">3</span>]); <span class="comment">//通过下标引用运算符引用arr数组的第4个元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">3</span>[arr]); <span class="comment">// [ ]是运算符，所以操作数可以交换位置，类似 a + b  等同于 b + a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="10-2-函数调用运算符"><a href="#10-2-函数调用运算符" class="headerlink" title="10.2 函数调用运算符 ( )"></a>10.2 函数调用运算符 ( )</h2><p>语法：  函数名（参数）<br>接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;哈哈哈\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">char</span>* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    print1(); <span class="comment">//使用函数调用运算符，有1个参数print1</span></span><br><span class="line">    print2(<span class="string">&quot;hello&quot;</span>);<span class="comment">//使用函数调用运算符，有2个参数print1、&quot;hello“</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">哈哈哈</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h1 id="十一、引用结构体（联合体）成员运算符"><a href="#十一、引用结构体（联合体）成员运算符" class="headerlink" title="十一、引用结构体（联合体）成员运算符"></a>十一、引用结构体（联合体）成员运算符</h1><p><strong>引用结构体（联合体）成员运算符有两个，一个是点运算符 . &emsp; 一个是箭头运算符 -&gt;</strong><br>语法：<br><strong>结构体变量.成员名<br>结构体指针变量-&gt;成员名</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> person p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s  年龄：%d  性别：%s\n&quot;</span>, p.name, p.age, p.sex); <span class="comment">//使用点运算符访问结构体变量的成员,运算符左侧为结构体变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> person* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s  年龄：%d  性别：%s\n&quot;</span>, p-&gt;name, p-&gt;age, p-&gt;sex); <span class="comment">//使用箭头运算符访问结构体变量的成员,运算符左侧为结构体指针变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">p</span> =</span> &#123; <span class="string">&quot;康小龙&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">    print1(p);</span><br><span class="line">    print2(&amp;p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">姓名：康小龙  年龄：<span class="number">18</span>  性别：男</span><br><span class="line">姓名：康小龙  年龄：<span class="number">18</span>  性别：男</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 预编译详解</title>
    <url>/C%E8%AF%AD%E8%A8%80-%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<p><strong>&emsp;编译C程序涉及很多步骤，第1个步骤就是预编译（预处理）阶段，预编译是在源代码编译之前做一些文本性质的操作。包括删除注释、执行预处理指令。为了观察预编译阶段所做的事，环境使用Linux系统下的GCC编译器</strong><br> 程序编译完整步骤可以查看这篇博客：<code>https://blog.csdn.net/kjl167/article/details/124157077</code></p>
<h1 id="一、-预定义符号"><a href="#一、-预定义符号" class="headerlink" title="一、 预定义符号"></a>一、 预定义符号</h1><p>ANSI C定义了一些预定义符号，它们表示不同含义<br><code>__FILE__   :进行编译的源文件名</code><br><code>__LINE__   :文件当前行号</code><br><code>__DATE__   :文件被编译日期</code><br><code>__TIME__   :文件被编译时间</code><br><code>__STDC__   :如果编译器遵循ANSI C 其值为1，否则未定义</code></p>
<span id="more"></span>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5b5cd3c3d20a3303b6be2d30cc77c1b2.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、-define-宏定义"><a href="#二、-define-宏定义" class="headerlink" title="二、 #define 宏定义"></a>二、 #define 宏定义</h1><p>#define是 C语言 和 C++ 中的一个预处理指令，其中的“#”表示这是一条预处理命令·。凡是以“#”开头的均为预处理命令，“define”为宏定义命令。建议将宏定义在文件最开始位置。</p>
<p><font color=red >在 C++ 中，宏不受命名空间的影响，因为宏在预处理阶段，而命名空间是在编译阶段。</font></p>
<p>下面这个C++代码会编译失败，因为对<code>MAX</code>重复定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> kjl</span><br><span class="line">&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> MAX 10	  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kxl</span><br><span class="line">&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> MAX 20	  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-1-定义不带参数的宏"><a href="#2-1-定义不带参数的宏" class="headerlink" title="2.1 定义不带参数的宏"></a>2.1 定义不带参数的宏</h2><p>用法：<br><code>#define 标识符（宏名） 对应值</code><br>作用：在预编译时，将标识符替换为对应值，对应值可以是任何文本内容<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int_t int   <span class="comment">//对关键字int起了一个别名，注意int_t不是类型,只是会替换为int  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_forever for(;;) <span class="comment">//用do_forever描述了一个无限for循环</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3780755682302ec1af02ee6d9e5653d.png#pic_center" alt="在这里插入图片描述"></p>
<p>注意：<font color=#FF0000 >不应该在宏定义的尾部加上分号</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例一</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10;</span></span><br><span class="line"><span class="type">int</span> x = MAX;   <span class="comment">//预编译后替换为： int x = 10;;  可以发现第二个;表示一条空语句，这种场景不会出错</span></span><br><span class="line"></span><br><span class="line">例二 </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10;</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(y &gt;= <span class="number">10</span>)</span><br><span class="line">	x = MAX;     <span class="comment">//预编译后替换为：  x = 10;;   if没有加&#123; &#125;，后面不能跟两条语句,出错</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/bc6600afb8e95fed8a57e682575b17ac.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-2-定义带参数宏"><a href="#2-2-定义带参数宏" class="headerlink" title="2.2 定义带参数宏"></a>2.2 定义带参数宏</h2><p>用法：<br><code>#define name(parameter-list) stuff</code><br>作用：在预编译时，将传入参数列表中参数替换到宏体中对应参数执行某些操作<br>name :宏名<br>parameter-list：参数列表<br>stuff:宏体<br><strong>注意：参数列表的左括号必须与name紧邻，如果两者之间有任何空白存在，参数列表和宏体会被当作不带参数的宏中的替换值</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/f50092a917e8c9cc29a62b6cec65fa15.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-2-1-宏的一些问题"><a href="#2-2-1-宏的一些问题" class="headerlink" title="2.2.1 宏的一些问题"></a>2.2.1 宏的一些问题</h3><p>测试1：当传入参数中有表达式<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fa2d9e94d98a88b3c72524ddcee3792d.png#pic_center" alt="在这里插入图片描述"><br>改进：将宏体中参数用小括号包裹起来<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a6e3b80bed7c9d28ad7328f9cda8c7e8.png#pic_center" alt="在这里插入图片描述"></p>
<p>测试2：当表达式旁边还有其他运算符</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2c52ec377d31bc57a51cbfbe99ec89ed.png#pic_center" alt="在这里插入图片描述"><br>改进：将宏体用小括号包裹起来<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0ddb7e6545608f3dccc227cfbda80051.png#pic_center" alt="在这里插入图片描述"><br><strong>结论：所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中<br>的运算符或邻近运算符之间因为运算符优先级不同产生不可预料的相互作用。</strong></p>
<h3 id="2-2-2-小技巧"><a href="#2-2-2-小技巧" class="headerlink" title="2.2.2 小技巧"></a>2.2.2 小技巧</h3><p>C语言支持：<strong>相邻字符串常量自动连接成一个字符串</strong><br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span><span class="string">&quot;World\n&quot;</span>); <span class="comment">//等同于printf(&quot;Hello World\n&quot;); </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p><strong>我们可以将字符串常量作为宏参数，打印指定数据类型值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(FORMAT,VALUE) printf(<span class="string">&quot;The value is &quot;</span> FORMAT <span class="string">&quot;\n&quot;</span>,VALUE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PRINT(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>); <span class="comment">// 即 printf(&quot;The value is &quot; &quot;%d&quot; &quot;\n&quot;,10);</span></span><br><span class="line">	PRINT(<span class="string">&quot;%lf&quot;</span>, <span class="number">5.55</span>); <span class="comment">//即 printf(&quot;The value is &quot; &quot;%lf&quot; &quot;\n&quot;,5.55);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The value is <span class="number">10</span></span><br><span class="line">The value is <span class="number">5.550000</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-宏的替换规则"><a href="#2-3-宏的替换规则" class="headerlink" title="2.3 宏的替换规则"></a>2.3 宏的替换规则</h2><p>在程序中使用宏时，需要涉及几个步骤。</p>
<ol>
<li>在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义。如果是，它们首先被替换。</li>
<li>替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。</li>
<li>最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLE(X) ((X) + (X))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用宏首先对参数检查，由于参数MAX是#define定义，所以被替换即：  int n = DOUBLE(100);</span></span><br><span class="line"><span class="comment">    再将DOUBLE(100)替换即:  int n = ((100) + (100));</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="type">int</span> n = DOUBLE(MAX); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>宏参数和#define 定义中可以包含其他#define定义的宏。但是宏不能出现递归。</li>
<li>当预处理器搜索#define定义的宏时候，字符串常量的内容并不被搜索。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X) ((X) &gt; NUM ? (X):NUM)  <span class="comment">//宏中可以包含其他宏，但是不能包含本身 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = MAX(<span class="number">10</span>);  <span class="comment">//替换为： int n = ((10) &gt; 100 ? (10):100);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NUM = %d\n&quot;</span>,NUM); <span class="comment">//替换为： printf(&quot;NUM = %d\n&quot;,100);   字符串中NUM没有被替换</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-1-作用"><a href="#2-3-1-作用" class="headerlink" title="2.3.1 # 作用"></a>2.3.1 # 作用</h3><p><code># :在宏中，#可以将宏参数名（不是参数值）转换为一个字符串 </code><br>#x  替换为： “x”<br>#y 替换为： “y”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(FORMAT,VALUE) printf(<span class="string">&quot;The value of &quot;</span> #VALUE  <span class="string">&quot; is &quot;</span> FORMAT <span class="string">&quot;\n&quot;</span>,VALUE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="number">1.23</span>;</span><br><span class="line">	PRINT(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// 即预编译替换为 printf(&quot;The value of “ &quot;x“ &quot; is &quot; &quot;%d&quot; &quot;\n&quot;,x); </span></span><br><span class="line">	PRINT(<span class="string">&quot;%lf&quot;</span>, d); <span class="comment">//即预编译替换为 printf(&quot;The value of &quot; “d” &quot; is &quot; &quot;%lf&quot; &quot;\n&quot;,d);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The value of x is <span class="number">10</span></span><br><span class="line">The value of d is <span class="number">1.230000</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-作用"><a href="#2-3-2-作用" class="headerlink" title="2.3.2 ## 作用"></a>2.3.2 ## 作用</h3><p><code>## ：在宏中， ##可以把自己两边的符号连接成一个符号</code><br>p##f  替换为: pf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOIN(X,Y) X##Y</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i = JOIN(re,sult); <span class="comment">// JOIN(re,sult) -&gt; re##sult 即 int i = result; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-带副作用的宏参数"><a href="#2-4-带副作用的宏参数" class="headerlink" title="2.4 带副作用的宏参数"></a>2.4 带副作用的宏参数</h2><p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x+<span class="number">1</span> <span class="comment">//不带副作用</span></span><br><span class="line">x++ <span class="comment">//具有副作用，增加了x的值，当这个表达式下次执行时，产生一个不同的结果</span></span><br></pre></td></tr></table></figure>
<p>MAX宏可以证明具有副作用的参数所引起的问题，观察下面代码，你认为它将打印什么</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y)) </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> z = MAX(x++,y++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d z=%d\n&quot;</span>,x,y,z);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x=<span class="number">6</span> y=<span class="number">10</span> z=<span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">说明：  MAX(x++,y++) 预编译替换为： ((x++) &gt; (y++) &gt; (x++) : (y++)) , x++和y++都是后缀++所以先比较后++,</span><br><span class="line">所以x=<span class="number">5</span> y=<span class="number">8</span> 条件表达式为假(比较后x=<span class="number">6</span>,y=<span class="number">9</span>)，执行y++,由于是后置++所以先返回<span class="number">9</span>，然后y=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-宏与函数区别"><a href="#2-5-宏与函数区别" class="headerlink" title="2.5 宏与函数区别"></a>2.5 宏与函数区别</h2><p>宏常用于执行简单的计算，比如在两个表达式（数）中寻找其中较大（较小）一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y)) </span></span><br></pre></td></tr></table></figure>
<p>相较于函数完成这个功能，宏有2个优势：</p>
<ol>
<li>用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比函数在程序的规模和速度方面更胜一筹</li>
<li>更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型以及其他任何可以用&gt;运算符来比较的类型，<strong>即宏是类型无关的</strong></li>
</ol>
<p><strong>有些任务函数不能完成，函数参数无法是类型，而宏的参数可以出现类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(n,type) ((type *)malloc((n) * sizeof(type)))  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p = MALLOC(<span class="number">25</span>,<span class="type">int</span>);  <span class="comment">// 替换为 int * p = ((int *)malloc((25) * sizeof(int)));  </span></span><br><span class="line"><span class="type">char</span> * p = MALLOC(<span class="number">10</span>,<span class="type">char</span>);  <span class="comment">// 替换为 char * p = ((char *)malloc((25) * sizeof(char)));  </span></span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/942fb48221a1a687d08d7f2f161286ac.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-6-宏的命名约定"><a href="#2-6-宏的命名约定" class="headerlink" title="2.6 宏的命名约定"></a>2.6 宏的命名约定</h2><p>#define宏的行为和函数相比存在一些不同的地方，上文做了总结。由于这些不同之处，因此让程序员知道一个标识符究竟是宏还是一个函数非常重要。不幸的是，使用函数或宏的语法是完全一样的，所以语法本身并不能帮助你区分这两者</p>
<p><code>一个常见的约定是把宏名字全部大写</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y)) </span></span><br><span class="line"></span><br><span class="line">value = MAX(a,b); <span class="comment">//命名约定可以使MAX身份一清二楚</span></span><br></pre></td></tr></table></figure>
<h2 id="2-7-define-与-typedef区别"><a href="#2-7-define-与-typedef区别" class="headerlink" title="2.7 #define 与 typedef区别"></a>2.7 #define 与 typedef区别</h2><p><code>C语言支持用typedef关键字对各种数据类型定义新名字</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">int_t</span>;  <span class="comment">//int_t是一个类型</span></span><br><span class="line"><span class="type">int_t</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>有的人喜欢使用#define方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int_t int  <span class="comment">//这里int_t只是符号，不是类型，在预编译后会被替换</span></span></span><br><span class="line"><span class="type">int_t</span> i = <span class="number">10</span>;<span class="comment">//预编译后即 int i = 10; </span></span><br></pre></td></tr></table></figure>
<p><strong>强烈不推荐使用#define方式，因为它不能正确处理指针类型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * int_p;</span><br><span class="line">int_p x,y; <span class="comment">//这里x、y都是int*指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int_p int *</span></span><br><span class="line">int_p x,y; <span class="comment">//预编译替换为：int * x,y;   这里x为int*指针类型，而y为int类型</span></span><br></pre></td></tr></table></figure>



<h1 id="三、-undef"><a href="#三、-undef" class="headerlink" title="三、 #undef"></a>三、 #undef</h1><p>宏的作用域从定义位置开始，到文件结束。<strong>可以使用#undef移除一个宏定义</strong><br>用法：<br><code>#undef 宏名</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/ce60046f80966f0524740724c7a7976d.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="四、命令行定义"><a href="#四、命令行定义" class="headerlink" title="四、命令行定义"></a>四、命令行定义</h1><p>许多C编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。当根据同一个源文件要编译一个程序的不同版本的时候，这个特性很有用。假定某个程序中声明了一个某个长度的数组，如果机器内存有限，这个数组必须很小，但是另外一个内存充沛机器上，数组能够大些。如果数组是用类似下面的形式进行声明“</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[ARRAY_SIZE];</span><br></pre></td></tr></table></figure>
<p>在GCC编译器下可以使用 <code>-D name=stuff</code>,将name的值定义为stuff<br><img src="https://i-blog.csdnimg.cn/blog_migrate/14cd197b01c8e1db7fe1fd266eb21a7a.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="五、-条件编译"><a href="#五、-条件编译" class="headerlink" title="五、 条件编译"></a>五、 条件编译</h1><p>&emsp;在编译一个程序的时候，选定或忽略源文件中某条语句（某组语句）是很常见的。只用于调试程序的语句就是一个很明显的例子。它们不应该出现在程序的产品版本中，但我们可能并不想把这些语句从源代码中删除，因为在需要一些维护性修改时，可能需要重新调试这个程序，此时还需要这些语句，条件编译可以实现这个目的。</p>
<p><strong>条件编译：满足条件编译某些代码，不满足条件不编译某些代码</strong></p>
<h2 id="5-1-if-emsp-endif"><a href="#5-1-if-emsp-endif" class="headerlink" title="5.1 #if&emsp;#endif"></a>5.1 #if&emsp;#endif</h2><p><strong>语法：<br>#if&emsp;constant-expression<br>&emsp;&emsp;statements<br>#endif</strong></p>
<p>说明：<strong>constant-expression必须为常量表达式</strong>，如果它的值为非0，statements部分正常编译，否则预编译阶段删除它们。<br>之所以要常量表达式，因为这个是在预编译阶段进行条件判断，如果是变量，变量只有在程序执行阶段才赋值的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7d831711220698cb17a9c8e8cc444b2b.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-2-if-emsp-elif-emsp-else-emsp-endif"><a href="#5-2-if-emsp-elif-emsp-else-emsp-endif" class="headerlink" title="5.2 #if&emsp;#elif&emsp;#else&emsp;#endif"></a>5.2 #if&emsp;#elif&emsp;#else&emsp;#endif</h2><p><strong>语法：<br>#if&emsp;constant-expression<br>&emsp;&emsp;statements<br>#elif&emsp;constant-expression<br>&emsp;&emsp;statements<br>#else<br>&emsp;&emsp;statements<br>#endif</strong><br>说明：#elif子句出现次数不限，constant-expression（常量表达式）值非0编译下面statements部分，如果都不满足编译else对应statements部分，#else是可选的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION == 1</span></span><br><span class="line">	<span class="type">int</span> ver = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION == 2</span></span><br><span class="line">    <span class="type">int</span> ver = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION == 3</span></span><br><span class="line">    <span class="type">int</span> ver = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> ver = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;version: %d\n&quot;</span>,ver);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-是否被定义"><a href="#5-3-是否被定义" class="headerlink" title="5.3 是否被定义"></a>5.3 是否被定义</h2><p>#if&emsp;defined(symbol)<br>#ifdef&emsp;symbol<br>说明：上面两条语句等价<br>功能：<strong>当symbol符号存在</strong>，则编译#if与#endif之间语句<br><img src="https://i-blog.csdnimg.cn/blog_migrate/18f848835079cf4318e2547faf81db4c.png#pic_center" alt="在这里插入图片描述"></p>
<p>#if&emsp;!defined(symbol)<br>#ifndef&emsp;symbol<br>说明：上面两条语句等价<br>功能：<strong>当symbol符号不存在</strong>，则编译#if与#endif之间语句<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0bfc9288995bc04a8254e735d49b07f2.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="5-4-嵌套指令"><a href="#5-4-嵌套指令" class="headerlink" title="5.4 嵌套指令"></a>5.4 嵌套指令</h2><p>前面提到的指令可以嵌套定义在另一个指令内部，如下面代码所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_UNIX)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> OPTION1</span></span><br><span class="line">		unix_version_option1();</span><br><span class="line"> 	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	<span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line"> 		unix_version_option2();</span><br><span class="line"> 	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(OS_MSDOS)</span></span><br><span class="line"> 	<span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line"> 		msdos_version_option2();</span><br><span class="line"> 	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>说明：这个例子中，根据操作系统类型选择不同的处理方案，在预处理指令前面加空白符，形成缩进，有利于提高可读性</p>
<h1 id="六、-文件包含"><a href="#六、-文件包含" class="headerlink" title="六、 文件包含"></a>六、 文件包含</h1><p><code>#include</code> 指令可以使另外一个文件的内容被包含到本文件内编译，就像它实际出现于<code>#include</code>指令的位置一样。这种替换的方式很简单：<strong>预处理器先删除这条指令，并用包含文件的内容取而代之</strong>。<strong>一个头文件被包含10次，那就实际被编译10次</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/61c692c2f9992e05db371df029f7376d.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="6-1-文件包含两种方式"><a href="#6-1-文件包含两种方式" class="headerlink" title="6.1 文件包含两种方式"></a>6.1 文件包含两种方式</h2><p>编译器支持两种不同方式<code>#include</code>文件包含：库函数头文件和自定义头文件</p>
<p>库函数头文件：<br><code>#include &lt;filename&gt;</code><br>编译器直接去标准位置去查找，如果找不到就预编译错误，在UNIX(Linux)系统下标准位置为：<code>/usr/include</code></p>
<p>自定义头文件：<br><code>#include &quot;filename&quot;</code><br>编译器先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件,如果找不到就预编译错误</p>
<p><strong>对于库函数头文件和自定义头文件使用双括号或尖括号方式都可以，它们区别在于：1. 查找方式不同   2. 通过库函数头文件&lt;&gt;  自定义头文件” “ 这种约定可以判断一个头文件是库函数头文件还是自定义头文件</strong></p>
<h2 id="6-2-嵌套文件包含"><a href="#6-2-嵌套文件包含" class="headerlink" title="6.2 嵌套文件包含"></a>6.2 嵌套文件包含</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9fe7acd9bdfba5712b12f84adbbe7618.png#pic_center" alt="在这里插入图片描述"><br>头文件a.h和b.h都包含x.h文件，test.c文件又分别包含a.h、b.h文件，当预编译test.c文件时，x.h文件被包含2次<br><strong>这种嵌套包含在绝大多数情况下出现在大型程序中，它往往需要很多头文件，因此发现这种情况并不容易，为了解决这个问题，可以使用条件编译</strong>。如果所有头文件都像下面这样编写，就可以解决问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEADERNAME_H</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> _HEADERNAME_H</span></span><br><span class="line">	<span class="comment">//头文件内容</span></span><br><span class="line"><span class="meta">#end</span></span><br></pre></td></tr></table></figure>
<p>当头文件第一次被包含时，_HEADERNAME_H未定义，条件判断为真，使用宏定义_HEADERNAME_H，并包含头文件内容。如果头文件再次被包含，条件判断为假，头文件内容不会再次被包含。<br><strong>_HEADERNAME_H ：按照头文件名进行取名，以避免其他头文件使用相同的名字而引起冲突。如头文件add.h, 则 _ADD_H</strong> </p>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
  </entry>
  <entry>
    <title>C语言的控制结构（顺序结构、选择结构、循环结构）详解</title>
    <url>/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%EF%BC%88%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%89%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
前言：程序由三种基本结构组成：**顺序结构、选择结构、和循环结构**，任何程序都由这3种基本结构组合而成。
**优点**：不会存在无规律的转向，可以使程序结构清晰，易于验证正确性且易于纠错。遵循这种方法的程序设计就是结构化程序设计。

<p><strong>此处简单画出三种结构的执行流程图：</strong></p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/d072af264cc91af93e9cba24492f236b.png" align="left">

<p><strong>注意：C语言没有布尔类型，在C语言中用数字0表示假，非0表示真，文章后面不在进行说明</strong></p>
<span id="more"></span> 

<h1 id="一、顺序结构"><a href="#一、顺序结构" class="headerlink" title="一、顺序结构"></a>一、顺序结构</h1><p>顺序结构：<strong>依照线性顺序依次执行</strong>，简单说就是从上到下依次执行<br>例如下面程序会依次输出1、2、3、4、5</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h1 id="二、选择结构"><a href="#二、选择结构" class="headerlink" title="二、选择结构"></a>二、选择结构</h1><p>选择结构：<strong>通过某个给定条件进行判断，条件为真或假时分别执行不同的程序内容,选择结构分if语句和switch语句两种</strong>（就像人生不是一帆风顺，直线往前走。比如今天出门看到外面下雨了就会带伞，没有下雨就不用带伞一样进行判断）</p>
<h2 id="2-1-if语句（只会匹配一个表达式对应内容）"><a href="#2-1-if语句（只会匹配一个表达式对应内容）" class="headerlink" title="2.1 if语句（只会匹配一个表达式对应内容）"></a>2.1 if语句（只会匹配一个表达式对应内容）</h2><p>语法结构（主要分为三种，下面会一 一举例）：<br><strong>说明：以 ; 结尾是一条语句，</strong><br><strong>第一种</strong><br>if(表达式)<br>&emsp;&emsp;执行语句; </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &gt;= <span class="number">18</span>)  <span class="comment">//当if括号内表达式为真时（即非0），才会执行紧接if的第一条语句</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>代码块： 一对大括号 {   }包裹的语句叫做代码块</strong><br>在if语句中如果不使用代码块则<strong>只会执行紧接if的第一条语句</strong>，后面语句与if表达式判断无关。如果想当if表达式为真时执行多条语句，<strong>需要将多条语句包裹在代码块内</strong>，下面将举例说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序本意是当用户输入年龄大于等于18时，输出成年并可以谈恋爱。小于18时则什么都不输出</span></span><br><span class="line"><span class="comment">//但是if表达式后面有两条语句，但没有使用代码块包裹，则不管用户输入什么都会输出 可以谈恋爱</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;   </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &gt;= <span class="number">18</span>) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱了&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成年</span><br><span class="line">可以谈恋爱了</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">可以谈恋爱了</span><br></pre></td></tr></table></figure>

<p><strong>使用代码块执行多条语句</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户输入大于等于18输出成年并可以谈恋爱，小于18则什么都不输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成年</span><br><span class="line">可以谈恋爱了</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong><br>if(表达式)<br>&emsp;&emsp;执行语句1;<br>else<br> &emsp;&emsp;执行语句2;  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &gt;= <span class="number">18</span>)  <span class="comment">//当if括号内表达式为真则执行下面第一条语句</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>   <span class="comment">//当上面表达式都不匹配时，则匹配else,执行else下面第一条语句</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;未成年\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成年</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">未成年</span><br></pre></td></tr></table></figure>
<p><strong>当if或else想执行多条语句时使用代码块，后续再不演示有代码块和没有代码块的区别</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户输入年龄大于等于18时输出成年可以谈恋爱，否则输出未成年不可以谈恋爱</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;未成年\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不可以谈恋爱\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">成年</span><br><span class="line">可以谈恋爱</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">未成年</span><br><span class="line">不可以谈恋爱</span><br></pre></td></tr></table></figure>

<p> <strong>第三种</strong>（多分枝选择）<br> if(表达式1)<br>&emsp;&emsp;执行语句1;<br>else if(表达式2)<br> &emsp;&emsp;执行语句2;<br> else<br>  &emsp;&emsp;执行语句3; </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据用户输入年龄，输出所处年龄段</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄:&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">	<span class="keyword">if</span> (age &lt;= <span class="number">12</span>)   <span class="comment">//当if表达式为真，输出童年并退出整个if语句,否则继续向下判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;童年\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">18</span>)  <span class="comment">//当年龄大于12小于18此表达式为真，输出青少年，</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;青少年\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">60</span>) <span class="comment">//当年龄大于等于18小于60此表达式为真，输出壮年，</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;壮年\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>      <span class="comment">//当上面多个表达式都不匹配时最后会匹配else对应语句，即输出老年</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;老年\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">童年</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">壮年</span><br></pre></td></tr></table></figure>
<p><strong>悬空else(else只会与紧挨的第一个if匹配，与代码缩进无关，这跟python语言不一样)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先进入if判断,由于a=0,所以不匹配 a == 1表达式,则直接退出整个if语句。</span></span><br><span class="line"><span class="comment">//但是此写法会让人误以为由于a=0,所以不匹配 a == 1表达式，则匹配else，输出：不可以谈恋爱,但注意此处</span></span><br><span class="line"><span class="comment">//else会与它紧紧挨着的if匹配，即if(b==2)匹配上，但是if(b==2)又是if(a==1)表达式为真的前提下才行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不可以谈恋爱\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不可以谈恋爱\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-switch语句"><a href="#2-2-switch语句" class="headerlink" title="2.2 switch语句"></a>2.2 switch语句</h2><p> 当分支条件过多时使用if会十分的不方便，上面例子中判断年龄段的程序，如果再判断的精细些（加上青少年、青年、中老年等），则整个if语句会十分臃肿且难以维护。使用switch就能很好解决这种问题。<br> 语法( <strong>下面[ ]内代表可选参数</strong>):<br> switch(<strong>整形表达式</strong>)<br> {<br>&emsp;&emsp;case <strong>整数常量表达式1</strong> :<br>&emsp;&emsp;&emsp;语句1_1<br>&emsp;&emsp;&emsp;语句1_2<br>&emsp;&emsp;&emsp;[break]<br>&emsp;&emsp;&emsp;…<br>&emsp;&emsp;case <strong>整数常量表达式2</strong> :<br>&emsp;&emsp;&emsp;语句2_1<br>&emsp;&emsp;&emsp;语句2_2<br>&emsp;&emsp;&emsp;…<br>&emsp;&emsp;&emsp;[break]<br>&emsp;&emsp;<strong>…</strong><br>&emsp;&emsp;[default<br>&emsp;&emsp;&emsp;语句n_1<br>&emsp;&emsp;&emsp;	break]<br>}</p>
<p>说明：</p>
<ol>
<li>当case后面常量表达式值<strong>等于</strong>switch的整数表达式时，执行该case后面的语句，<strong>但不退出switch</strong>,而是一直执行下去，直到整个switch结束，<strong>所以case只是switch的入口</strong>，<strong>这跟if匹配到某个表达式执行对应语句后就退出不一样</strong></li>
<li>case后面的<strong>常量表达式的值不能相同</strong>，例如出现多个 case 1:</li>
<li><strong>在switch中遇到break会退出整个switch</strong></li>
<li><strong>当switch的整数表达式与所有case都没匹配上时，则执行default对应语句</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序本意，当用户输入1-7时输出对应星期几</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入今天是星期几：&gt;  &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span> (day)    <span class="comment">//switch()内必须是整数表达式，例如当里面是变量时，此变量必须为整数类型(short、char、int、long)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:        <span class="comment">//当case后面常量表达式值等于switch的整数表达式时，进入该case，并依次执行剩下内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">星期二</span><br><span class="line">星期三</span><br><span class="line">星期四</span><br><span class="line">星期五</span><br><span class="line">星期六</span><br><span class="line">星期天</span><br></pre></td></tr></table></figure>
<p>我们本来只是想输出星期二，结果case 2:对应语句执行完后继续执行，直到整个switch执行完。<br>这时我们可以加上break关键字<br><strong>break在switch作用：在switch中遇到break会退出整个switch,不管break下面还有没有case语句</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户输入1-7时输出对应星期几</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入今天是星期几：&gt;  &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span> (day)   </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//遇到break跳出对应switch</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">星期二</span><br></pre></td></tr></table></figure>
<p>但此时用户输入除了1-7以外的值，整个switch没有匹配到，程序不会输出什么，此程序对用户不够友好。<strong>我们无法预测用户输入的所有可能值，但我们可以对不符合规则的输入进行提醒，此时会用到default关键字</strong>,即case都没有匹配到，则执行default对应语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户输入1-7时输出对应星期几</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入今天是星期几：&gt;  &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//遇到break跳出对应switch</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期天\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误，请输入1-7范围内的数字\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入错误，请输入<span class="number">1</span><span class="number">-7</span>范围内的数字</span><br></pre></td></tr></table></figure>
<p>当想多个case执行相同语句时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户输入1-5时输出工作日，输出6-7时输出休息日</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入今天是星期几：&gt;  &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span> (day)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;工作日\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;休息日\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入错误，请输入1-7范围内的数字\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">工作日</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">工作日</span><br></pre></td></tr></table></figure>
<h1 id="三、循环结构"><a href="#三、循环结构" class="headerlink" title="三、循环结构"></a>三、循环结构</h1><p>循环结构：<strong>当条件为真时反复执行，直到条件为假则跳出</strong>（《围城》里面说到，有的人想进去，有的人却想出去，就像人生一样好像一直循环着）</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法：<br>for(表达式1;表达式2;表达式3)<br>&emsp;&emsp;循环语句;</p>
<p>说明：<br>表达式1：初始化部分，用于初始化循环变量，<strong>整个for循环只会执行1次</strong><br>表达式2：条件判断部分，用于判断循环终止<br>表达式3：调整部分，用于循环条件的调整<br>建议：<strong>不要在循环体内修改循环变量，防止for循环失控</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/90dc4af7a7df63557992fc459661f104.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出数组所有元素</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//第一次循环首先将i初始化为0，这个初始化部分只会执行1次,此时i&lt;10(只有判断条件为真才会进入循环)</span></span><br><span class="line">	<span class="comment">//执行循环语句输出arr[0]，然后进入调整部分让变量i加1,此时i=1；</span></span><br><span class="line">	<span class="comment">//第二次循环，首先进入判断部分进入判断；此时i&lt;10 即 1&lt;10为真，执行循环语句输出arr[1],然后进入调整部分</span></span><br><span class="line">	<span class="comment">//让变量i+1，此时i=2；后续循环跟第二次循环类似</span></span><br><span class="line">	<span class="comment">//注意：初始化部分在整个for循环只执行1次，判断部分会比循环语句多1次</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>break：循环中遇到break直接<em>终止整个循环</em>（while、do while中也一样）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在1-10中输出小于5的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">//当i == 5时，if条件为真，执行break，跳出整个for循环，所以数字5及后续数字不会打印</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>continue：循环中遇到continue会<em>终止本次循环</em>，也就是本次循环continue后面代码不会执行（while、do while中也一样）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">//当i == 5时，if条件为真，执行continue，终止本次循环后面代码（即5不会打印）。直接跳到调整部分，i++后i为6，进行下一次循环的判断</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>语法：<br>while(表达式)<br>&emsp;&emsp;循环语句</p>
<p>当表达式为真时执行循环语句，然后再次判断…<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cbd6f63b695839f25077f067463243b1.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出1-10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10</span>) <span class="comment">//当表达式为真执行里面&#123; &#125;内循环语句</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);  </span><br><span class="line">		i++;   <span class="comment">//调整部分，使i变量逐渐大于10后终止循环，没有调整部分将会是死循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>break:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出1-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10</span>) <span class="comment">//当表达式为真执行里面&#123; &#125;内循环语句</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">//当i==5时执行break,终止整个while循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);  </span><br><span class="line">		i++;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<p>continue</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10</span>) <span class="comment">//当表达式为真执行里面&#123; &#125;内循环语句</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">//当i==5时执行continue,终止本地循环continue后面部分，i++不会执行，所以进入判断部分i还是5，导致死循环</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);  </span><br><span class="line">		i++;   <span class="comment">//调整部分，使i变量逐渐大于10后终止循环，没有调整部分将会是死循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>  <span class="comment">//死循环，后面光标一直闪烁，程序没有停止运行</span></span><br></pre></td></tr></table></figure>

<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><p>语法<br>do<br>&emsp;&emsp;循环语句<br>while(表达式)</p>
<p>do while与while基本相同，表达式为真才会执行循环语句。但是do while第一次执行时不会判断表达式<br>。<strong>即就算表达式为假也会执行一次循环语句</strong><br><strong>do while 适用场景：某个功能必须执行一次，后续是否执行通过是否满足条件判断</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/fe0d0a8f9e81feb83b2880db6290be14.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;哈哈哈\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>); <span class="comment">//第一次循环时输出 哈哈哈,由于表达式为假，退出do while循环</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">哈哈哈</span><br></pre></td></tr></table></figure>
<p>break</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出1-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>continue</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">//当i=5时表达式为真，执行continue,直接到判断部分，此时i&lt;=10进入循环语句，但i=5时表达式为真，执行continue,直接到判断部分依此类推，程序陷入死循环</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>  <span class="comment">//死循环，后面光标一直闪烁，程序没有停止运行</span></span><br></pre></td></tr></table></figure>
<h1 id="四、goto语句"><a href="#四、goto语句" class="headerlink" title="四、goto语句"></a>四、goto语句</h1><p>C语言提供了可以使用的goto语句和标记跳转的标签。理论上goto语句没有使用必要（容易代码逻辑错造成随意跳转），但在深层循环嵌套使用break达不到目的。而可以使用goto可以解决</p>
<p>语法</p>
<p>标号：<br>&emsp;&emsp;语句；</p>
<p>if(表达式)<br>&emsp;&emsp;goto 标签;</p>
<p>标签：表达需要跳转的位置<br>goto 标签：跳到哪个标签去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户输入 博主是个大帅哥 就会输出 你也是大帅哥 退出程序，否则死循环</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> input[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入：博主是个大帅哥，否则程序死循环\n&quot;</span>);</span><br><span class="line">	again: <span class="comment">//使用 again标记需要跳转位置</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(input,<span class="string">&quot;博主是个大帅哥&quot;</span>) == <span class="number">0</span>) <span class="comment">//strcmp() 字符串比较函数，当为0代表两个字符串相等</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;你也是个大帅哥\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;你说谎，请重新输入：&gt;&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> again; <span class="comment">//跳转到again标号对应位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>goto使用注意事项</p>
<ul>
<li>goto不能跨函数，指定的标签必须位于当前函数中，所有标签为内部命名空间的成员，因此不会干扰其他标识符。</li>
<li>goto跳转到标签位置的范围内不能有任何变量的初始化，除非该变量作用域不与标签作用域相同。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例<span class="number">1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-test1-&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> label3; <span class="comment">// 错误，goto不能跨越函数</span></span><br><span class="line">label1:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-label1-&quot;</span>);</span><br><span class="line">label2:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label2-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-test2-&quot;</span>);</span><br><span class="line">label3:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label3-&quot;</span>);</span><br><span class="line">label4:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label4-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例<span class="number">2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-test1-&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> label2;</span><br><span class="line">label1:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-label1-&quot;</span>);</span><br><span class="line">label2:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label2-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-test2-&quot;</span>);</span><br><span class="line">label2:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-test2() label2-&quot;</span>);</span><br><span class="line">label3:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label3-&quot;</span>);</span><br><span class="line">label4:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label4-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* test1函数中label2标签与test2函数中label2标签不冲突，因为标签为内部命名空间的成员，作用域只在当前函数 */</span></span><br><span class="line"></span><br><span class="line">例<span class="number">3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-test1-&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> label2;</span><br><span class="line">        <span class="type">int</span> i; <span class="comment">// 正确</span></span><br><span class="line">label1:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label1-&quot;</span>);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>; <span class="comment">// 错误，不允许对变量初始化</span></span><br><span class="line">label2:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label2-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-test1-&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> label2;</span><br><span class="line">        <span class="type">int</span> i; <span class="comment">// 正确</span></span><br><span class="line">label1:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label1-&quot;</span>);</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = <span class="number">2</span>; <span class="comment">// 正确，通过大括号将变量j作用域与标签相隔离</span></span><br><span class="line">		&#125;</span><br><span class="line">label2:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-label2-&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
      <tags>
        <tag>控制结构</tag>
      </tags>
  </entry>
  <entry>
    <title>FUSE是什么</title>
    <url>/FUSE%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<h1 id="一、FUSE基本概念"><a href="#一、FUSE基本概念" class="headerlink" title="一、FUSE基本概念"></a>一、FUSE基本概念</h1><h2 id="1-1-FUSE-是什么"><a href="#1-1-FUSE-是什么" class="headerlink" title="1.1 FUSE 是什么"></a>1.1 FUSE 是什么</h2><p>FUSE 是 Filesystem in Userspace 的缩写，也就是常说的<strong>用户态文件系统</strong>。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvZnVzZS5odG1s">Linux内核官方文档<i class="fa fa-external-link-alt"></i></span>对 FUSE 的解释如下：</p>
<blockquote>
<p>What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).</p>
</blockquote>
<span id="more"></span>

<p><strong>即FUSE 是一个用户空间文件系统的框架</strong>，这套框架包含3个组件：</p>
<ol>
<li><strong>内核模块 fuse.ko</strong> ：用来接收VFS传递下来的IO请求，并且把这个IO封装之后通过管道发送到用户态；</li>
<li><strong>用户态 lib 库 libfuse</strong> ：解析内核态转发出来的协议包，拆解成常规的 IO 请求；</li>
<li><strong>mount 工具 fusermount</strong> ；</li>
</ol>
<p>这 3 个组件一起完成一件事：可以在用户态实现文件系统，并且让IO在内核态和用户态文件系统之间自由穿梭。</p>
<img src="FUSE是什么/FUSE架构图.png" width="50%">

<h2 id="1-2-为什么需要FUSE"><a href="#1-2-为什么需要FUSE" class="headerlink" title="1.2 为什么需要FUSE"></a>1.2 为什么需要FUSE</h2><p>FUSE被称为用户空间文件系统，为什么要强调用户空间呢？接触过Linux内核的同学大概会知道，早期的文件系统开发只能在内核中。文件系统一般是实现在内核里面的，比如，Ext4、Fat32、NTFS(Kernel原生版)等常见的文件系统，其代码都在内核中，内核开发的难点在于调试和排查故障，而FUSE特殊之处就是，其文件系统的<strong>核心逻辑</strong>是在<strong>用户空间</strong>实现的。</p>
<p>有了FUSE之后，我们就可以在用户态空间实现文件系统。<br><strong>优点</strong>：开发便捷，易于调试。安全性高，崩溃不会影响整个系统。</p>
<p><strong>缺点</strong>：性能较低，会在用户态和内核态之间频繁切换，带来了性能开销。</p>
<h3 id="1-2-1-内核态文件系统IO流程"><a href="#1-2-1-内核态文件系统IO流程" class="headerlink" title="1.2.1 内核态文件系统IO流程"></a>1.2.1 内核态文件系统IO流程</h3><p>早期的文件系统是位于内核之中， 处于VFS之下，块设备之上的一个位置。对上呈现文件存储实现，对下管理裸块设备。也就是说早期文件系统是内核的一个模块。那就可以理解了，内核模块的开发之所以艰难就是难在<strong>调试和排障</strong>，用户态的程序你可以随意 debug，出问题最多也就是 panic，coredump，内核态的程序出了问题就是宕机，所有现场都丢失，你只能通过日志，kdump 等手段来排查。</p>
<p>下图是没有FUSE的时候，IO经过内核文件系统的一个大概流程</p>
<img src="FUSE是什么/内核态文件系统IO流程图1.gif"  >

<p>比较详细的流程图<br><img src="FUSE是什么/内核态文件系统IO流程图2.png"  ></p>
<h3 id="1-2-2-用户态文件系统IO流程"><a href="#1-2-2-用户态文件系统IO流程" class="headerlink" title="1.2.2 用户态文件系统IO流程"></a>1.2.2 用户态文件系统IO流程</h3><p>注意：图中简化了用户态之上的逻辑处理。</p>
<img src="FUSE是什么/用户态文件系统IO流程图1.gif"  >

<h1 id="二、FUSE进阶"><a href="#二、FUSE进阶" class="headerlink" title="二、FUSE进阶"></a>二、FUSE进阶</h1><h2 id="2-1-FUSE原理"><a href="#2-1-FUSE原理" class="headerlink" title="2.1 FUSE原理"></a>2.1 FUSE原理</h2><p>首先看一眼 wiki 上有对 FUSE 的 ls -l &#x2F;tmp&#x2F;fuse 命令的演示图：<br><img src="FUSE是什么/FUSE原理图.png"  ></p>
<p>背景：一个用户态文件系统，挂载点为 &#x2F;tmp&#x2F;fuse ，用户二进制程序文件为 .&#x2F;hello（该二进制程序可以理解为用户自己根据自身需求实现的文件系统）;</p>
<p>这个图的意思是：</p>
<ol>
<li>当执行 ls -l &#x2F;tmp&#x2F;fuse 命令的时候，流程如下：<br> (1) IO 请求先进内核，经VFS传递给内核 FUSE 文件系统模块；<br> (2) 内核 FUSE 模块把请求发给到用户态，由 .&#x2F;hello 程序接收并且处理。处理完成之后，响应原路返回；</li>
</ol>
<p>简化的 IO 动画示意图：</p>
<img src="FUSE是什么/FUSE简洁IO流程图.gif"  >

<p>通过这两张图，对 FUSE IO 的流程应该就清晰了，内核 FUSE 模块在内核态中间做协议封装和协议解析的工作，它接收从VFS下来的请求并按照 FUSE 协议转发到用户态，然后接收用户态的响应，并随后回复给用户。<strong>FUSE在这条IO路径是做了一个透明中转站的作用</strong>，用户完全不感知这套框架。我们把中间的 FUSE 当作一个黑盒遮住，就更容易理解了。</p>
<p>fuse.ko和libfuse库的作用：</p>
<p>这两个模块一个位于内核，一个位于用户态，是配套使用的，最核心的功能是<strong>协议封装和解析</strong>。</p>
<p>举个例子，内核 fuse.ko用于接收VFS下来的IO请求，然后封装成 FUSE 数据包，转发给用户态。这个时候，用户态文件系统收到这个 FUSE 数据包，它如果想要看懂这个数据包，就必须实现一套FUSE协议的代码，这套代码是公开透明的，属于FUSE框架的公共的代码，这种代码不需要让所有的用户文件系统都重复实现一遍，于是libfuse库就诞生了。</p>
<h2 id="2-2-FUSE-协议格式"><a href="#2-2-FUSE-协议格式" class="headerlink" title="2.2 FUSE 协议格式"></a>2.2 FUSE 协议格式</h2><p>接下来我们看下FUSE数据传输的数据格式（FUSE协议的格式），请求包和响应包是什么样子的？</p>
<h3 id="2-2-1-FUSE-请求"><a href="#2-2-1-FUSE-请求" class="headerlink" title="2.2.1 FUSE 请求"></a>2.2.1 FUSE 请求</h3><p>FUSE 请求包分为两部分：</p>
<ol>
<li>Header ： 这个是所有请求共用的，比如 open 请求，read 请求，write 请求，getxattr 请求，头部都至少有这个结构体，Header 结构体能描述整个 FUSE 请求，其中字段能区分请求类型；</li>
<li>Payload ：这个东西是每个 IO 类型会是不同的，比如 read 请求就没这个，write 请求就有这个，因为 write 请求是携带数据的；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_in_header</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;       <span class="comment">/* Total length of the data, including this header */</span></span><br><span class="line">    <span class="type">uint32_t</span> opcode;    <span class="comment">/* The kind of operation (see below) */</span></span><br><span class="line">    <span class="type">uint64_t</span> unique;    <span class="comment">/* A unique identifier for this request */</span></span><br><span class="line">    <span class="type">uint64_t</span> nodeid;    <span class="comment">/* ID of the filesystem object being operated on */</span></span><br><span class="line">    <span class="type">uint32_t</span> uid;       <span class="comment">/* UID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> gid;       <span class="comment">/* GID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> pid;       <span class="comment">/* PID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> padding;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Len: 是整个请求的字节数长度（Header + Payload）</li>
<li>Opcode: 请求的类型，比如区分 open、read、write 等等；</li>
<li>Unique: 请求唯一标识（和响应中要对应）</li>
<li>Nodeid: 请求针对的文件 nodeid，目标文件或者文件夹的 nodeid；</li>
<li>Uid: 文件&#x2F;文件夹操作的进程的用户 ID</li>
<li>Gid: 文件&#x2F;文件夹操作的进程的用户组 ID</li>
<li>Pid: 文件&#x2F;文件夹操作的进程的进程 ID</li>
</ul>
<h3 id="2-2-2-FUSE响应"><a href="#2-2-2-FUSE响应" class="headerlink" title="2.2.2 FUSE响应"></a>2.2.2 FUSE响应</h3><p>FUSE 响应包分为两部分：</p>
<ol>
<li><p>Header ：这个结构体也是在数据头部的，所有 IO 类型的响应都至少有这个结构体。该结构体用于描述整个响应请求；</p>
</li>
<li><p>Payload ：每个请求的类型可能不同，比如 read 请求就会有这个，因为要携带 read 出来的用户数据，write 请求就不会有；</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_out_header</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;       <span class="comment">/* Total length of data written to the file descriptor */</span></span><br><span class="line">    <span class="type">int32_t</span>  error;     <span class="comment">/* Any error that occurred (0 if none) */</span></span><br><span class="line">    <span class="type">uint64_t</span> unique;    <span class="comment">/* The value from the corresponding request */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Len: 整个响应的字节数长度（ Header + Payload ）；</li>
<li>Error: 响应错误码，成功返回 0，其他对应着系统的错误代码，负数；</li>
<li>Unique: 对应者请求的唯一标识，和请求对应；</li>
</ul>
<h2 id="2-3-dev-fuse"><a href="#2-3-dev-fuse" class="headerlink" title="2.3 &#x2F;dev&#x2F;fuse"></a>2.3 &#x2F;dev&#x2F;fuse</h2><p>现在对数据协议的格式，转发和转运的模块我们也知道了。现在还差一个关键的点：数据包的通道，换句话说，内核模块的“包裹”发到哪里？用户程序又从哪里读取拿到这个“包裹”。</p>
<p><strong>答案是：&#x2F;dev&#x2F;fuse ，这个虚设备文件就是内核模块和用户程序的桥梁</strong>。</p>
<p>这样一切都顺理成章了，整个过程中，用户的IO通过正常的系统调用进来，走到内核文件系统FUSE，FUSE文件系统把这个IO请求按照FUSE协议封装起来，打包成特定的格式，通过 &#x2F;dev&#x2F;fuse 这个管道传递到用户态。在此之前有守护进程监听这个管道，看到有消息出来之后，立马读出来，然后利用libfuse库解析协议，之后就是用户文件系统的代码逻辑了。</p>
<p>该过程示意图如下（省略了拆解包的步骤）：<br><img src="FUSE是什么/数据通道.gif"  ></p>
<h1 id="三、-FUSE-的使用"><a href="#三、-FUSE-的使用" class="headerlink" title="三、 FUSE 的使用"></a>三、 FUSE 的使用</h1><ol>
<li>检查内核是否支持，即是否有fuse.ko 内核模块。可运行下列命令检查，如果不报错则表示内核支持并且已经加载。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# modprobe fuse</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>挂载FUSE内核文件系统，便于管理</li>
</ol>
<p>FUSE这个内核文件系统其实是可以挂载，也可以不挂载，挂载了主要是方便管理多个用户系统而已，FUSE内核文件系统的 Type 名称为 fusectl，挂载命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# mount -t fusectl none /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure>

<p>可以用 df -aT 命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">df</span> -aT|grep -i fuse</span><br><span class="line">none           fusectl             0       0         0    - /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure>

<p>通过挂载内核 fuse 文件系统，可以看到所有实现的用户文件系统，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">ls</span> -l /sys/fs/fuse/connections</span><br><span class="line">total 0</span><br><span class="line">dr-x------. 2 user1 user1 0 Oct 30 14:42 36</span><br><span class="line">dr-x------. 2 user1 user1 0 Oct 30 14:42 38</span><br></pre></td></tr></table></figure>

<p>在 &#x2F;sys&#x2F;fs&#x2F;fuse&#x2F;connections 对应两个目录，目录名为 Unique ID，能够唯一标识一个用户文件系统。这里表示内核 fuse 模块通过 &#x2F;dev&#x2F;fuse 设备文件，建立了两个通信管道，分别对应了两个用户文件系统，可以在用 df -aT 对照确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">df</span> -aT|grep -i fuse</span><br><span class="line">none                fusectl                          0       0         0    - /sys/fs/fuse/connections</span><br><span class="line">fuse_demo sourcedir fuse.fuse_demo sourcedir         0       0         0    - /tmp/d1</span><br><span class="line">fuse_demo sourcedir fuse.fuse_demo sourcedir         0       0         0    - /tmp/d2</span><br></pre></td></tr></table></figure>

<p>每个 Uniqe ID 名录下，有若干个文件，通过这些文件，我们可以获取到当前用户文件系统的状态，或跟 fuse 文件系统交互，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">ls</span> -l /sys/fs/fuse/connections/36</span><br><span class="line">total 0</span><br><span class="line">--w-------. 1 user1 user1 0 Oct 30 14:42 abort</span><br><span class="line">-rw-------. 1 user1 user1 0 Oct 30 14:42 congestion_threshold</span><br><span class="line">-rw-------. 1 user1 user1 0 Oct 30 14:42 max_background</span><br><span class="line">-r--------. 1 user1 user1 0 Oct 30 14:42 waiting</span><br></pre></td></tr></table></figure>

<ul>
<li>waiting 文件：cat 一下就能获取到当前正在处理的 IO 请求数；</li>
<li>abort 文件：该文件写入任何字符串，都会终止这个用户文件系统和上面所有的请求；</li>
</ul>
<ol start="3">
<li>挂载用户文件系统</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户态文件系统程序名 mountpoint [options] </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>卸载用户文件系统</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fusermount -u mountpoint</span><br></pre></td></tr></table></figure>

<p>FUSE 的作用在于使用户能够绕开内核代码来编写文件系统，但是请注意，文件系统要实现对具体的设备的操作的话必须要使用设备驱动提供的接口，而设备驱动位于内核空间，这时可以直接读写块设备文件，就相当于只把文件系统摘到用户态，用户直接管理块设备空间。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvZnVzZS5odG1s">Linux内核官方FUSE介绍<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vYXJ0aWNsZS82NTVjMDg5M2VkMTUwZmY2NWYyYjdhMTZm">FUSE 文件系统<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMmI3N2QwYmJjNDM=">FUSE(Filesystem in Userspace)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>FUSE</category>
      </categories>
      <tags>
        <tag>FUSE</tag>
      </tags>
  </entry>
  <entry>
    <title>RocksDB是什么</title>
    <url>/RocksDB%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>RocksDB 是一个持久、内嵌型 K&#x2F;V存储引擎，键和值是任意大小的字节流（没有类型）。它支持<code>point lookup</code>和<code>range scan</code>，并提供不同类型的 ACID 保证。它是一个 C++ 库。RocksDB 借鉴了开源<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9sZXZlbGRiLw==">leveldb<i class="fa fa-external-link-alt"></i></span>项目的重要代码以及<span class="exturl" data-url="aHR0cDovL2hiYXNlLmFwYWNoZS5vcmcv">Apache HBase<i class="fa fa-external-link-alt"></i></span>的设计理念。初始代码是从开源 leveldb 1.5 fork而来的。它还以 Meta 在 RocksDB 之前开发的代码和理念为基础。</p>
<p>RocksDB 具有高度灵活的设置，可以根据不同的生产环境进行调优，包括 SSD、硬盘、ramfs 或远程存储。它支持多种压缩算法，并提供了良好的生产支持和调试工具。另一方面，RocksDB 也努力限制可调参数的数量，提供足够好的开箱即用性能，并在适用的地方使用一些自适应算法。</p>
<span id="more"></span>

<p>“内嵌” 意味着：</p>
<ul>
<li>该数据库没有独立进程，而是被集成进应用中，和应用共享内存等资源，从而避免了跨进程通信的开销。</li>
<li>它没有内置服务器，无法通过网络进行远程访问。</li>
<li>它不是分布式的，这意味着它不提供容错性、冗余或分片（sharding）机制。</li>
</ul>
<p>如有必要，需依赖于应用层来实现上述功能。</p>
<p>RocksDB 提供了很少的几个用于修改 kv 集合的函数底层接口：</p>
<ul>
<li><code>put(key, value)</code>：插入新的键值对或更新已有键值对</li>
<li><code>merge(key, value)</code>：将新值与给定键的原值进行合并</li>
<li><code>delete(key)</code>：从集合中删除键值对</li>
</ul>
<p>获取指定 key 所关联的 value：</p>
<ul>
<li><code>get(key)</code></li>
</ul>
<p>通过迭代器可以进行范围扫描 —— 找到特定的 key，并按顺序访问该 key 后续的键值对：</p>
<ul>
<li><code>iterator.seek(key_prefix); iterator.value(); iterator.next()</code></li>
</ul>
<h2 id="1-2-高度分层架构"><a href="#1-2-高度分层架构" class="headerlink" title="1.2 高度分层架构"></a>1.2 高度分层架构</h2><img src="RocksDB是什么/LSM-tree.png"  >

<p>RocksDB 的核心数据结构被称为<strong>日志结构合并树</strong> （LSM-Tree）。它是一种树形的数据结构，由多个层级组成，每层的数据按 key 有序。LSM-Tree 主要设计用来应对写入密集型工作负载，并于 1996 年在同名论文 <span class="exturl" data-url="aHR0cDovL3BhcGVyaHViLnMzLmFtYXpvbmF3cy5jb20vMThlOTFlYjRkYjIxMTRhMDZlYTYxNGYwMzg0ZjI3ODQucGRm">The Log-Structured Merge-Tree (LSM-Tree)<i class="fa fa-external-link-alt"></i></span> 被大家所知，其核心思想是充分利用了磁盘批量的顺序IO要远比随机IO性能好。</p>
<p>LSM-Tree 的最高层保存在内存中，包含最近写入的数据。其他较低层级的数据存储在磁盘上，层数编号从 0 到 N 。第 0 层 L0 存储从内存移动到磁盘上的数据，第 1 层及以下层级则存储更老的数据。<strong>通常某层的下个层级在数据量上会比该层大一个数量级，当某层数据量变得过大时，会合并到下一层</strong>。</p>
<h3 id="1-2-1-MemTable"><a href="#1-2-1-MemTable" class="headerlink" title="1.2.1 MemTable"></a>1.2.1 MemTable</h3><p><code>MemTable</code>是一个内存数据结构，在键值对写入磁盘之前，<code>Memtable</code> 会缓存住这些键值对。所有插入和更新操作都会过 MemTable。当然也包括删除操作：不过，在 RocksDB 中，并不会直接原地修改键值对，而是通过插入墓碑记录（tombstone ）来进行标记删除。</p>
<p><code>MemTable</code> 具有可配置的字节数限制。当一个 <code>MemTable</code> 变满时，就会切到一个新的<code> MemTable</code>。同时原 <code>MemTable</code> 变为不可修改状态，由后台线程把内容flush到一个SST文件，然后将该<code>MemTable</code>销毁。</p>
<p>例如现在向数据库中插入key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.put(&quot;chipmunk&quot;, &quot;1&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;2&quot;)</span><br><span class="line">db.put(&quot;raccoon&quot;, &quot;3&quot;)</span><br><span class="line">db.put(&quot;dog&quot;, &quot;4&quot;)</span><br></pre></td></tr></table></figure>

<img src="RocksDB是什么/img1.png"  >

<p>如上图所示，<code>MemTable</code> 中的键值对是按 key 有序排列的。尽管 <code>chipmunk</code> 是最先插入的，但由于 MemTable 是按 key 有序的，因此 <code>chipmunk</code> 排在 <code>cat</code> 之后。这种排序对于范围扫描是必须的。</p>
<p>影响memtable的最重要的几个选项是：</p>
<ul>
<li>memtable_factory: memtable对象的工厂。通过声明一个工厂对象，用户可以改变底层memtable的实现，并提供事先声明的选项。</li>
<li>write_buffer_size：一个memtable的大小</li>
<li>db_write_buffer_size：多个列族的memtable的大小总和。这可以用来管理memtable使用的总内存数。</li>
<li>write_buffer_manager：除了声明memtable的总大小，用户还可以提供他们自己的写缓冲区管理器，用来控制总体的memtable使用量。这个选项会覆盖db_write_buffer_size</li>
<li>max_write_buffer_number：内存中可以拥有刷盘到SST文件前的最大memtable数。</li>
</ul>
<p>默认的<code>MemTable</code>实现是基于<code>skiplist</code>。用户也可以使用其他<code>MemTable</code>实现，例如<code>HashLinkList</code>，<code>HashSkipList</code>或者<code>Vector</code>，以满足不同场景需求。</p>
<table>
<thead>
<tr>
<th>MEMTABLE类型</th>
<th>SKIPLIST</th>
<th>HASHSKIPLIST</th>
<th>HASHLINKLIST</th>
<th>VECTOR</th>
</tr>
</thead>
<tbody><tr>
<td>最佳使用场景</td>
<td>通用</td>
<td>带特殊key前缀的范围查询</td>
<td>带特殊key前缀，并且每个前缀都只有很小数量的行</td>
<td>大量随机写压力</td>
</tr>
<tr>
<td>索引类型</td>
<td>二分搜索</td>
<td>哈希+二分搜索</td>
<td>哈希+线性搜索</td>
<td>线性搜索</td>
</tr>
<tr>
<td>是否支持全量db有序扫描</td>
<td>天然支持</td>
<td>非常耗费资源（拷贝以及排序一生成一个临时视图</td>
<td>同HashSkipList</td>
<td>同HashSkipList</td>
</tr>
<tr>
<td>额外内存</td>
<td>平均（每个节点有多个指针</td>
<td>高（哈希桶+非空桶的skiplist元数据+每个节点多个指针</td>
<td>稍低（哈希桶+每个节点的指针</td>
<td>低（vector尾部预分配的内存）</td>
</tr>
<tr>
<td>Memtable落盘</td>
<td>快速，以及固定数量的额外内存</td>
<td>慢，并且大量临时内存使用</td>
<td>同HashSkipList</td>
<td>同HashSkipList</td>
</tr>
<tr>
<td>并发插入</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>带Hint插入</td>
<td>支持（在没有并发插入的时候</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h3 id="1-2-2-WAL"><a href="#1-2-2-WAL" class="headerlink" title="1.2.2 WAL"></a>1.2.2 WAL</h3><p>当进程崩溃或机器异常时，其内存数据都会丢失。为了防止数据丢失，保证数据的持久化，RocksDB 会将所有更新写入到磁盘上的预写日志（WAL，write-ahead log）中。当发生异常时，RocksDB可以回放日志，恢复数据。</p>
<p>WAL 是一个只允许追加的文件，包含一组更改记录序列。每个记录包含键值对、记录类型（Put &#x2F; Merge &#x2F; Delete）和校验和（checksum，可选）。与 MemTable 不同，在 WAL 中，记录不按 key 有序，而是按照请求到来的顺序被追加到 WAL 中。</p>
<img src="RocksDB是什么/img2.png"  >

<h3 id="1-2-3-SSTable"><a href="#1-2-3-SSTable" class="headerlink" title="1.2.3 SSTable"></a>1.2.3 SSTable</h3><p>SSTable (Sorted String Table) 是一种持久化，有序且不可变的的键值存储结构。为了管理，RocksDB会将一个SST文件切分为若干个固定大小的block，每个block都有一个校验和用于检测数据是否损坏。每次从磁盘读取数据时，RocksDB 都会使用这些校验和进行校验。为了节省磁盘空间，RocksDB 提供了多种压缩算法，以平衡性能和压缩率。例如：Zlib、BZ2、Snappy（默认）、LZ4 或 ZSTD 算法。</p>
<p>尽管 SST 中的 kv 对是有序的，我们也并非总能进行二分查找，尤其是数据块在压缩过后，会使得查找很低效。RocksDB 使用索引来优化查询，索引存储在紧邻数据块之后。索引块会存储每个 block 中最后一个 key与该key在SST文件中偏移量的映射关系，并且索引块中 key 也是有序的，因此我们可以通过二分搜索快速找到某个 key。</p>
<img src="RocksDB是什么/img3.png"  >

<p>例如，我们在查找 <code>lynx</code>，索引会告诉我们这个键值对可能在 block 2，因为按照字典序，<code>lynx</code> 在 <code>chipmunk</code> 之后，但在 <code>raccoon</code> 之前。但其实 SST 文件中并没有 <code>lynx</code>，但我们仍然需要从磁盘加载 block 以进行搜索。RocksDB 支持启用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmxvb21fZmlsdGVy">布隆过滤器<i class="fa fa-external-link-alt"></i></span>，一种具有高效空间利用率的概率性数据结构，可以用来检测某个元素是否在集合中。布隆过滤器保存在 SST 文件中过滤器部分，以便能够快速确定某个 key 不在 SST 中，减少无效磁盘访问，极大提升了查询速度。</p>
<p><strong>Flush</strong></p>
<p>RocksDB 使用一个专门的后台线程定期地把不可变的<code>MemTable</code>从内存持久化到磁盘。一旦刷盘（flush）完成，不可变的<code>MemTable</code> 和相应的 <code>WAL</code> 就会被丢弃。RocksDB 开始写入新的<code> WAL</code>、<code>MemTable</code>。每次刷盘都会在 L0 层上产生一个新的 <code>SST 文件</code>。该文件一旦写入磁盘后，就不再会修改。</p>
<p>RocksDB 的 MemTable 的默认基于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tpcF9saXN0">跳表<i class="fa fa-external-link-alt"></i></span>实现。该数据结构是一个具有额外采样层的链表，从而允许快速、有序地查询和插入数据。有序性使得 <code>MemTable</code> 刷盘时更高效，因为可以直接按顺序迭代键值对顺序写入磁盘。<strong>将随机写变为顺序写是 LSM-Tree 的核心设计之一</strong>。</p>
<img src="RocksDB是什么/img4.png"  >



<p><strong>Compaction</strong></p>
<p>当低level的SST文件数量或者大小达到阈值时，会进行Compaction。之所以进行Compaction是因为如果所有SST文件位于L0层会有空间放大（space amplifications）和读放大（read amplifications）的问题。</p>
<p>空间放大是存储数据所用实际空间与逻辑上数据大小的比值。假设一个数据库需要 2 MB 磁盘空间来存储逻辑上的 1 MB 大小的键值对是，那么它的空间放大率是 2。类似地，读放大用来衡量用户执行一次逻辑上的读操作，系统内所需进行的实际 IO 次数。</p>
<p>现在，让我们向数据库添加更多 key 并删除当中的一些 key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.delete(&quot;chipmunk&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;5&quot;)</span><br><span class="line">db.put(&quot;raccoon&quot;, &quot;6&quot;)</span><br><span class="line">db.put(&quot;zebra&quot;, &quot;7&quot;)</span><br><span class="line">// Flush triggers</span><br><span class="line">db.delete(&quot;raccoon&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;8&quot;)</span><br><span class="line">db.put(&quot;zebra&quot;, &quot;9&quot;)</span><br><span class="line">db.put(&quot;duck&quot;, &quot;10&quot;)</span><br></pre></td></tr></table></figure>

<img src="RocksDB是什么/img5.png"  >

<p>随着我们的不断写入，<code>MemTable </code>不断被刷到磁盘，L0 上的<code> SST 文件</code>数量也在增长：</p>
<ul>
<li>删除或更新 key 所占用的空间永远不会被回收。例如，<code>cat</code> 这个 key 的三次更新记录分别在 SST1，SST2 和 SST3 中，而 <code>chipmunk</code> 在 SST1 中有一次更新记录，在 SST2 中有一次删除记录，这些无用的记录仍然占用额外磁盘空间。</li>
<li>随着 L0 上 SST 文件数量的增加，读取变得越来越慢。每次查找都要逐个检查所有 SST 文件。</li>
</ul>
<p>RocksDB 引入了Compaction 机制，可以降低空间放大和读放大，但代价是更高的写放大。Compaction 会将某层的 SST 文件同下一层的 SST 文件合并，并在这个过程中丢弃已删除和被覆盖的无效 key。Compaction 会在后台专用的线程池中运行，从而保证了 RocksDB 可以在做 Compaction 时能够正常处理用户的读写请求。</p>
<img src="RocksDB是什么/img6.png"  >

<p><code>Level Style Compaction</code>是 RocksDB 中的默认 Compaction 策略。使用<code> Level Style Compaction</code>，L0 层中的不同<code>SST 文件</code>键范围会重叠。L1 层及以下层会被组织为包含多个 <code>SST 文件</code>的序列，并保证同层级内的所有 SST 在键范围上没有交叠，且 <code>SST 文件</code>之间有序。Compaction 时，会选择性地将某层的<code> SST 文件</code>与下一层的 key 范围有重叠 <code>SST 文件</code>进行合并。</p>
<p>举例来说，如下图所示，在 L0 到 L1 层进行 Compaction 时，如果 L0 上的输入文件覆盖整个键范围，此时就需要对所有 L0 和 L1 层的文件进行 Compaction。</p>
<img src="RocksDB是什么/img7.png"  >

<p>而像是下面的这种 L1 和 L2 层的 Compaction，L1 层的输入文件只与 L2 层的两个 SST 文件重叠，因此，只需要对部分文件进行 Compaction 即可。</p>
<img src="RocksDB是什么/img8.png"  >

<p>当 L0 层上的 SST 文件数量达到一定阈值（默认为 4）时，将触发 Compaction。对于 L1 层及以下层级，当整个层级的 SST 文件总大小超过配置的目标大小时，会触发 Compaction 。当这种情况发生时，可能会触发 L1 到 L2 层的 Compaction。从而，从 L0 到 L1 层的 Compaction 可能会引发一直到最底层级联 Compaction。在 Compaction 完成之后，RocksDB 会更新元数据并从磁盘中删除已经被 Compcated 过的文件。</p>
<p><em>注：RocksDB 提供了不同 Compaction 策略来在空间、读放大和写放大之间进行权衡</em>。</p>
<h3 id="1-2-4-写路径"><a href="#1-2-4-写路径" class="headerlink" title="1.2.4 写路径"></a>1.2.4 写路径</h3><p>1，(可选) 当收到一个写请求时，会先把该条数据append方式写到WAL文件，用作故障恢复。</p>
<p>2，当写完WAL后，会把该条数据写入内存的MemTable，随即返回写成功。</p>
<p>3，当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的MemTable，同时为了不阻塞写操作生成一个新MemTable。</p>
<p>4，有后台线程把内存里不可变的Memtable给flush到磁盘，生成L0 SST文件。</p>
<p>5，从 L0 到 L1 层的 Compaction 可能会引发一直到最底层级联 Compaction。在 Compaction 完成之后，RocksDB 会更新元数据并从磁盘中删除已经被 Compcated 过的SST文件。</p>
<h3 id="1-2-5-读路径"><a href="#1-2-5-读路径" class="headerlink" title="1.2.5 读路径"></a>1.2.5 读路径</h3><ol>
<li>检索 MemTable。</li>
<li>检索所有不可变 MemTable。</li>
<li>搜索最近 flush 过的 L0 层中的所有 SST 文件。</li>
<li>对于 L1 层及以下层级，首先找到可能包含该 key 的单个 SST 文件，然后在文件内进行搜索。</li>
</ol>
<p>搜索 SST 文件涉及：</p>
<ol>
<li>（可选）探测布隆过滤器。</li>
<li>查找 index 来找到可能包含这个 key 的 block 所在位置。</li>
<li>读取 block 文件并尝试在其中找到 key。</li>
</ol>
<h2 id="1-3-概述"><a href="#1-3-概述" class="headerlink" title="1.3 概述"></a>1.3 概述</h2><h3 id="列族-Column-Families"><a href="#列族-Column-Families" class="headerlink" title="列族(Column Families)"></a>列族(Column Families)</h3><p>RocksDB支持将一个数据库实例按照许多列族进行分片。所有数据库创建的时候都会有一个用”default”命名的列族，如果某个操作不指定列族，他将操作这个default列族。<strong>不同的列族共享WAL，独享SST和MemTable，所以Column Family起到了一定的逻辑和资源隔离的作用</strong>。</p>
<p>RocksDB在开启WAL的时候保证即使crash，列族的数据也能保持一致性。它还通过 API 支持跨列族的原子操作<code>WriteBatch</code>。</p>
<h3 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h3><p>API<code>Put</code>将单个键值插入数据库。如果数据库中已存在该键，则将覆盖先前的值。API<code>Write</code>允许在数据库中原子地插入、更新或删除多个键值。数据库保证一次<code>Write</code>调用中的所有键值都将插入数据库，或者一个键值也不会插入数据库。如果数据库中已存在任何这些键，则将覆盖先前的值。API<a href="https://github.com/facebook/rocksdb/wiki/DeleteRange"><code>DeleteRange</code></a>可用于删除某个范围内的所有键。</p>
<h3 id="Gets-Iterators-and-Snapshots"><a href="#Gets-Iterators-and-Snapshots" class="headerlink" title="Gets,Iterators and Snapshots"></a>Gets,Iterators and Snapshots</h3><p>键和值被视为纯字节流。键或值的大小没有限制。<code>Get</code>API 允许应用程序从数据库中提取单个键值。<code>MultiGet</code>API 允许应用程序从数据库检索一组键。使用<code>MultiGet</code>获取的多个键值对将保证在同一时间点的一致性。</p>
<p>数据库中的所有数据都按逻辑顺序排列。应用程序可以定义一种键比较方法，用来指定键的排序规则。<code>Iterator</code> API允许对数据库做range scan 。<code>Iterator</code>可以查找指定的键，然后可以从该点开始一次扫描一个键。。Iterator API还可以用于对数据库中的键进行反向迭代。<strong>在创建<code>Iterator</code>时会创建数据库的一致时间点视图，因此，通过Iterator返回的所有键都来自数据库的一致视图。</strong></p>
<p><a href="https://github.com/facebook/rocksdb/wiki/Snapshot"><code>Snapshot</code></a>API允许应用程序创建数据库的时间点视图。<code>Get</code>和<code>Iterator</code>API 可用于从指定的snapshot读取数据。<code>Snapshot</code>和 <code>Iterator</code>都提供了数据库的时间点视图，但它们的实现不同。<strong>短期&#x2F;前台扫描最好通过迭代器完成，而长时间&#x2F;后台扫描最好通过快照完成</strong>。 <code>Iterator</code>会对整个指定时间点的数据库相关文件保留一个引用计数，这些文件在iterator释放前，都不会被删除。另一方面，snapshot不会阻止文件删除；相反，compaction过程知道snapshot存在，并承诺永远不会删除在任何现有快照中可见的key。</p>
<p><code>Snapshot</code>在数据库重启后不会保留：reload RocksDB库会释放所有之前创建好的snapshot。</p>
<h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><p>RocksDB支持多操作事务。它支持乐观模式和悲观模式。参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvaG56ZW5nL3JvY2tzZGItZG9jLWNuL2Jsb2IvbWFzdGVyL2RvYw==">事务<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="前缀迭代器-Prefix-Iterators"><a href="#前缀迭代器-Prefix-Iterators" class="headerlink" title="前缀迭代器(Prefix Iterators)"></a>前缀迭代器(Prefix Iterators)</h3><p>大多数 LSM-tree 引擎无法支持高效的range scan  API，因为它需要查看多个数据文件。但是，大多数应用程序不会对数据库中的键进行纯随机范围扫描；相反，应用程序通常只扫描指定前缀的键。RocksDB 利用了这一点。应用程序可以配置<code>Options.prefix_extractor</code>以启用基于键前缀的过滤。启用后，会将前缀的hash添加到布隆过滤器（Bloom Filter）中。指定了键前缀的<code>Iterator</code>(在ReadOptions中)将使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Sb2Nrc0RCLUJsb29tLUZpbHRlcg==">布隆过滤器<i class="fa fa-external-link-alt"></i></span>来避免查找不包含指定键前缀的数据文件。参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9QcmVmaXgtU2Vlaw==">前缀查找<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="持久性-Persistence"><a href="#持久性-Persistence" class="headerlink" title="持久性(Persistence)"></a>持久性(Persistence)</h3><p>RocksDB 有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Xcml0ZS1BaGVhZC1Mb2ctKFdBTCk=">预写日志 (WAL)<i class="fa fa-external-link-alt"></i></span>。所有写入操作（<code>Put</code>、<code>Delete</code>和<code>Merge</code>）都存储在名为 memtable 的内存缓冲区中，也可以选择性地写入 WAL。重新启动时，它会重新处理日志中记录的所有事务。</p>
<p>WAL 可以配置为存储在与 <strong>SST 文件</strong> 不同的目录中。这对于您可能希望将所有数据文件存储在非持久性快速存储中的情况是必要的。同时，您可以通过将所有事务日志放在较慢但持久的存储上来确保不会丢失数据。</p>
<p>每次<code>Put</code>都有一个标志位，通过WriteOptions来设置，允许指定这个Put操作是不是需要写事务日志。WriteOptions同时允许指定在<code>Put</code>返回成功前，是不是需要调用<code>fsync</code>。</p>
<p>在内部，RocksDB 使用批量提交机制将事务批量放入日志中，以便它可以使用单个<code>fsync</code>调用提交多个事务。</p>
<h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>RocksDB 使用校验和来检测存储中的损坏。每个 <strong>SST 文件块</strong>（通常大小在 <strong>4KB 到 128KB</strong> 之间）都会有一个单独的校验和。块一旦写入存储，就不再做修改。RocksDB 还维护完整的文件校验和（请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9GdWxsLUZpbGUtQ2hlY2tzdW0tYW5kLUNoZWNrc3VtLUhhbmRvZmY=">完整文件校验和和校验和切换<i class="fa fa-external-link-alt"></i></span>）以及可选的<span class="exturl" data-url="aHR0cDovL3JvY2tzZGIub3JnL2Jsb2cvMjAyMi8wNy8xOC9wZXIta2V5LXZhbHVlLWNoZWNrc3VtLmh0bWw=">每个键值校验和<i class="fa fa-external-link-alt"></i></span>。</p>
<p>RocksDB 动态检测并利用 CPU 校验和卸载支持。</p>
<h3 id="Multi-Threaded-Compactions"><a href="#Multi-Threaded-Compactions" class="headerlink" title="Multi-Threaded Compactions"></a>Multi-Threaded Compactions</h3><p>在存在持续写入的情况下，需要进行compactions以提高空间效率、读取（查询）效率和及时删除数据。Compaction会删除已删除或覆盖的键值，并重新组织数据以提高查询效率。如果配置的话，Compactions 可能会在多个线程中同时进行。</p>
<p>整个数据库存储在一组<strong>SST文件</strong>中。当<strong>memtable</strong>写满时，其内容将写入 LSM-tree的 Level-0 (L0) 文件中。RocksDB 在将<strong>memtable</strong> 刷新到 L0 文件中时，会删除重复和覆盖的键。在compaction中，一些文件会定期读入并合并以形成更大的文件，通常会进入下一个 LSM 级别（例如 L1，直到 Lmax）。</p>
<p>LSM 数据库的整体写入吞吐量直接取决于compaction发生的速度，尤其是当数据存储在 SSD 或 RAM 等快速存储中时。RocksDB 可以配置为从多个线程发出并发compaction请求。据观察，当数据库位于 SSD 上时，与单线程compaction相比，多线程compaction可以将持续写入速率提高10倍。</p>
<h3 id="Compaction-Styles"><a href="#Compaction-Styles" class="headerlink" title="Compaction Styles"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wYWN0aW9u">Compaction Styles<i class="fa fa-external-link-alt"></i></span></h3><p><code>Level Style Compaction</code>和<code>Universal Style Compaction</code>都将数据存储在数据库中固定数量的逻辑级别中。较新的数据存储在级别 0 (L0) 中，较旧的数据存储在编号较高的级别中，最高可达 Lmax。<strong>L0中的文件可能会有重叠的键，但其他级别的文件通常会在每个级别上单独排序</strong>。</p>
<p><code>Level Style Compaction</code>（默认）通常通过最小化每个Compaction步骤中涉及的文件来优化磁盘占用空间与逻辑数据库大小（空间放大）：将 Ln 中的一个文件与 Ln+1 中的所有重叠文件合并，并用 Ln+1 中的新文件替换它们。</p>
<p><code>Universal Style Compaction</code>通常通过一次合并多个文件和级别来优化写入磁盘的总字节数与逻辑数据库大小（写入放大），从而需要更多临时空间。与<code>Level Style Compaction</code>相比，<code>Universal Style Compaction</code>通常会导致写放大更低，但空间和读放大更高。</p>
<p><code>FIFO Style Compaction</code>会删除过时的旧文件，并可用于类似缓存的数据。在FIFO compaction中，所有文件都在L0级。当数据的总大小超过配置的大小（CompactionOptionsFIFO::max_table_files_size）时，我们删除最旧的<code>SST文件</code>。</p>
<p>我们还允许开发人员开发和测试自定义compaction策略。为此，RocksDB有适当的钩子来关闭内建的compaction算法，然后使用其他API来允许应用使用他们自己的compaction算法。<code>Options.disable_auto_compaction</code>如果设置，则关闭内建的compaction算法。<code>GetLiveFilesMetaData</code> API允许外部组件查看数据库中的每个数据文件，并决定要merge和compaction哪些数据文件。调用<code>CompactFiles</code>以compaction您想要的文件。该<code>DeleteFile</code>API 允许应用程序删除被视为过时的数据文件。</p>
<h3 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h3><p>清单日志文件用于记录数据库所有状态变化。<code>compaction</code>过程中会在数据库中添加新文件和删除原有文件，并通过将这些操作记录在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9NQU5JRkVTVA==">MANIFEST<i class="fa fa-external-link-alt"></i></span>中来使这些操作持久化。</p>
<h3 id="Avoiding-Stalls"><a href="#Avoiding-Stalls" class="headerlink" title="Avoiding Stalls"></a>Avoiding Stalls</h3><p>后台<code>compaction</code>线程还用于将<code>memable</code>的内容flush到存储上的文件中。如果所有后台<code>compaction</code>线程都长时间忙于compaction，突发性的写操作可能很快填满<code>memable</code>，从而阻塞新的写入。可以通过配置 RocksDB 来保留一小组线程，专门用于将<code>memable</code> flush到存储，从而避免这种情况。</p>
<h3 id="Compaction-Filter"><a href="#Compaction-Filter" class="headerlink" title="Compaction Filter"></a>Compaction Filter</h3><p>某些应用程序可能希望在<code>compaction</code>时处理键，例如根据 TTL 删除过期的键、在后台删除一定范围的键、更新现有键的值。这可以通过应用程序定义的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wYWN0aW9uLUZpbHRlcg==">Compaction Filter<i class="fa fa-external-link-alt"></i></span>来完成。</p>
<h3 id="只读模式"><a href="#只读模式" class="headerlink" title="只读模式"></a>只读模式</h3><p>数据库可以以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9SZWFkLW9ubHktYW5kLVNlY29uZGFyeS1pbnN0YW5jZXM=">只读模式<i class="fa fa-external-link-alt"></i></span>打开，在该模式下，数据库保证应用程序无法修改任何数据。这大大提高了读取性能，因为避免了一些锁机制。</p>
<h3 id="数据库调试日志"><a href="#数据库调试日志" class="headerlink" title="数据库调试日志"></a>数据库调试日志</h3><p>默认情况下，RocksDB将详细日志写入名为<code>LOG*</code>的文件。这些日志主要用于调试和分析正在运行的系统。用户可以选择不同的日志级别（参见 <code>DBOptions.info_log_level</code>）。日志文件可以配置为按照指定的周期进行滚动。日志接口是可插拔的，用户可以选择使用不同的记录器，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Mb2dnZXI=">记录器<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="Data-Compression"><a href="#Data-Compression" class="headerlink" title="Data Compression"></a>Data Compression</h3><p>RocksDB 支持 lz4、zstd、snappy、zlib 和 lz4_hc压缩，以及 Windows 下的 xpress。RocksDB可以为不同level的<code>SST文件</code>配置不同的压缩算法。请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wcmVzc2lvbg==">压缩<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="全量备份与复制"><a href="#全量备份与复制" class="headerlink" title="全量备份与复制"></a>全量备份与复制</h3><p>RocksDB 提供了<code>BackupEngine</code> API进行备份，可参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Ib3ctdG8tYmFja3VwLVJvY2tzREI=">How to backup RocksDB<i class="fa fa-external-link-alt"></i></span>。</p>
<p>RocksDB 本身不是复制的，但它提供了一些辅助函数，使用户能够在 RocksDB 之上实现自己的复制系统，可参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9SZXBsaWNhdGlvbi1IZWxwZXJz">Replication Helpers<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="支持同一个进程打开多个数据库"><a href="#支持同一个进程打开多个数据库" class="headerlink" title="支持同一个进程打开多个数据库"></a>支持同一个进程打开多个数据库</h3><p>RocksDB 的一个常见用法是应用程序将数据集划分为逻辑分区或分片。此技术有利于应用程序负载均衡以及快速故障恢复。这意味着单个进程应能同时操作多个RocksDB数据库。这是通过一个名为<code>Env</code>的对象完成的。除此之外，线程池与<code>Env</code>相关联，如果想在多个数据库实例之间共享一个公共线程池（用于后台compaction），那么它应该使用同一个<code>Env</code>对象来打开这些数据库。</p>
<p>类似地，多个数据库实例可以共享相同的块缓存或速率限制器。</p>
<h3 id="Block-Cache"><a href="#Block-Cache" class="headerlink" title="Block Cache"></a>Block Cache</h3><p>RocksDB对block使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9CbG9jay1DYWNoZQ==">LRU<i class="fa fa-external-link-alt"></i></span>做读缓存。 block cache分为两个单独的cache：第一个缓存未压缩的block，第二个缓存在内存中压缩的block。如果配置了压缩block缓存，用户可能希望启用direct I&#x2F;O ，以防止在操作系统的页缓存中缓存相同的数据。</p>
<h3 id="Table-Cache"><a href="#Table-Cache" class="headerlink" title="Table Cache"></a>Table Cache</h3><p>Table Cache是缓存打开的文件描述符的结构。这些文件描述符用于<strong>sstfiles</strong>。应用程序可以指定Table Cache的最大大小，或将 RocksDB 配置为始终保持所有文件打开状态，以提高性能。</p>
<h3 id="I-O-Control"><a href="#I-O-Control" class="headerlink" title="I&#x2F;O Control"></a>I&#x2F;O Control</h3><p>RocksDB允许用户以不同的方式配置从<code>SST文件</code>或到<code>SST文件</code>的I&#x2F;O。用户可以启用direct I&#x2F;O，以便RocksDB完全控制I&#x2F;O和缓存。另一种方法是利用一些选项允许用户提示应该如何执行I&#x2F;O。他们可以建议RocksDB在读取文件时调用 <code>fadvise</code>，在正在追加数据的文件中定期调用 range sync。有关更多详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9JTw==">IO<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvaG56ZW5nL3JvY2tzZGItZG9jLWNuL2Jsb2IvbWFzdGVyL2RvYw==">https://github.com/johnzeng/rocksdb-doc-cn/blob/master/doc<i class="fa fa-external-link-alt"></i></span>)</p>
<h3 id="StackableDB"><a href="#StackableDB" class="headerlink" title="StackableDB"></a>StackableDB</h3><p>RocksDB 具有内置的包装器机制，可以在数据库核心代码之上添加额外的功能，这些功能通过<code>StackableDB</code>API封装。例如，TTL功能是由<code>StackableDB</code>接口实现的，并不是RocksDB核心API的一部分，这种方法使代码保持模块化和干净。</p>
<h3 id="Merge-Operator"><a href="#Merge-Operator" class="headerlink" title="Merge Operator"></a>Merge Operator</h3><p>RocksDB 原生支持三种类型的记录，即<code>Put</code>、<code>Delete</code>、<code>Merge</code>记录。当compaction过程遇到<code>Merge</code>时，它会调用应用程序指定的方法，称为合并运算符。合并可以将多个 Put 和 Merge 记录合并为一条记录。这个强大的功能允许通常执行读取-修改-写入的应用程序完全避免读取。它允许应用程序将操作意图记录为<code>Merge</code>记录，而 RocksDB compaction过程会将该意图延迟应用于原始值。此功能在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9NZXJnZS1PcGVyYXRvcg==">合并运算符中有详细描述<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="DB-ID"><a href="#DB-ID" class="headerlink" title="DB ID"></a>DB ID</h3><p>数据库创建时创建的全局唯一ID，默认存储在 DB 文件夹中的 <code>IDENTITY</code>文件中。可选地，它只存储在<code>MANIFEST</code>文件中。建议存储在 <code>MANIFEST </code>文件中。</p>
<h2 id="1-4-工具"><a href="#1-4-工具" class="headerlink" title="1.4 工具"></a>1.4 工具</h2><p>有许多有趣的工具用于支持生产环境中的数据库。<code>sst_dump</code>程序转储<code>sst文件</code>中的所有键值，以及其他信息。<code>ldb</code>工具可以put, get，s can数据库的内容。<code>ldb</code>还可以转储<code>MANIFEST</code>的内容，它还可以用来修改数据库配置的层级数。有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9BZG1pbmlzdHJhdGlvbi1hbmQtRGF0YS1BY2Nlc3MtVG9vbA==">管理和数据访问工具<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="1-5-LevelDB-所没有的特性"><a href="#1-5-LevelDB-所没有的特性" class="headerlink" title="1.5 LevelDB 所没有的特性"></a>1.5 LevelDB 所没有的特性</h2><p><strong>Performance</strong>：</p>
<ul>
<li>Multithread compaction</li>
<li>Multithread memtable inserts</li>
<li>Reduced DB mutex holding</li>
<li>Optimized level-based compaction style and universal compaction style</li>
<li>Prefix bloom filter</li>
<li>Memtable bloom filter</li>
<li>Single bloom filter covering the whole SST file</li>
<li>Write lock optimization</li>
<li>Improved Iter::Prev() performance</li>
<li>Fewer comparator calls during SkipList searches</li>
<li>Allocate memtable memory using huge page.</li>
</ul>
<p><strong>Features</strong>：</p>
<ul>
<li>Column Families</li>
<li>Transactions and WriteBatchWithIndex</li>
<li>Backup and Checkpoints</li>
<li>Merge Operators</li>
<li>Compaction Filters</li>
<li>RocksDB Java</li>
<li>Manual Compactions Run in Parallel with Automatic Compactions</li>
<li>Persistent Cache</li>
<li>Bulk loading</li>
<li>Forward Iterators&#x2F; Tailing iterator</li>
<li>Single delete</li>
<li>Delete files in range</li>
<li>Pin iterator key&#x2F;value</li>
</ul>
<p><strong>Alternative Data Structures And Formats</strong>：</p>
<ul>
<li>Plain Table format for memory-only use cases</li>
<li>Vector-based and hash-based memtable format</li>
<li>Clock-based cache (coming soon)</li>
<li>Pluggable information log</li>
<li>Annotate transaction log write with blob (for replication)</li>
</ul>
<p><strong>Tunability</strong>：</p>
<ul>
<li>Rate limiting</li>
<li>Tunable Slowdown and Stop threshold</li>
<li>Option to keep all files open</li>
<li>Option to keep all index and bloom filter blocks in block cache</li>
<li>Multiple WAL recovery modes</li>
<li>Fadvise hints for readahead and to avoid caching in OS page cache</li>
<li>Option to pin indexes and bloom filters of L0 files in memory</li>
<li>More Compression Types: zlib, lz4, zstd</li>
<li>Compression Dictionary</li>
<li>Checksum Type: xxhash</li>
<li>Different level size multiplier and compression type for each level.</li>
</ul>
<p><strong>Manageability</strong>：</p>
<ul>
<li>Statistics</li>
<li>Thread-local profiling</li>
<li>More commands in command-line tools</li>
<li>User-defined table properties</li>
<li>Event listeners</li>
<li>More DB Properties</li>
<li>Dynamic option changes</li>
<li>Get options from a string or map</li>
<li>Persistent options to option files</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraQ==">RocksDB Wiki<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucXRtdW5pYW8uY29tLzIwMjMvMDYvMDUvaG93LXJvY2tzZGItd29ya3M=">RocksDB运行原理<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDQxODM1">深入理解什么是LSM-Tree<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>RocksDB</category>
      </categories>
      <tags>
        <tag>RocksDB</tag>
        <tag>LSM-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>qcow2文件格式</title>
    <url>/qcow2%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-qcow2是什么"><a href="#1-1-qcow2是什么" class="headerlink" title="1.1 qcow2是什么"></a>1.1 qcow2是什么</h2><p><code>qcow2</code> 是一种虚拟磁盘镜像格式，全称是 “QEMU Copy-On-Write version 2”。它可以用一个文件的形式来表示一块固定大小的块设备磁盘。</p>
<ul>
<li><p><strong>动态分配</strong>：qcow2 支持按需分配空间，不会立即占用所有磁盘容量，而是随着数据写入逐渐扩展大小，节省存储空间。</p>
</li>
<li><p><strong>支持快照</strong>：qcow2 格式允许创建快照。</p>
</li>
<li><p><strong>压缩和加密</strong>：qcow2 格式支持对数据进行压缩以减少磁盘空间，并可以启用AES加密来保护镜像数据的安全。</p>
</li>
<li><p><strong>写时复制（Copy-On-Write, COW）</strong>：这意味着只有在镜像文件上有新的写操作时，才会实际改变文件内容，这样可以更高效地使用磁盘空间。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h2><table>
<thead>
<tr>
<th align="left">术语</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">offset</td>
<td align="left">相对于qcow2文件(img)起始处的偏移量</td>
</tr>
<tr>
<td align="left">cluster</td>
<td align="left">qcow2文件由固定大小的单元组成，该单元称为cluster，默认大小为65536bytes&#x2F;64K</td>
</tr>
<tr>
<td align="left">sector</td>
<td align="left">数据块读写的最小单元，大小为512字节</td>
</tr>
<tr>
<td align="left">host cluster</td>
<td align="left">Host上qcow2文件的cluster</td>
</tr>
<tr>
<td align="left">guest cluster</td>
<td align="left">Guest上virtual disk的cluster</td>
</tr>
<tr>
<td align="left">qcow2 header</td>
<td align="left">qcow2文件的头信息，占用第一个cluster</td>
</tr>
<tr>
<td align="left">refcount</td>
<td align="left">qcow2内部用于管理cluster的分配而维护的引用计数</td>
</tr>
<tr>
<td align="left">refcount table</td>
<td align="left">用于查找refcount的第一级表</td>
</tr>
<tr>
<td align="left">refcount block</td>
<td align="left">用于查找refcount的第二级表</td>
</tr>
<tr>
<td align="left">L1 table</td>
<td align="left">用于查找guest cluster到host cluster映射的第一级表</td>
</tr>
<tr>
<td align="left">L2 table</td>
<td align="left">用于查找guest cluster到host cluster映射的第二级表</td>
</tr>
<tr>
<td align="left">IBA</td>
<td align="left">image block address</td>
</tr>
<tr>
<td align="left">VBA</td>
<td align="left">virtual block address</td>
</tr>
</tbody></table>
<h2 id="1-3-qcow2文件格式"><a href="#1-3-qcow2文件格式" class="headerlink" title="1.3 qcow2文件格式"></a>1.3 qcow2文件格式</h2><p><span style="color: red;">qcow2中所有数字按大端字节序存储</span></p>
<h2 id="1-3-1-文件头"><a href="#1-3-1-文件头" class="headerlink" title="1.3.1 文件头"></a>1.3.1 文件头</h2><p>qcow2文件的第一个cluster包含文件头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QCowHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic; <span class="comment">// &quot;QFI\xfb&quot; 4个字节固定的标识符</span></span><br><span class="line">    <span class="type">uint32_t</span> version; <span class="comment">// 版本, 2 或 3</span></span><br><span class="line">    <span class="type">uint64_t</span> backing_file_offset; <span class="comment">// 存放后备文件路径的offset，这个字符串不是以0结束的。该值为0时，不是无后备文件</span></span><br><span class="line">    <span class="type">uint32_t</span> backing_file_size; <span class="comment">//  后备文件路径字符串长度，单位是字节数。必须小于1023字节。没有后备文件时，该值无意义</span></span><br><span class="line">    <span class="type">uint32_t</span> cluster_bits; <span class="comment">// cluster_size =  1 &lt;&lt; cluster_bits，该值不能小于9，即cluster大小不能小于512字节</span></span><br><span class="line">    <span class="type">uint64_t</span> size; <span class="comment">// 虚拟磁盘的大小，不是该qcow2文件实际占用空间大小</span></span><br><span class="line">    <span class="type">uint32_t</span> crypt_method; <span class="comment">// 0：未加密；1： AES加密</span></span><br><span class="line">    <span class="type">uint32_t</span> l1_size; <span class="comment">// L1表的entry数目</span></span><br><span class="line">    <span class="type">uint64_t</span> l1_table_offset; <span class="comment">// L1表在img中的偏移量，必须与cluster对齐</span></span><br><span class="line">    <span class="type">uint64_t</span> refcount_table_offset;  <span class="comment">// refcount table在img中的偏移量，必须与cluster对齐</span></span><br><span class="line">    <span class="type">uint32_t</span> refcount_table_clusters;<span class="comment">// refcount table占用了多少个cluster</span></span><br><span class="line">    <span class="type">uint32_t</span> nb_snapshots;           <span class="comment">//snapshot的个数</span></span><br><span class="line">    <span class="type">uint64_t</span> snapshots_offset;       <span class="comment">//snapshot在img的offset，必须与cluster对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are only valid for version &gt;= 3 */</span></span><br><span class="line">    <span class="type">uint64_t</span> incompatible_features;</span><br><span class="line">    <span class="type">uint64_t</span> compatible_features;</span><br><span class="line">    <span class="type">uint64_t</span> autoclear_features;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> refcount_order; <span class="comment">// refcount_block表中entry大小= 1 &lt;&lt; refcount_orde。单位为bits。 版本为2时总是假设值为4，也就是说一个entry大小为2字节</span></span><br><span class="line">    <span class="type">uint32_t</span> header_length; <span class="comment">// 文件头结构体的大小，版本2时总是假设值为72 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-2-文件头扩展"><a href="#1-3-2-文件头扩展" class="headerlink" title="1.3.2 文件头扩展"></a>1.3.2 文件头扩展</h2><p>在文件头之后，可以存储称为文件头扩展的可选部分，每个扩展都有如下结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qcow2UnknownHeaderExtension</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    QLIST_ENTRY(Qcow2UnknownHeaderExtension) next;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; Qcow2UnknownHeaderExtension;</span><br></pre></td></tr></table></figure>

<p>Qcow2UnknownHeaderExtension结构说明:</p>
<pre><code>Byte  0 -  3:   Header extension type:
          0x00000000 - End of the header extension area
          0xE2792ACA - Backing file format name
          0x6803f857 - Feature name table
          other      - Unknown header extension, can be safely ignored
          
      4 -  7:   Header extension数据长度
      
      8 -  n:   Header extension数据部分
      
      n -  m:   为对齐到8字节的填充部分 
</code></pre>
<p>other - Unknown header extension, can be safely</p>
<p>ignored</p>
<p>4 - 7: header extension 的数据长度0000 0005 5byte</p>
<p>8 - n: Header extension数据部分 7163 6f77 32</p>
<p>n - m: 为对齐到 8字节的填充部分 00 0000</p>
<p><span style="color: red;">注意:  除非特别说明，否则每个Header extension type只能在image中出现一次</span></p>
<h3 id="1-3-3-backing-file-name"><a href="#1-3-3-backing-file-name" class="headerlink" title="1.3.3 backing file name"></a>1.3.3 backing file name</h3><p>头扩展区域的末尾和第一个cluster的末尾之间的剩余空间可用于存放后备文件路径名。</p>
<h2 id="1-4-qcow2文件格式"><a href="#1-4-qcow2文件格式" class="headerlink" title="1.4 qcow2文件格式"></a>1.4 qcow2文件格式</h2><p>refcount table&#x2F;refcount block&#x2F;l1&#x2F;l2的顺序关系不限</p>
<img src="qcow2文件格式/qcow2文件格式.png">

<h1 id="二、Host-cluster-management"><a href="#二、Host-cluster-management" class="headerlink" title="二、Host cluster management"></a>二、Host cluster management</h1><p>qcow2通过维护引用计数来管理Host cluster的分配。refcount为0表示cluster 空闲，1表示cluster已被使用，&gt;&#x3D;2表示cluster已被使用并且任何写访问都必须执行COW操作。引用计数通过二级表进行管理。</p>
<p><strong>refcount table</strong></p>
<ul>
<li>其大小是可变的，以cluster为单位分配</li>
<li>若分配多个cluster，则占用空间必须是连续的</li>
<li>每个entry大小为8字节，存放的是refcount block表的offset</li>
</ul>
<p><strong>refcount block</strong></p>
<ul>
<li>大小为1 cluster</li>
<li>每个entry大小为2字节，存放refcount</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定qcow2文件的offset，其cluster的refcount可以通过下列公式计算得出</span></span><br><span class="line"></span><br><span class="line">refcount_block_entries = (cluster_size / <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))</span><br><span class="line"></span><br><span class="line">refcount_block_index = (offset / cluster_size) % refcount_block_entries</span><br><span class="line">refcount_table_index = (offset / cluster_size) / refcount_block_entries</span><br><span class="line"></span><br><span class="line">refcount_block = load_cluster(refcount_table[refcount_table_index]);</span><br><span class="line"><span class="keyword">return</span> refcount_block[refcount_block_index];</span><br></pre></td></tr></table></figure>



<p><strong>refcount table entry</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bit  0 -  8:    Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">     9 - 63:    refcount block表在img中的offset，必须与cluster对齐。如果该值为0则表示还没分配</span><br><span class="line">     					  相应的refcount block，这个refcount block管理的所有refcount值为0</span><br></pre></td></tr></table></figure>



<p>**refcount block entry ** :</p>
<pre><code>x = refcount_bits - 1，refcount_bit值与qcow2 header中refcount_order变量有关

Bit  0 -  x:  cluster的refcount
</code></pre>
<h1 id="三、Cluster-mapping"><a href="#三、Cluster-mapping" class="headerlink" title="三、Cluster mapping"></a>三、Cluster mapping</h1><h2 id="3-1-为什么需要Cluster-mapping"><a href="#3-1-为什么需要Cluster-mapping" class="headerlink" title="3.1 为什么需要Cluster mapping"></a>3.1 为什么需要Cluster mapping</h2><p>以向一个空的qcow2文件写入数据为例，假设cluster大小为65536字节。</p>
<img src="qcow2文件格式/虚拟机写数据1.png">

<p>从前两次写操作来看，似乎虚拟机写入的数据与写入qcow2文件的数据成某种线性关系。起始为0，大小65536的数据写入第一个cluster中。起始为65536，大小65535的数据写入第二个cluster。如果第三次写起始为655360，大小65536数据？qcow2并不会把它放在第11个cluster中，而是放在第三个cluster中。<strong>这样qcow2就不会向raw一样产生空洞，qcow2文件随着不停的写入数据而慢慢变大。然而这样也同时打破了虚拟的地址偏移与qcow2的地址偏移的线形关系</strong>。</p>
<p>正是因为虚拟机写入的数据与写入到qcow2文件中的数据不成线性关系，因此qcow2 需要通过映射表查询cluster真实的存储位置。为此qcow2文件中通过L2 table来记录虚拟地址偏移与qcow2文件地址偏移的关系。L2 table中的每一项都是一个64位地址，存某个cluster在qcow2文件中的offset。</p>
<p><strong>guest cluster对应host cluster真实位置保存在L2 table的第N个元素中，其中N与guest cluster成线性关系。</strong></p>
<img src="qcow2文件格式/虚拟机写数据2.png" >

<p>一个qcow2文件以cluster为单位进行切分, L2 table记录guest cluster到host cluster的映射关系。一个L2 table大小等于一个cluster的大小。cluster默认大小是64K，即一个L2 table有8192个元素，可以管理512M大小空间。当超过512M大小的时候qcow2会新建一个L2 table，由于新建的L2 table与之前的L2 table地址不相邻（其实每一个L2 table只是qcow2文件中的一个cluster，每次新建一个L2 table也就是分配一个cluster）。所以qcow2没办法简单的记录它，因此产生 L1 table。 L1 table中每一个元素都指向一个L2 table的地址。L1 ta ble的地址保存在qcow2 header中。</p>
<img src="qcow2文件格式/Cluster_mapping.png"  style="zoom:50%;" >

<h2 id="3-2-L1-table与-L2-table"><a href="#3-2-L1-table与-L2-table" class="headerlink" title="3.2 L1 table与 L2 table"></a>3.2 L1 table与 L2 table</h2><p>与refcounts一样，qcow2使用二级表将guest cluster映射到host cluster。它们被称为L1 table和L2 table。</p>
<p><strong>L1 table</strong></p>
<ul>
<li>其大小是可变的，以cluster为单位分配</li>
<li>若分配多个cluster，则占用空间必须是连续的</li>
<li>entry个数等于qcow2 header中l1_size变量的值</li>
<li>每个entry大小为8字节，存放的是L2 table的offset</li>
</ul>
<p><strong>L2 table</strong></p>
<ul>
<li>大小为1 cluster</li>
<li>每个entry大小为8字节，存某个cluster在qcow2文件中的offset。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定虚拟磁盘的offset，其对应到qcow2文件的offset可以通过下列公式计算得出</span></span><br><span class="line"></span><br><span class="line"> l2_entries = (cluster_size / <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line"></span><br><span class="line"> l2_index = (offset / cluster_size) % l2_entries</span><br><span class="line"> l1_index = (offset / cluster_size) / l2_entries</span><br><span class="line"></span><br><span class="line"> l2_table = load_cluster(l1_table[l1_index]);</span><br><span class="line"> cluster_offset = l2_table[l2_index];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> cluster_offset + (offset % cluster_size)</span><br></pre></td></tr></table></figure>

<p><strong>L1 table entry</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bit   0 -  8:   Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">      9 - 55:   L2 table在img中的offset，必须与cluster对齐。如果该值为0则L2 table和</span><br><span class="line">     						该L2 table所描述的所有cluster都没分配</span><br><span class="line"></span><br><span class="line">     56 - 62:   Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">     			63:   0表示L2表没有被使用或者需要COW， 1表示它refcount正好是1。此信息仅在活跃的L1表中是准确的</span><br></pre></td></tr></table></figure>

<p><strong>L2 table entry</strong></p>
<pre><code>Bit  0 -  61:   Cluster descriptor

          62:   0 for standard clusters
                1 for compressed clusters

          63:   0表示未使用或需要COW的cluster，1表示它refcount正好是1。此信息仅在活动的L1表访问L2表中是准确的。
</code></pre>
<p>​    Standard Cluster Descriptor:<br>​<br>​        Bit       0:   如果为1，则从cluster读取时返回全0数据。这通常描述预分配，但它不会用于从cluster读取数据，如果集群末分										 配，也不会从后备文件读取致据。<br>​        							 With version 2, this is always 0.<br>​    </p>
<pre><code>         1 -  8:    Reserved (set to 0)

         9 - 55:    host cluster在img中的offset，必须与cluster对齐。如果该值为0则表示该cluster未分配。

        56 - 61:    Reserved (set to 0)
        
如果cluster未分配，读请求会从后备文件中获取数据(除非设置了Standard Cluster Descriptor中的第0位)。如果没有后备文件或后备文件小于image，则对后备文件未覆盖的所有部分一律读零
</code></pre>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qcow2</tag>
      </tags>
  </entry>
  <entry>
    <title>gtest 快速入门</title>
    <url>/gtest-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<p>前言：之前在工作中简单用过gtest，但当时项目比较赶时间，对测试并不是很重视。经常出现一个人改完代码后，模块之间出现bug情况，然后花很长时间排查bug。吸取教训后准备在新项目中引入gtest，花了两天时间学习了gtest文档，发现它功能还是蛮多的。准备整理一个gtest系列的专栏，也是检验自己学习成果。</p>
<h1 id="一、-gtest快速入门"><a href="#一、-gtest快速入门" class="headerlink" title="一、 gtest快速入门"></a>一、 gtest快速入门</h1><h2 id="1-1-gtest是什么"><a href="#1-1-gtest是什么" class="headerlink" title="1.1 gtest是什么"></a>1.1 gtest是什么</h2><p><code>gtest</code> 是 Google Test 的简称，是一个由 Google 开发与维护的 C++ 测试框架。它提供了丰富的断言和测试工具，帮助开发者编写更好的 C++ 测试代码。</p>
<span id="more"></span>

<p><strong>特点</strong>：</p>
<ul>
<li>丰富的断言：支持多种断言宏，如 <code>EXPECT_TRUE</code>、<code>ASSERT_TRUE</code> 等，便于验证测试结果。</li>
<li>支持多种测试结构：例如<code>TEST</code>、<code>TEST_F</code> 和 <code>TEST_P</code>等，以满足不同的测试场景。</li>
<li>自动生成测试报告：可指定生成xml、json格式测试报告</li>
<li>跨平台：支持 Windows、Linux、macOS 等多个平台。</li>
<li>与构建系统集成：可与 CMake、Bazel 等构建工具无缝集成。</li>
</ul>
<h2 id="1-2-构建一个gtest项目"><a href="#1-2-构建一个gtest项目" class="headerlink" title="1.2 构建一个gtest项目"></a>1.2 构建一个gtest项目</h2><p>我们可以直接从github上下载<code>gtest</code>作为一个独立项目来学习，也可将<code>gtest</code>合并到现有的项目中去。</p>
<p><strong>将gtest作为独立项目</strong></p>
<p><code>gtest</code>本身提供了许多示例供我们学习，示例代码位于<code>googletest/samples</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/googletest.git <span class="comment"># 下载gtest最新代码</span></span><br><span class="line"><span class="built_in">cd</span> googletest </span><br><span class="line"><span class="built_in">mkdir</span> build <span class="comment"># 创建编译目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake3 .. <span class="comment"># 如果想构建这些示例程序，需要加上 -Dgtest_build_samples=ON</span></span><br><span class="line">make </span><br></pre></td></tr></table></figure>

<p><strong>整合到现有的项目中</strong></p>
<p>修改现有项目的<code>CMakeLists.txt</code>文件，声明对<code>gtest</code> 的依赖关系。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">        googletest</span><br><span class="line">        URL https://github.com/google/googletest/archive/refs/tags/release-<span class="number">1.10</span>.<span class="number">0</span>.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br></pre></td></tr></table></figure>

<p>上述配置声明了对从 GitHub 下载的<code>gtest</code>依赖，1.10.0表示要下载的<code>gtest</code>版本，因为我系统上<code>gcc</code>编译器比较老，不支持c++ 14，所以我下的<code>gtest</code>版本较低，大家可以根据自身环境下载合适版本。</p>
<p>将 <code>gtest</code> 声明为依赖项后，便可以在自己的项目中使用<code>gtest</code>了。例如创建一个<code>hello_test.cc</code>的文件，测试计算阶乘的函数是否正确。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result *= i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, Negative)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-5</span>)); <span class="comment">// 测试-5的阶乘是否等于1</span></span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-1</span>)); <span class="comment">// 测试-1的阶乘是否等于1</span></span><br><span class="line">	<span class="built_in">EXPECT_GT</span>(<span class="built_in">Factorial</span>(<span class="number">-10</span>), <span class="number">0</span>); <span class="comment">// 测试-10的阶乘是否大于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gtest</code>提供了<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcHJpbWVyLmh0bWwjYXNzZXJ0aW9ucw==">一些断言<i class="fa fa-external-link-alt"></i></span>，您可以使用它们来测试代码的行为。上面的示例演示了一些基本断言，后面将会详细讲解这些断言的功能。</p>
<p>可以发现上述测试代码中没有<code>main</code>函数，那么怎么编译运行呢？我们只需要链接<code>gtest-main</code>库，它提供了一个默认的 <code>main</code> 函数实现，用于运行所有的测试。</p>
<p>要编译测试程序，请将以下内容添加到<code>CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        hello_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        gtest_main</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>现在，让我们运行测试程序看下效果吧，可以看到运行成功，所以断言都通过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test</span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from FactorialTest</span><br><span class="line">[ RUN      ] FactorialTest.Negative</span><br><span class="line">[       OK ] FactorialTest.Negative (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from FactorialTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure>

<h2 id="1-3-gtest入门"><a href="#1-3-gtest入门" class="headerlink" title="1.3 gtest入门"></a>1.3 gtest入门</h2><h3 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1 基本概念"></a>1.3.1 基本概念</h3><p><code>gtest</code>使用断言（Assertion）来检查某些条件是否为真，以此验证代码的行为，可以认为断言就是一个检查点。**断言的结果有成功、 非致命失败和致命失败三种。**当断言失败时，会打印断言所处的文件名与行号，以便我们快速定位错误位置。</p>
<p>在<code>gtest</code>中，断言主要分为两类，<strong><code>ASSERT_*</code>版本失败时会产生致命失败，并中止当前函数。<code>EXPECT_*</code>版本会产生非致命失败，不会中止当前函数</strong>。通常<code>EXPECT_*</code>是首选，因为它们允许在测试中报告多个错误。如果在某个断言失败后，后续测试代码继续运行没有任何意义则应使用<code>ASSERT_*</code>。</p>
<p>可以通过 <code>&lt;&lt;</code> 运算符向断言中添加自定义错误信息，当断言失败时，这些信息会显示在测试输出中，帮助快速定位问题。任何可以流式传输到<code>ostream</code>的内容都可以流式传入到断言中——特别是C风格字符串和C++ string对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ASSERT_EQ</span>(x.<span class="built_in">size</span>(), y.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++i) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个测试程序可以包含多个测试套件（test suite），一个测试套件包含一个或多个测试</strong>。应该将测试分组到能够反映测试代码结构的测试套件中。<strong>测试使用断言来验证测试代码的行为</strong>，如果测试崩溃或断言失败（不管是否为致命失败），则认为该测试失败；否则认为测试成功。</p>
<blockquote>
<p>已知限制：<code>gtest</code>的设计是线程安全的。在<code>pthread</code>库可用的系统上，实现是线程安全的。目前，在其他系统（例如Windows）上从两个线程并发地使用<code>gtest</code>断言是不安全的。在大多数测试中，这不是问题，因为断言通常在主线程中完成。如果您想提供帮助，您可以自愿为您的平台实现<code>gtest-port.h</code>中必要的同步原语。</p>
</blockquote>
<h3 id="1-3-2-TEST"><a href="#1-3-2-TEST" class="headerlink" title="1.3.2 TEST"></a>1.3.2 TEST</h3><p><code>TEST</code>是一个宏，用于定义<strong>测试套件（Test Suite）<strong>相关的测试。 <code>TEST</code>宏有两个参数，第一个参数是</strong>测试套件的名称</strong>，第二个参数是<strong>测试名称</strong>，两个名称都必须是有效的 C++ 标识符，并且<strong>不应包含任何下划线字符</strong>。测试的全名由测试套件+测试名组成。来自不同测试套件的测试名可以相同。</p>
<p>要创建测试：</p>
<ol>
<li>使用<code>TEST</code>宏定义并命名测试函数。这是一个没有返回值的 C++ 函数。</li>
<li>在此函数中，除了您想要包含的任何有效 C++ 语句外，还使用<code>gtest</code>提供的各种断言来检查条件是否满足。</li>
<li>测试结果由断言决定；如果测试中的任何断言失败（无论是致命的还是非致命的），或者测试崩溃，则整个测试失败。否则，测试成功。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestSuiteName, TestName) </span><br><span class="line">&#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们有一个计算阶乘的函数，此功能的测试套件可能如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result *= i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, HandlesEvenInput)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">4</span>), <span class="number">23</span>); <span class="comment">// 4的阶乘为24，使用EXPECT_EQ，非致命失败，该测试后续代码继续运行</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;t1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">6</span>), <span class="number">720</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, HandlesOddInput)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">3</span>), <span class="number">5</span>); <span class="comment">// 3的阶乘为6，使用ASSERT_EQ，致命失败，该测试后续代码不会运行</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;t2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">5</span>), <span class="number">120</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gtest</code>按测试套件对测试结果进行分组，因此逻辑上相关的测试应该在同一个测试套件中；换句话说，它们在<code>TEST</code>宏中第一个参数应该相同。在上面的例子中，我们有两个测试， <code>HandlesZeroInput</code>和<code>HandlesPositiveInput</code>，它们属于同一个测试<code>FactorialTest</code>。</p>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from FactorialTest</span><br><span class="line">[ RUN      ] FactorialTest.HandlesEvenInput</span><br><span class="line">/xxx/hello_test.cpp:18: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  Factorial(4)</span><br><span class="line">    Which is: 24</span><br><span class="line">  23</span><br><span class="line">t1</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesEvenInput (0 ms)</span><br><span class="line">[ RUN      ] FactorialTest.HandlesOddInput</span><br><span class="line">/xxx/hello_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  Factorial(3)</span><br><span class="line">    Which is: 6</span><br><span class="line">  5</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesOddInput (0 ms)</span><br><span class="line">[----------] 2 tests from FactorialTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 2 tests, listed below:</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesEvenInput</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesOddInput</span><br><span class="line"></span><br><span class="line"> 2 FAILED TESTS</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-TEST-F"><a href="#1-3-3-TEST-F" class="headerlink" title="1.3.3 TEST_F"></a>1.3.3 TEST_F</h3><p><code>TEST_F</code>是一个宏，用于定义<strong>测试夹具（Test Fixture）<strong>相关的测试。它是 <code>TEST</code> 宏的扩展（<code>_F</code>代表“Fixture”），允许在同一测试夹具的多个测试之间共享相同的配置和资源。使用 <code>TEST_F</code> 可以避免重复代码，并确保测试环境的一致性。<code>TEST</code>宏有两个参数，第一个参数是</strong>测试夹具的名称</strong>，第二个参数是<strong>测试名称</strong>，两个名称都必须是有效的 C++ 标识符，并且<strong>不应包含任何下划线字符</strong>。</p>
<p>要创建夹具：</p>
<ol>
<li>定义一个测试夹具类，它必须继承<code>testing::Test</code>类</li>
<li>在夹具类内部，声明您计划使用的任何资源。</li>
<li>如果有必要，编写一个默认构造函数或override <code>SetUp</code>函数初始化资源。</li>
<li>如果需要，请编写一个析构函数或override  <code>TearDown</code>函数来释放资源。要了解何时应使用构造函数&#x2F;析构函数以及何时应使用<code>SetUp()/TearDown()</code>，请阅读<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvZmFxLmh0bWwjQ3RvclZzU2V0VXA=">常见问题解答<i class="fa fa-external-link-alt"></i></span>。</li>
<li>如果需要，请定义要共享的测试子程序。</li>
</ol>
<p>当使用夹具时，使用<code>TEST_F()</code>而不是<code>TEST()</code>，因为它允许您访问测试夹具中的对象和子例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(TestFixtureClassName, TestName) </span><br><span class="line">&#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：对于使用<code>TEST_F</code>定义的每个测试，<code>gtest</code>将在运行时创建一个新的测试夹具对象，并调用<code>SetUp</code>函数初始化资源。运行完一个测试后，通过调用<code>TearDown</code>函数进行资源清理，然后删除这个对象。即同一测试夹具中的不同测试不会复用夹具对象，一个测试对夹具所做的任何更改都不会影响其他测试。</p>
<p>比如我们有个计算器类，要对它进行功能测试。我们希望每个测试都使用一些相同数据，并且不同测试之间互不影响，所以使用测试夹具，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试夹具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTest</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 在每个测试运行前调用，进行初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 初始化一个 Calculator 对象</span></span><br><span class="line">		calculator = <span class="keyword">new</span> <span class="built_in">Calculator</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Setting up the test environment.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在每个测试运行后调用，进行清理</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 删除 Calculator 对象，清理资源</span></span><br><span class="line">		<span class="keyword">delete</span> calculator;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Tearing down the test environment.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 共享的测试数据</span></span><br><span class="line">	<span class="type">int</span> x = <span class="number">2024</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">	Calculator *calculator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试加法功能</span></span><br><span class="line"><span class="built_in">TEST_F</span>(CalculatorTest, AddTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在 SetUp 中初始化了 calculator，可以直接使用它</span></span><br><span class="line">	<span class="type">int</span> result = calculator-&gt;<span class="built_in">add</span>(x, y);</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(result, <span class="number">2025</span>);  <span class="comment">// 验证加法是否正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试减法功能</span></span><br><span class="line"><span class="built_in">TEST_F</span>(CalculatorTest, SubtractTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在 SetUp 中初始化了 calculator，可以直接使用它</span></span><br><span class="line">	<span class="type">int</span> result = calculator-&gt;<span class="built_in">subtract</span>(x, y);</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(result, <span class="number">2023</span>);  <span class="comment">// 验证减法是否正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行测试程序时</p>
<ol>
<li><code>gtest</code>先创建一个CalculatorTest对象（我们称之为<code>t1</code>）</li>
<li>调用<code>SetUp</code>函数对计算器资源初始化，使用t1测试完加法功能后，调用<code>TearDown</code>清理资源，并删除t1对象</li>
<li>创建另一个对象重复上述步骤测试减法功能</li>
</ol>
<p>不过上面示例可以不override <code>SetUp</code>和<code>TearDown</code>，使用构造与析构函数也能实现一样功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from CalculatorTest</span><br><span class="line">[ RUN      ] CalculatorTest.AddTest</span><br><span class="line">Setting up the <span class="built_in">test</span> environment.</span><br><span class="line">Tearing down the <span class="built_in">test</span> environment.</span><br><span class="line">[       OK ] CalculatorTest.AddTest (0 ms)</span><br><span class="line">[ RUN      ] CalculatorTest.SubtractTest</span><br><span class="line">Setting up the <span class="built_in">test</span> environment.</span><br><span class="line">Tearing down the <span class="built_in">test</span> environment.</span><br><span class="line">[       OK ] CalculatorTest.SubtractTest (0 ms)</span><br><span class="line">[----------] 2 tests from CalculatorTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-编写main函数"><a href="#1-3-4-编写main函数" class="headerlink" title="1.3.4 编写main函数"></a>1.3.4 编写main函数</h3><p>在上文的所有示例中我们都没有编写<code>main</code>函数，而是链接<code>gtest-main</code>库，库中提供了一个默认 <code>main</code>函数，它会自动初始化测试框架并运行所有的测试，这在绝大多数情况下适用。</p>
<p>如果需要在测试运行之前执行一些无法在测试套件和测试夹具内表达的自定义操作，我们需要自己编写<code>main</code>函数，这个<code>main</code>函数通常包含以下步骤：</p>
<ol>
<li>测试运行前自定义操作</li>
<li>调用<code>::testing::InitGoogleTest</code>函数解析<code>gtest</code>可以识别的命令行参数（标志），这允许用户通过各种参数控制测试程序的行为</li>
<li>调用 <code>RUN_ALL_TESTS</code> 来运行所有的测试，如果所有测试运行成功返回0，否则返回1</li>
</ol>
<p>当调用该<code>RUN_ALL_TESTS</code>：</p>
<ul>
<li>保存所有<code>gtest</code> 标志的状态</li>
<li>为第一个测试创建一个测试夹具对象</li>
<li>调用<code>SetUp</code>初始化</li>
<li>在夹具对象上运行测试</li>
<li>调用<code>TearDown</code>清理</li>
<li>删除该对象</li>
<li>恢复所有<code>gtest</code>标志的状态。</li>
<li>对下一个测试重复上述步骤，直到所有测试都运行完毕。</li>
</ul>
<blockquote>
<p>重要提示：您不能忽略<code>RUN_ALL_TESTS</code>的返回值，否则将得到编译器错误。这样设计的理由是：自动测试服务应根据其退出码确定测试是否通过，而不是根据其<code>stdout</code>&#x2F;<code>stderr</code>输出；</p>
<p>另外，<code>RUN_ALL_TESTS</code>只应调用一次。多次调用会与某些高级<code>gtest</code>功能（例如线程安全 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCNkZWF0aC10ZXN0cw==">死亡测试<i class="fa fa-external-link-alt"></i></span>）相冲突。</p>
</blockquote>
<p>假设我们有一个全局的日志系统，需要在运行测试之前初始化日志配置，并在所有测试结束后关闭日志系统。这时，我们需要自定义 <code>main</code> 函数来完成这些操作，例如创建一个<code>hello_test.cc</code>的文件，文件内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个日志系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Logger initialized!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Logger shutdown!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, Test1)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, Test2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EXPECT_NE</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 main 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Logger::<span class="built_in">Initialize</span>(); <span class="comment">// 启动日志系统</span></span><br><span class="line"></span><br><span class="line">	::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv); <span class="comment">// 初始化 Google Test</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> r = <span class="built_in">RUN_ALL_TESTS</span>(); <span class="comment">// 运行所有测试</span></span><br><span class="line"></span><br><span class="line">	Logger::<span class="built_in">Shutdown</span>(); <span class="comment">// 自定义清理：关闭日志系统</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要编译测试程序，请将以下内容添加到<code>CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        hello_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        gtest <span class="comment"># 我们自己编写了main函数，所有链接gtest库而不是gtest_main库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-断言参考"><a href="#1-3-5-断言参考" class="headerlink" title="1.3.5 断言参考"></a>1.3.5 断言参考</h3><p><code>gtest</code>使用断言来验证代码行为，要使用断言，添加<code>#include &lt;gtest/gtest.h&gt;</code>。本节将列出<code>gtest</code>提供的所有断言，以后有需要可作参考。</p>
<p><code>gtest</code>提供的断言宏大多数是<code>EXPECT_*</code>和<code>ASSER_*</code>配对出现。当失败时，<code>EXPECT_*</code>宏会产生非致命失败并允许当前函数继续运行，而<code>ASSERT_*</code> 宏会产生致命失败并中止当前函数。</p>
<h4 id="1-3-5-1-布尔"><a href="#1-3-5-1-布尔" class="headerlink" title="1.3.5.1 布尔"></a>1.3.5.1 布尔</h4><table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_TRUE(condition)</code>;</td>
<td><code>EXPECT_TRUE(condition)</code>;</td>
<td>condition is <em>true</em></td>
</tr>
<tr>
<td><code>ASSERT_FALSE(condition)</code>;</td>
<td><code>EXPECT_FALSE(condition)</code>;</td>
<td>condition is <em>false</em></td>
</tr>
</tbody></table>
<h4 id="1-3-5-2-整数、指针、string"><a href="#1-3-5-2-整数、指针、string" class="headerlink" title="1.3.5.2 整数、指针、string"></a>1.3.5.2 整数、指针、string</h4><p>以下断言比较两个值。值参数必须能被断言的比较运算符比较，否则编译器会报错。</p>
<p>如果参数支持<code>&lt;&lt;</code>运算符，则在断言失败时将调用它来打印参数。否则，GoogleTest 将尝试以最佳方式打印它们 - 请参阅 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCN0ZWFjaGluZy1nb29nbGV0ZXN0LWhvdy10by1wcmludC15b3VyLXZhbHVlcw==">教 GoogleTest 如何打印您的值<i class="fa fa-external-link-alt"></i></span>。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_EQ(val1, val2);</code></td>
<td><code>EXPECT_EQ(val1, val2);</code></td>
<td><em>val1</em> &#x3D;&#x3D; <em>val2</em></td>
</tr>
<tr>
<td><code>ASSERT_NE(val1, val2);</code></td>
<td><code>EXPECT_NE(val1, val2);</code></td>
<td><em>val1</em> !&#x3D; <em>val2</em></td>
</tr>
<tr>
<td><code>ASSERT_LT(val1, val2);</code></td>
<td><code>EXPECT_LT(val1, val2);</code></td>
<td><em>val1</em> &lt; <em>val2</em></td>
</tr>
<tr>
<td><code>ASSERT_LE(val1, val2);</code></td>
<td><code>EXPECT_LE(val1, val2);</code></td>
<td><em>val1</em> &lt;&#x3D; <em>val2</em></td>
</tr>
<tr>
<td><code>ASSERT_GT(val1, val2);</code></td>
<td><code>EXPECT_GT(val1, val2);</code></td>
<td><em>val1</em> &gt; <em>val2</em></td>
</tr>
<tr>
<td><code>ASSERT_GE(val1, val2);</code></td>
<td><code>EXPECT_GE(val1, val2);</code></td>
<td><em>val1</em> &gt;&#x3D; <em>val2</em></td>
</tr>
</tbody></table>
<p><code>ASSERT_EQ</code>、<code>EXPECT_EQ</code>和<code>ASSERT_NE</code>、<code>EXPECT_NE</code>还可以比较：</p>
<ol>
<li>C++ <code>std::string</code></li>
<li>指针，当比较指针是否为空应使用<code>EXPECT_EQ(ptr, nullptr)</code>而不是<code>EXPECT_EQ(ptr, NULL)</code>，对于<code>ASSERT_NE</code>也适用</li>
</ol>
<h4 id="1-3-5-3-C-风格字符串"><a href="#1-3-5-3-C-风格字符串" class="headerlink" title="1.3.5.3 C 风格字符串"></a>1.3.5.3 C 风格字符串</h4><p>以下断言比较两个C 风格字符串。要比较两个<code>std::string</code> 对象或 C风格字符串与空指针比较，请改用<code>EXPECT_EQ</code>或<code>EXPECT_NE</code></p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_STREQ(str1, str2);</code></td>
<td><code>EXPECT_STREQ(str1, str2);</code></td>
<td>the two C strings have the same content</td>
</tr>
<tr>
<td><code>ASSERT_STRNE(str1, str2);</code></td>
<td><code>EXPECT_STRNE(str1, str2);</code></td>
<td>the two C strings have different content</td>
</tr>
<tr>
<td><code>ASSERT_STRCASEEQ(str1,str2);</code></td>
<td><code>EXPECT_STRCASEEQ(str1, str2);</code></td>
<td>the two C strings have the same content, ignoring case</td>
</tr>
<tr>
<td><code>ASSERT_STRCASENE(str1,str2);</code></td>
<td><code>EXPECT_STRCASENE(str1, str2);</code></td>
<td>the two C strings have different content, ignoring case</td>
</tr>
</tbody></table>
<h4 id="1-3-5-4-浮点"><a href="#1-3-5-4-浮点" class="headerlink" title="1.3.5.4 浮点"></a>1.3.5.4 浮点</h4><p>由于舍入误差，两个浮点值完全匹配的可能性很小，因此<code>EXPECT_EQ</code>不合适。通常，为了使浮点比较有意义，用户需要仔细选择误差界限。GoogleTest 还提供了使用基于最后单位 (ULP) 的默认错误界限的断言。要了解有关 ULP 的更多信息，请参阅文章 <span class="exturl" data-url="aHR0cHM6Ly9yYW5kb21hc2NpaS53b3JkcHJlc3MuY29tLzIwMTIvMDIvMjUvY29tcGFyaW5nLWZsb2F0aW5nLXBvaW50LW51bWJlcnMtMjAxMi1lZGl0aW9uLw==">比较浮点数<i class="fa fa-external-link-alt"></i></span>。</p>
<p>彼此之间的差异在 4 个 ULP 以内则认为相等。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_FLOAT_EQ(val1,val2);</code></td>
<td><code>EXPECT_FLOAT_EQ(val1,val2);</code></td>
<td>the two <code>float</code> values are almost equal</td>
</tr>
<tr>
<td><code>ASSERT_DOUBLE_EQ(val1,val2);</code></td>
<td><code>EXPECT_DOUBLE_EQ(val1,val2);</code></td>
<td>the two <code>double</code> values are almost equa</td>
</tr>
</tbody></table>
<p>验证val1和val2之间的差值不会超过绝对误差界限<code>abs_error</code>。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_NEAR(val1, val2, abs_error);</code></td>
<td><code>EXPECT_NEAR(val1, val2, abs_error);</code></td>
<td>the difference between <em>val1</em> and <em>val2</em> doesn’t exceed the given absolute error</td>
</tr>
</tbody></table>
<h4 id="1-3-5-5-异常"><a href="#1-3-5-5-异常" class="headerlink" title="1.3.5.5 异常"></a>1.3.5.5 异常</h4><p>以下断言验证一段代码是否抛出异常。使用时需要在构建环境中启用异常。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_THROW(statement, exception_type);</code></td>
<td><code>EXPECT_THROW(statement, exception_type);</code></td>
<td><em>statement</em> throws an exception of the given type</td>
</tr>
<tr>
<td><code>ASSERT_ANY_THROW(statement);</code></td>
<td><code>EXPECT_ANY_THROW(statement);</code></td>
<td><em>statement</em> throws an exception of any type</td>
</tr>
<tr>
<td><code>ASSERT_NO_THROW(statement);</code></td>
<td><code>EXPECT_NO_THROW(statement);</code></td>
<td><em>statement</em> doesn’t throw any exception</td>
</tr>
</tbody></table>
<p>测试例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throws_invalid_argument</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throws_out_of_range</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectThrowTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">EXPECT_THROW</span>(<span class="built_in">throws_invalid_argument</span>(), std::invalid_argument); <span class="comment">// 断言成功</span></span><br><span class="line">	<span class="built_in">EXPECT_THROW</span>(<span class="built_in">throws_out_of_range</span>(), std::invalid_argument); <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectAnyThrowTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 测试是否抛出了任何类型的异常</span></span><br><span class="line">	<span class="built_in">EXPECT_ANY_THROW</span>(<span class="built_in">throws_invalid_argument</span>()); <span class="comment">// 断言成功</span></span><br><span class="line">	<span class="built_in">EXPECT_ANY_THROW</span>(<span class="built_in">throws_out_of_range</span>()); <span class="comment">// 断言成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectNoThrowTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 测试是否没有抛出异常</span></span><br><span class="line">	<span class="built_in">EXPECT_NO_THROW</span>(<span class="built_in">throws_invalid_argument</span>()); <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 3 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 3 tests from ExceptionTest</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectThrowTest</span><br><span class="line">/xxx/hello_test.cpp:16: Failure</span><br><span class="line">Expected: throws_out_of_range() throws an exception of <span class="built_in">type</span> std::invalid_argument.</span><br><span class="line">  Actual: it throws a different <span class="built_in">type</span>.</span><br><span class="line">[  FAILED  ] ExceptionTest.ExpectThrowTest (0 ms)</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectAnyThrowTest</span><br><span class="line">[       OK ] ExceptionTest.ExpectAnyThrowTest (0 ms)</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectNoThrowTest</span><br><span class="line">/xxx/hello_test.cpp:30: Failure</span><br><span class="line">Expected: throws_invalid_argument() doesn<span class="string">&#x27;t throw an exception.</span></span><br><span class="line"><span class="string">  Actual: it throws.</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectNoThrowTest (0 ms)</span></span><br><span class="line"><span class="string">[----------] 3 tests from ExceptionTest (0 ms total)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[----------] Global test environment tear-down</span></span><br><span class="line"><span class="string">[==========] 3 tests from 1 test suite ran. (1 ms total)</span></span><br><span class="line"><span class="string">[  PASSED  ] 1 test.</span></span><br><span class="line"><span class="string">[  FAILED  ] 2 tests, listed below:</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectThrowTest</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectNoThrowTest</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 2 FAILED TESTS</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-6-谓词"><a href="#1-3-5-6-谓词" class="headerlink" title="1.3.5.6 谓词"></a>1.3.5.6 谓词</h4><p>以下断言可以验证更复杂的谓词(Predicate，一个返回bool的可调用对象)，并打印比<code>EXPECT_TRUE</code>更清晰的失败信息。</p>
<p>参数<code>pred</code>是一个可调用对象，它接受与相应宏相同数量的参数。如果<code>pred</code>对给定的参数返回true，则断言成功，否则断言失败。当断言失败时，它打印出每个实参的值，便于排错，它最多接受5个参数。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_PRED1(pred, val1);</code></td>
<td><code>EXPECT_PRED1(pred, val1);</code></td>
<td><em>pred(val1)</em> return true</td>
</tr>
<tr>
<td><code>ASSERT_PRED2(pred, val1, val2);</code></td>
<td><code>EXPECT_PRED2(pred, val1, val2);</code></td>
<td><em>pred(val1, val2)</em> return true</td>
</tr>
<tr>
<td><code>ASSERT_PRED3(pred, val1, val2, val3);</code></td>
<td><code>EXPECT_PRED3(pred, val1, val2, val3);</code></td>
<td><em>pred(val1, val2, val3)</em> return true</td>
</tr>
<tr>
<td><code>ASSERT_PRED4(pred, val1, val2, val3, val4);</code></td>
<td><code>EXPECT_PRED2(pred, val1, val2, val3 ,val4);</code></td>
<td><em>pred(val1, val2, val3 ,val4)</em> return true</td>
</tr>
<tr>
<td><code>ASSERT_PRED5(pred, val1, val2, val3, val4 ,val5);</code></td>
<td><code>EXPECT_PRED2(pred, val1, val2, val3, val4, val5);</code></td>
<td><em>pred(val1, val2, val3, val4, val5)</em> return true</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词函数：检查 value 是否在 [low, high] 范围内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInRange</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value &gt;= low &amp;&amp; value &lt;= high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(PredicateTest, IsInRangeTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">2000</span>;</span><br><span class="line">	<span class="type">int</span> high = <span class="number">2025</span>;</span><br><span class="line">	<span class="type">int</span> value = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EXPECT_PRED3</span>(IsInRange, value, low, high); <span class="comment">// 断言成功</span></span><br><span class="line">	<span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsInRange</span>(value, low, high));  <span class="comment">// 断言成功</span></span><br><span class="line"></span><br><span class="line">	value = <span class="number">2026</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EXPECT_PRED3</span>(IsInRange, value, low, high); <span class="comment">// 断言失败</span></span><br><span class="line">	<span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsInRange</span>(value, low, high));  <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<code>ASSERT_PRED2</code>可以打印所有参数的值，有助于快速定位问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateTest</span><br><span class="line">[ RUN      ] PredicateTest.IsInRangeTest</span><br><span class="line">/xxx/hello_test.cpp:20: Failure</span><br><span class="line">IsInRange(value, low, high) evaluates to <span class="literal">false</span>, <span class="built_in">where</span></span><br><span class="line">value evaluates to 2026</span><br><span class="line">low evaluates to 2000</span><br><span class="line">high evaluates to 2025</span><br><span class="line">/xxx/hello_test.cpp:21: Failure</span><br><span class="line">Value of: IsInRange(value, low, high)</span><br><span class="line">  Actual: <span class="literal">false</span></span><br><span class="line">Expected: <span class="literal">true</span></span><br><span class="line">[  FAILED  ] PredicateTest.IsInRangeTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] PredicateTest.IsInRangeTest</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure>




<blockquote>
<p>注意，如果给定的谓词是重载函数或函数模板，断言宏可能无法确定调用哪个版本，并且可能需要明确指定函数的类型。</p>
</blockquote>
<p>对于<code>IsPositive</code>重载为单个参数为<code>int</code>或<code>double</code>版本，使用时需要显式指定函数的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(<span class="type">double</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>); </span><br></pre></td></tr></table></figure>

<p>对于函数模版也是一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(T n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">double</span>&gt;, <span class="number">3.14</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如果您想自定义断言失败的错误信息，可以使用下面这类宏。参数<code>pred_formatter</code>是一个具有以下签名的可调用对象，其中<code>val1</code>、<code>val2</code>、 …<code>valn</code>是谓词参数的值，而<code>expr1</code>、<code>expr2</code>、 …<code>exprn</code>是源代码中对应的表达式。类型<code>T1</code>、<code>T2</code>、 …<code>Tn</code> 可以是值类型或引用类型，例<code>T</code>、<code>T&amp;</code>、<code>const T&amp;</code>等。有关返回类型的更多信息<code>testing::AssertionResult</code>，请参阅 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCN1c2luZy1hLWZ1bmN0aW9uLXRoYXQtcmV0dXJucy1hbi1hc3NlcnRpb25yZXN1bHQ=">返回 AssertionResult 的函数<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">testing::AssertionResult <span class="title">PredicateFormatter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* expr1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> <span class="type">char</span>* expr2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ...</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> <span class="type">char</span>* exprn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            T1 val1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            T2 val2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ...</span></span></span><br><span class="line"><span class="params"><span class="function">                                            Tn valn)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_PRED_FORMAT1(pred_formatter, val1);</code></td>
<td><code>EXPECT_PRED_FORMAT1(pred_formatter, val1);</code></td>
<td><em>pred_formatter(expr1, val1)</em> return true</td>
</tr>
<tr>
<td><code>ASSERT_PRED_FORMAT2(pred_formatter, val1, val2);</code></td>
<td><code>EXPECT_PRED_FORMAT2(pred_formatter, val1, val2);</code></td>
<td>…</td>
</tr>
<tr>
<td><code>ASSERT_PRED_FORMAT3(pred_formatter, val1, val2, val3);</code></td>
<td><code>EXPECT_PRED_FORMAT3(pred_formatter, val1, val2, val3);</code></td>
<td>…</td>
</tr>
<tr>
<td><code>ASSERT_PRED_FORMAT4(pred_formatter, val1, val2, val3, val4);</code></td>
<td><code>EXPECT_PRED_FORMAT4(pred_formatter, val1, val2, val3 ,val4);</code></td>
<td>…</td>
</tr>
<tr>
<td><code>ASSERT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4 ,val5);</code></td>
<td><code>EXPECT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4, val5);</code></td>
<td>…</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInRange</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value &gt;= low &amp;&amp; value &lt;= high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="function">testing::AssertionResult <span class="title">IsInRangeFormat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> <span class="type">char</span> *value_expr, <span class="type">const</span> <span class="type">char</span> *low_expr, <span class="type">const</span> <span class="type">char</span> *high_expr,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsInRange</span>(value, low, high))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ::testing::<span class="built_in">AssertionSuccess</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ::testing::<span class="built_in">AssertionFailure</span>()</span><br><span class="line">				&lt;&lt; <span class="string">&quot;Value &quot;</span> &lt;&lt; value_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value</span><br><span class="line">				&lt;&lt; <span class="string">&quot; is not in range [&quot;</span> &lt;&lt; low_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; low</span><br><span class="line">				&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; high_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; high &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(PredicateFormatTest, IsInRangeTest)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">2000</span>;</span><br><span class="line">	<span class="type">int</span> high = <span class="number">2025</span>;</span><br><span class="line">	<span class="type">int</span> value = <span class="number">2026</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EXPECT_PRED_FORMAT3</span>(IsInRangeFormat, value, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateFormatTest</span><br><span class="line">[ RUN      ] PredicateFormatTest.IsInRangeTest</span><br><span class="line">/xxx/hello_test.cpp:32: Failure</span><br><span class="line">Value value = 2026 is not <span class="keyword">in</span> range [low = 2000, high = 2025]</span><br><span class="line">[  FAILED  ] PredicateFormatTest.IsInRangeTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateFormatTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] PredicateFormatTest.IsInRangeTest</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-7-显式的成功和失败"><a href="#1-3-5-7-显式的成功和失败" class="headerlink" title="1.3.5.7 显式的成功和失败"></a>1.3.5.7 显式的成功和失败</h4><p>本节中的断言直接生成成功或失败，而不是测试值或表达式。当由控制流而不是布尔表达式决定测试的成功或失败时，这很有用。</p>
<p><code>SUCCEED()</code> ： 生成成功，这并不会使整个测试成功。只有当测试在执行过程中没有任何断言失败时，测试才被视为成功。该<code>SUCCEED</code>断言纯粹是记录性的，目前不会生成任何用户可见的输出。但是，我们可能会在未来将<code>SUCCEED</code>消息添加到<code>gtest</code>输出中。</p>
<p><code>FAIL()</code> ：生成致命失败并从当前函数返回。只能在返回 <code>void </code>的函数中使用。 有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCNhc3NlcnRpb24tcGxhY2VtZW50">断言放置。<i class="fa fa-external-link-alt"></i></span></p>
<p><code>ADD_FAILURE()</code>：生成非致命失败，允许当前函数继续运行。</p>
<p><code>ADD_FAILURE_AT(file_path, line_number)</code>：在指定的文件和行号处生成非致命失败</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(AdditionTest, HandlesVariousConditions)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2</span> == result)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SUCCEED</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">FAIL</span>() &lt;&lt; <span class="string">&quot;Unexpected result for 1 + 1: &quot;</span> &lt;&lt; result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="number">4</span>)  <span class="comment">// 使用 ADD_FAILURE来记录一个失败，但不中止测试</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ADD_FAILURE</span>() &lt;&lt; <span class="string">&quot;Expected 2 + 2 to be 4, but got &quot;</span> &lt;&lt; result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="number">6</span>) <span class="comment">// 使用 ADD_FAILURE_AT() 来记录失败，指定文件和行号</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ADD_FAILURE_AT</span>(__FILE__, __LINE__ - <span class="number">3</span>) &lt;&lt; <span class="string">&quot;Expected 3 + 3 to be 6, but got &quot;</span> &lt;&lt; result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-8-匹配器"><a href="#1-3-5-8-匹配器" class="headerlink" title="1.3.5.8 匹配器"></a>1.3.5.8 匹配器</h4><p>以下断言使用匹配器对测试值进行更灵活、可读性更强的验证。可以使用<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcmVmZXJlbmNlL21hdGNoZXJzLmh0bWw=">内置<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvZ21vY2tfY29va19ib29rLmh0bWwjTmV3TWF0Y2hlcnM=">自定义的匹配器<i class="fa fa-external-link-alt"></i></span>来验证值是否与匹配器匹配。使用时需要链接<code>gmock</code>库。</p>
<p><code>EXPECT_THAT(value, matcher);</code><br><code>ASSERT_THAT(value, matcher);</code></p>
<p>value：要测试的值。<br>matcher：匹配器，可以是内置的匹配器（如 <code>Eq()</code>, <code>Le()</code>, <code>Gt()</code> 等），也可以是自定义的匹配器。</p>
<p>例如，以下代码验证val是否介于 5 和 10 之间，字符串str是否以”Hello”开头。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ::testing::AllOf;</span><br><span class="line"><span class="keyword">using</span> ::testing::Gt;</span><br><span class="line"><span class="keyword">using</span> ::testing::Lt;</span><br><span class="line"><span class="keyword">using</span> ::testing::StartsWith;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MathTest, AssertThatExample)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val = <span class="number">4</span>;</span><br><span class="line">	<span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hi World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EXPECT_THAT</span>(val, <span class="built_in">AllOf</span>(<span class="built_in">Gt</span>(<span class="number">5</span>), <span class="built_in">Lt</span>(<span class="number">10</span>))); </span><br><span class="line">	<span class="built_in">EXPECT_THAT</span>(str, <span class="built_in">StartsWith</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-9-Windows-HRESULT"><a href="#1-3-5-9-Windows-HRESULT" class="headerlink" title="1.3.5.9 Windows HRESULT"></a>1.3.5.9 Windows HRESULT</h4><p>以下断言测试<code>HRESULT</code>成功或失败。</p>
<table>
<thead>
<tr>
<th><strong>Fatal assertion</strong></th>
<th><strong>Nonfatal assertion</strong></th>
<th><strong>Verifies</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ASSERT_HRESULT_SUCCEEDED(expression);</code></td>
<td><code>EXPECT_HRESULT_SUCCEEDED(expression);</code></td>
<td>expression is a success <code>HRESULT</code></td>
</tr>
<tr>
<td><code>ASSERT_HRESULT_FAILED(expression);</code></td>
<td><code>EXPECT_HRESULT_FAILED(expression);</code></td>
<td>expression is a failure <code>HRESULT</code></td>
</tr>
</tbody></table>
<h4 id="1-3-5-10-死亡断言"><a href="#1-3-5-10-死亡断言" class="headerlink" title="1.3.5.10 死亡断言"></a>1.3.5.10 死亡断言</h4><p><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcmVmZXJlbmNlL2Fzc2VydGlvbnMuaHRtbCNkZWF0aA==">死亡断言<i class="fa fa-external-link-alt"></i></span>与后续进阶主题中死亡测试息息相关，因此将它们融为一节，将在后续进阶主题中讲解。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3Qv">GoogleTest User’s Guide<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Google Test</category>
      </categories>
      <tags>
        <tag>gtest</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序与快速排序</title>
    <url>/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>



<p>前言：冒泡排序与快速排序都属于交换排序，它们排序的思想是：根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部（前部）移动，键值较小的记录向序列的前部（尾部）移动</p>
<p><font color=#FF0000 >注意：下文中所有排序都是升序</font></p>
<h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>&emsp;冒泡排序思想：<strong>比较相邻的元素。如果第一个比第二个大，就交换它们。从第一组比较到最后一组相邻元素，此时最后一个元素是最大的元素。除去最后一个元素，将剩下n-1个元素重复上面步骤，直到只剩下一个元素为止</strong></p>
<span id="more"></span>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3ce87b8919a8fd745331bedd5def4053.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-1-冒泡排序代码实现"><a href="#1-1-冒泡排序代码实现" class="headerlink" title="1.1 冒泡排序代码实现"></a>1.1 冒泡排序代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 排序趟数为：待排序序列元素个数-1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-冒泡排序优化"><a href="#1-2-冒泡排序优化" class="headerlink" title="1.2 冒泡排序优化"></a>1.2 冒泡排序优化</h2><p>&emsp;在上文中冒泡排序的举例图中我们发现，当序列元素个数为n，冒泡排序需排序n-1趟。但在第n-1趟前，序列可能已经排序好了，继续排序没有意义。我们可以设置一个标志位,当某趟排序没有发生过相邻元素交换时，代表序列已经有序，退出循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 排序趟数为：待排序序列元素个数-1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>; <span class="comment">// 标志位，当某趟没发生相邻元素交换时,flag为1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">0</span>; <span class="comment">// 相邻元素交换，flag置0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-时间复杂度与空间复杂度"><a href="#1-3-时间复杂度与空间复杂度" class="headerlink" title="1.3 时间复杂度与空间复杂度"></a>1.3 时间复杂度与空间复杂度</h2><p>当序列本身有序时，时间复杂度最好：<code>O(N)</code>,当序列逆序时，时间复杂度最坏：<code>O(N^2)</code>。冒泡排序只用了常数个辅助变量空间，空间复杂度：<code>O(1)</code></p>
<p>说明：<br> ●冒泡排序是一个稳定的排序算法</p>
<h1 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h1><p>&emsp;快速排序思想：<strong>选取待排序序列中的某元素作为基准值，按照该基准值将待排序序列分割成两子序列，左子序列中所有元素均小于等于基准值，右子序列中所有元素均大于等于基准值，然后对左右子序列重复该过程，直到所有元素都排列在对应位置上为止</strong></p>
<h2 id="2-1-选取基准值划分左右子序列方法"><a href="#2-1-选取基准值划分左右子序列方法" class="headerlink" title="2.1 选取基准值划分左右子序列方法"></a>2.1 选取基准值划分左右子序列方法</h2><p><strong>选取基准值划分左右子序列方法有多种，下面会演示三种划分方法，只需掌握一种即可</strong></p>
<h3 id="2-1-1-Hoare法"><a href="#2-1-1-Hoare法" class="headerlink" title="2.1.1 Hoare法"></a>2.1.1 Hoare法</h3><p><strong>Hoare法是由快速排序发明人查尔斯·霍尔给出方法，Hoare法分为两种方法选取基准值</strong><br>第一种：<strong>选取序列最左边元素做为基准值（key），右指针先走</strong></p>
<ol>
<li>循环开始前，左指针指向基准值，右指针指向序列最右边元素</li>
<li>循环开始：右指针先走，找到比基准值小的元素停下来，左指针走，找到比基准值大的元素停下来，交换左右指针指向元素值。重复该过程，直到左右指针相遇为止</li>
<li>将基准值与左右指针相遇位置元素进行交换</li>
</ol>
<p>第二种：<strong>选取序列最右边元素做为基准值（key），左指针先走</strong></p>
<ol>
<li>循环开始前，左指针指向序列最左边元素，右指针指向基准值</li>
<li>循环开始：左指针先走，找到比基准值大的元素停下来，右指针走，找到比基准值小的元素停下来，交换左右指针指向元素值。重复该过程，直到左右指针相遇为止</li>
<li>将基准值与左右指针相遇位置元素进行交换</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3fcb0f01fb1ca1dd92f908ffe57cb176.png#pic_center" alt="在这里插入图片描述"><br><font color=#FF0000 >以哪边做key，另一边先走原因：可以保证左右指针相遇位置一定比key小(大)，而先走的顺序随意，例如：左边做key,左指针先走，在左右指针相遇前的交换没有区别，最后左右指针相遇位置元素值与key相比不能保证上面条件</font></p>
<p><strong>下面演示左边做key,右指针先走的两种情况，情况一：左指针走与右指针相遇 ，情况二：右指针走与左指针相遇</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/de379e2aaa30c177095369cc729597ff.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key_i = left; <span class="comment">// key元素的下标</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 右指针先走，遇到比key小的元素停下</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= arr[key_i])</span><br><span class="line">		&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 左指针走，遇到比key大的元素停下</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[key_i])</span><br><span class="line">		&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 交换左右指针指向元素</span></span><br><span class="line">		swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将key位置元素与左右指针相遇位置元素交换，并返回相遇位置元素下标</span></span><br><span class="line">	swap(&amp;arr[key_i], &amp;arr[right]);</span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-挖坑法"><a href="#2-1-2-挖坑法" class="headerlink" title="2.1.2 挖坑法"></a>2.1.2 挖坑法</h3><p><strong>挖坑法是Hoare法的变形</strong></p>
<ol>
<li>循环开始前，将序列最左边元素值保存在变量key中，并将该位置做为坑位，左指针指向坑位，右指针指向序列最右边元素</li>
<li>循环开始：右指针先走，找到比key小的元素停下来，将该位置元素放到左边的坑位中，并将该位置做为新的坑位。左指针走，找到比key大的元素停下来，将该位置元素放到右边的坑位中，并将该位置做为新的坑位。重复该过程，直到左右指针相遇为止</li>
<li>相遇位置一定是坑位，将key值放入坑位中</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f46902ecc770c088dcb452a305c9ccd.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key = arr[left]; <span class="comment">// 存放key的值</span></span><br><span class="line">	<span class="type">int</span> pit = left; <span class="comment">// 存放坑位下标</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 右指针找比key小的值并放入坑中</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= key)</span><br><span class="line">		&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[pit] = arr[right];</span><br><span class="line">		pit = right;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 左指针找比key大的值并放入坑中</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key)</span><br><span class="line">		&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[pit] = arr[left];</span><br><span class="line">		pit = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 左右指针相遇于坑位中，将key值放入坑中，返回坑位下标</span></span><br><span class="line">	arr[pit] = key;</span><br><span class="line">	<span class="keyword">return</span> pit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-前后指针法"><a href="#2-1-3-前后指针法" class="headerlink" title="2.1.3 前后指针法"></a>2.1.3 前后指针法</h3><ol>
<li>循环开始前，将序列最左边元素值做为基准值（key），prev指针指向基准值，cur指针指向prev下一个位置</li>
<li>循环开始：cur指针找到比基准值小的元素停下，先++prev,然后交换prev与cur指向位置的值，重复该过程，直到cur指向位置越界</li>
<li>cur越界后，prev与基准位置值交换<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7fa68faa870140c2278832ff41d6ebe3.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key_i = left; <span class="comment">// 存放key元素下标 </span></span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur = prev + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (cur &lt;= right &amp;&amp; arr[cur] &gt;= arr[key_i])</span><br><span class="line">		&#123;</span><br><span class="line">			++cur;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cur &lt;= right) <span class="comment">// 当cur未越界，先++prev，然后交换prev与cur位置值</span></span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;arr[cur], &amp;arr[++prev]);</span><br><span class="line">			cur++; <span class="comment">// 防止序列逆序情况下，cur一直不动,prev越界访问并交换，例如序列： 9、8、7、6、5</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(&amp;arr[prev], &amp;arr[key_i]);</span><br><span class="line">	<span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们发现cur指向元素大于等于基准值情况还是小于基准值情况下都需要cur++。只有cur指向元素小于基准值才需要++prev,并交换prev与cur指向位置值，如果++prev后prev等于cur,此时为原地交换没有必要。因此可以对上面代码进行优化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key_i = left; <span class="comment">// 存放基准值元素下标 </span></span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur = prev + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt; arr[key_i] &amp;&amp; ++prev != cur)</span><br><span class="line">			swap(&amp;arr[prev], &amp;arr[cur]);</span><br><span class="line"></span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(&amp;arr[prev], &amp;arr[key_i]);</span><br><span class="line">	<span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h2><p>使用 2.1 中任一方法选取基准值并将待排序序列分为左右两个子序列，只需对左右子序列重复该过程，达到整个序列有序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="comment">// 序列元素个数小于等于1，已经有序，不需要排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key_i = Partition(arr, left, right); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 左子序列下标范围： [left,key_i-1]  key_i  右子序列下标范围： [key_i+1,right]</span></span><br><span class="line">	QuickSort(arr, left, key_i - <span class="number">1</span>);</span><br><span class="line">	QuickSort(arr, key_i+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-快速排序测试"><a href="#2-3-快速排序测试" class="headerlink" title="2.3 快速排序测试"></a>2.3 快速排序测试</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前后指针法（优化）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key_i = left; <span class="comment">// 存放基准值元素下标 </span></span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur = prev + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt; arr[key_i] &amp;&amp; ++prev != cur)</span><br><span class="line">			swap(&amp;arr[prev], &amp;arr[cur]);</span><br><span class="line"></span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(&amp;arr[prev], &amp;arr[key_i]);</span><br><span class="line">	<span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="comment">// 序列元素个数小于等于1，已经有序，不需要排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key_i = Partition(arr, left, right);</span><br><span class="line">	<span class="comment">// 左子序列下标范围： [left,key_i-1]  key_i  右子序列下标范围： [key_i+1,right]</span></span><br><span class="line">	QuickSort(arr, left, key_i - <span class="number">1</span>);</span><br><span class="line">	QuickSort(arr, key_i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	PrintArray(arr, <span class="number">10</span>);</span><br><span class="line">	QuickSort(arr, <span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">	PrintArray(arr, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">10</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-快速排序的优化"><a href="#2-4-快速排序的优化" class="headerlink" title="2.4 快速排序的优化"></a>2.4 快速排序的优化</h2><h3 id="2-4-1-三数取中"><a href="#2-4-1-三数取中" class="headerlink" title="2.4.1 三数取中"></a>2.4.1 三数取中</h3><p>&emsp;当每次选取key值是序列的中位数时，可以把序列分为长度相等的左右子序列，快速排序时间复杂度为：<code>O(N*log₂N)</code>。但如果每次选取的key是序列的最小值或最大值时，序列分为一个子序列为空，另一个子序列长度为序列长度-1情况，时间复杂度为：<code>O(N^2)</code>。<strong>上文中选取key划分左右子序列，对key的选择都是序列最左边元素或序列最右边元素，当序列基本有序，很容易出现选取的key为最小值或最大值，影响快速排序效率</strong>。有人提出三数取中的优化方法，每次选取序列最左边元素、序列中间元素、序列最右边元素，比较三个元素大小，选取中间元素做为key。但是key元素位置可能不是序列最左边或最右边位置，根据上文中选取key划分左右子序列的方法，让key元素与序列最左边（最右边）元素交换位置即可<br><img src="https://i-blog.csdnimg.cn/blog_migrate/67687e270a19338c3e1d1406c6ee377d.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMiddle</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (arr[left] &lt; arr[middle])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[middle] &lt; arr[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> middle;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &lt; arr[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[middle] &gt; arr[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> middle;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &lt; arr[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//三数取中</span></span><br><span class="line">	<span class="type">int</span> middle = GetMiddle(arr, left, right);</span><br><span class="line">	swap(&amp;arr[left], &amp;arr[middle]);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> key_i = left; <span class="comment">// 存放基准值元素下标 </span></span><br><span class="line">	<span class="type">int</span> prev = left;</span><br><span class="line">	<span class="type">int</span> cur = prev + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt; arr[key_i] &amp;&amp; ++prev != cur)</span><br><span class="line">			swap(&amp;arr[prev], &amp;arr[cur]);</span><br><span class="line"></span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(&amp;arr[prev], &amp;arr[key_i]);</span><br><span class="line">	<span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-小区间优化"><a href="#2-4-2-小区间优化" class="headerlink" title="2.4.2 小区间优化"></a>2.4.2 小区间优化</h3><p>&emsp;<strong>当序列（区间）元素个数较少时，继续使用快速排序将导致递归次数大大增加</strong>。例如：某个子序列有10个元素，首先递归1次划分左右两个子序列，每个子序列元素个数大约为4。左右两个子序列递归分别递归继续划分左右子序列，每个子序列元素个数大约为2…直到每个子序列元素个数小于等于1为止，此时大约递归了：<code>2^0+2^1+2^2+2^3 = 15</code>次。为了对子序列中10个元素排序需要递归15次，整个快速排序过程中有很多这样子序列，这些子序列递归次数几乎占整个快速排序递归次数的一大半。<strong>对于区间元素个数较少时可以使用直接插入排序，减少大量递归带来的开销</strong></p>
<p><strong>直接插入排序可参考这篇博客</strong>: <code>https://blog.csdn.net/kjl167/article/details/125872807/</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/b6679006bb60d9716776715777ac9228.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>;i++) <span class="comment">// 待排序次数为n-1,下标小于等于i的元素已经是有序的</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="type">int</span> end = i;  </span><br><span class="line">		<span class="type">int</span> elem = arr[end+<span class="number">1</span>]; <span class="comment">// 待插入元素</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (elem &lt; arr[end])</span><br><span class="line">			&#123;</span><br><span class="line">				arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">				end--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end + <span class="number">1</span>] = elem; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="comment">// 序列元素个数小于等于1，已经有序，不需要排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 小区间优化，当区间元素个数小于等于10用直接插入排序让区间有序，而不是通过递归让区间有序，减少快速排序的递归次数</span></span><br><span class="line">	<span class="keyword">if</span> (right - left + <span class="number">1</span> &lt;= <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertSort(arr + left, right - left + <span class="number">1</span>); <span class="comment">// 子序列（区间）不一定位于数组开头位置，所以arr不一定是区间起始位置，arr+left才是</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> key_i = Partition(arr, left, right);</span><br><span class="line">		<span class="comment">// 左子序列下标范围： [left,key_i-1]  key_i  右子序列下标范围： [key_i+1,right]</span></span><br><span class="line">		QuickSort(arr, left, key_i - <span class="number">1</span>);</span><br><span class="line">		QuickSort(arr, key_i + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-非递归实现快速排序"><a href="#2-4-3-非递归实现快速排序" class="headerlink" title="2.4.3 非递归实现快速排序"></a>2.4.3 非递归实现快速排序</h3><p>&emsp;上文中快速排序通过递归实现，每次递归调用会消耗一定栈空间大小，栈大小是很有限的。虽然通过三数取中以及小区间优化对快速排序进行了优化，减少了递归次数，但如果遇到待排序序列所有元素几乎相同时，递归深度趋近于N，快速排序的空间复杂度为：<code>O(N)</code>,很容易造成栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	p-&gt;data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * SIZE); <span class="comment">// SIZE为栈空间初始化大小，在Stack.h头文件定义</span></span><br><span class="line">	p-&gt;top = <span class="number">0</span>;</span><br><span class="line">	p-&gt;capacity = SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(Stack* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="built_in">free</span>(p-&gt;data);</span><br><span class="line">	p-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;top = p-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;top == p-&gt;capacity) <span class="comment">// 栈空间已满，需要扩容</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> newCapacity = p-&gt;capacity * <span class="number">2</span>;</span><br><span class="line">		ElemType* tmp = <span class="built_in">realloc</span>(p-&gt;data, <span class="keyword">sizeof</span>(ElemType) * newCapacity);</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="comment">// 扩容失败，报错并退出</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;realloc fail\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data = tmp;</span><br><span class="line">		p-&gt;capacity = newCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 栈空间扩容成功，元素入栈</span></span><br><span class="line"></span><br><span class="line">	p-&gt;data[p-&gt;top] = elem;</span><br><span class="line">	p-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">Pop</span><span class="params">(Stack* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;top == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈为空，元素出栈失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ElemType elem = p-&gt;data[p-&gt;top - <span class="number">1</span>]; <span class="comment">// 待出栈元素</span></span><br><span class="line">		p-&gt;top--;</span><br><span class="line">		<span class="keyword">return</span> elem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">EmptyStack</span><span class="params">(<span class="type">const</span> Stack* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">return</span> p-&gt;top == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSortNoRecurse</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="comment">// 序列元素个数小于等于1，已经有序，不需要排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Stack s;</span><br><span class="line">	InitStack(&amp;s); <span class="comment">// 初始化栈</span></span><br><span class="line">	Push(&amp;s, left);</span><br><span class="line">	Push(&amp;s, right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!EmptyStack(&amp;s))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			由于栈是先进后出，我们是left先入栈，right后入栈，所有先出栈的是right</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="type">int</span> right_i = Pop(&amp;s); </span><br><span class="line">		<span class="type">int</span> left_i = Pop(&amp;s);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 小区间优化，当区间元素个数小于等于10用直接插入排序让区间有序</span></span><br><span class="line">		<span class="keyword">if</span> (right_i - left_i + <span class="number">1</span> &lt;= <span class="number">10</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			InsertSort(arr + left_i, right_i - left_i + <span class="number">1</span>); <span class="comment">// 子序列（区间）不一定位于数组开头位置，所以arr不一定是区间起始位置，arr+left才是</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> key_i = Partition(arr, left_i, right_i);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">				左子序列：[left_i , key_i - 1]  右子序列：[key_i + 1 , right_i]</span></span><br><span class="line"><span class="comment">				由于栈是先进后出,右子序列先入栈，左子序列后入栈，可以确保出栈先对左子序列排序</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (key_i + <span class="number">1</span> &lt; right_i) <span class="comment">// 右子序列元素个数大于1才需要入栈等待排序</span></span><br><span class="line">			&#123;</span><br><span class="line">				Push(&amp;s, key_i + <span class="number">1</span>);</span><br><span class="line">				Push(&amp;s, right_i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (left_i &lt; key_i - <span class="number">1</span>) <span class="comment">// 左子序列元素个数大于1才需要入栈等待排序</span></span><br><span class="line">			&#123;</span><br><span class="line">				Push(&amp;s, left_i);</span><br><span class="line">				Push(&amp;s, key_i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DestroyStack(&amp;s); <span class="comment">// 销毁栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-时间复杂度与空间复杂度"><a href="#2-5-时间复杂度与空间复杂度" class="headerlink" title="2.5 时间复杂度与空间复杂度"></a>2.5 时间复杂度与空间复杂度</h2><p>每次选key为序列的中位数时，时间复杂度最好为：<code>O(N*log₂N)</code>,空间复杂度为：<code>O(log₂N)</code>。当序列中元素几乎相同时，时间复杂度最坏为：<code>O(N^2)</code>,空间复杂度为：<code>O(N)</code></p>
<p>说明：<br> ●快速排序是一个不稳定的排序算法<br> ●快速排序面对序列元素几乎相同时，效率很差</p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>几个循环练习题（九九乘法表、金字塔、猜数字游戏）</title>
    <url>/%E5%87%A0%E4%B8%AA%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8%E3%80%81%E9%87%91%E5%AD%97%E5%A1%94%E3%80%81%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%EF%BC%89.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>前言<br>在之前博客中讲解了循环的基础语法，下面通过几个小题来练习下。<br>如之前没有学习过循环朋友可以先看下面这篇博客后再来看这篇。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tqbDE2Ny9hcnRpY2xlL2RldGFpbHMvMTIyMzc2MTQ3">https://blog.csdn.net/kjl167/article/details/122376147<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>先再来看此博客</p>
<h1 id="一、九九乘法表"><a href="#一、九九乘法表" class="headerlink" title="一、九九乘法表"></a>一、九九乘法表</h1><p>分析：<br>九九乘法表主要由两个变量相乘而成，变量范围为1-9，变量类型我们可以选择整数类型。<br> 1 * 1 &#x3D; 1   （第1行，有1列）<br> 2 * 1 &#x3D; 2 &emsp;2 * 2 &#x3D; 4 （第2行，有2列）<br> 3 * 1 &#x3D; 3 &emsp;3 * 2 &#x3D; 6  &emsp;3 * 3 &#x3D; 9（第3行，有3列）<br> …<br> 九九乘法表共有九行。我们可以发现<strong>第n行就会有n列</strong>。我们可以用变量 i 代表第几行(并且代表乘号左边操作数)，变量 j 代表这行第几列(并且代表乘号右边操作数)。<strong>j &lt;&#x3D; i</strong> 。</p>
<span id="more"></span>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//定义i代表第几行(也代表乘法左操作数)</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">1</span>;<span class="comment">//定义j代表该行第几列(也代表乘法右操作数)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) <span class="comment">//控制行数，总过有9行，所以 i&lt;=9</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) <span class="comment">//控制列数，第n行就会有n列，所以 j&lt;=i</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\t&quot;</span>, i, j, i * j); <span class="comment">//打印每一行的每一列结果，使用转义字符&#x27;\t&#x27;（水平制表符）可以使输出更美观</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">//一行打印结束后需要换行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">2</span> * <span class="number">1</span> = <span class="number">2</span>       <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">3</span> * <span class="number">1</span> = <span class="number">3</span>       <span class="number">3</span> * <span class="number">2</span> = <span class="number">6</span>       <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"><span class="number">4</span> * <span class="number">1</span> = <span class="number">4</span>       <span class="number">4</span> * <span class="number">2</span> = <span class="number">8</span>       <span class="number">4</span> * <span class="number">3</span> = <span class="number">12</span>      <span class="number">4</span> * <span class="number">4</span> = <span class="number">16</span></span><br><span class="line"><span class="number">5</span> * <span class="number">1</span> = <span class="number">5</span>       <span class="number">5</span> * <span class="number">2</span> = <span class="number">10</span>      <span class="number">5</span> * <span class="number">3</span> = <span class="number">15</span>      <span class="number">5</span> * <span class="number">4</span> = <span class="number">20</span>      <span class="number">5</span> * <span class="number">5</span> = <span class="number">25</span></span><br><span class="line"><span class="number">6</span> * <span class="number">1</span> = <span class="number">6</span>       <span class="number">6</span> * <span class="number">2</span> = <span class="number">12</span>      <span class="number">6</span> * <span class="number">3</span> = <span class="number">18</span>      <span class="number">6</span> * <span class="number">4</span> = <span class="number">24</span>      <span class="number">6</span> * <span class="number">5</span> = <span class="number">30</span>      <span class="number">6</span> * <span class="number">6</span> = <span class="number">36</span></span><br><span class="line"><span class="number">7</span> * <span class="number">1</span> = <span class="number">7</span>       <span class="number">7</span> * <span class="number">2</span> = <span class="number">14</span>      <span class="number">7</span> * <span class="number">3</span> = <span class="number">21</span>      <span class="number">7</span> * <span class="number">4</span> = <span class="number">28</span>      <span class="number">7</span> * <span class="number">5</span> = <span class="number">35</span>      <span class="number">7</span> * <span class="number">6</span> = <span class="number">42</span>      <span class="number">7</span> * <span class="number">7</span> = <span class="number">49</span></span><br><span class="line"><span class="number">8</span> * <span class="number">1</span> = <span class="number">8</span>       <span class="number">8</span> * <span class="number">2</span> = <span class="number">16</span>      <span class="number">8</span> * <span class="number">3</span> = <span class="number">24</span>      <span class="number">8</span> * <span class="number">4</span> = <span class="number">32</span>      <span class="number">8</span> * <span class="number">5</span> = <span class="number">40</span>      <span class="number">8</span> * <span class="number">6</span> = <span class="number">48</span>      <span class="number">8</span> * <span class="number">7</span> = <span class="number">56</span>      <span class="number">8</span> * <span class="number">8</span> = <span class="number">64</span></span><br><span class="line"><span class="number">9</span> * <span class="number">1</span> = <span class="number">9</span>       <span class="number">9</span> * <span class="number">2</span> = <span class="number">18</span>      <span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span>      <span class="number">9</span> * <span class="number">4</span> = <span class="number">36</span>      <span class="number">9</span> * <span class="number">5</span> = <span class="number">45</span>      <span class="number">9</span> * <span class="number">6</span> = <span class="number">54</span>      <span class="number">9</span> * <span class="number">7</span> = <span class="number">63</span>      <span class="number">9</span> * <span class="number">8</span> = <span class="number">72</span>      <span class="number">9</span> * <span class="number">9</span> = <span class="number">81</span></span><br></pre></td></tr></table></figure>

<h1 id="二、星号图案"><a href="#二、星号图案" class="headerlink" title="二、星号图案"></a>二、星号图案</h1><p>输出如图所示图案，层数由用户指定</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/7e703544f56bd58d14e8b8654f48582d.png"  align="left">

<p>分析：<br>题目要求图案的层数需要用户自定义输入，可以定义变量n来代表层数。<br>根据观察可以发现图中星号规律，即第n层就会有n个星号。可以通过两层嵌套for循环实现，外层for循环控制层数，内层for循环控制每一层星号的数量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>; </span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入层数：&gt;&quot;</span>); <span class="comment">//提示用户输入层数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">//将用户输入的值存储到变量n中</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//变量i控制层数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) <span class="comment">//变量j控制每一层星号数量</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);  <span class="comment">//打印星号</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">//一层星号输出完毕后换行进行下一层星号输出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h1 id="三、猜数字游戏"><a href="#三、猜数字游戏" class="headerlink" title="三、猜数字游戏"></a>三、猜数字游戏</h1><p>题目：随机生成一个数字（1-100范围）让用户猜，当用户猜测的数字大于实际的数字时候提醒猜大了，当用户猜测的数字小于实际的数字时候提醒猜小了，直到猜对为止。并询问是否还要再玩一把</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 play  0 exit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = rand() % <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//生成范围1-100内的随机数</span></span><br><span class="line">    <span class="type">int</span> guess;  <span class="comment">//用户猜的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏开始，数字范围为1-100 ：》&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">        <span class="keyword">if</span> (guess &gt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜大了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜小了\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，猜对了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请再猜：&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>)); <span class="comment">//随机数种子</span></span><br><span class="line">    <span class="type">int</span> choose;  <span class="comment">//接受用户选择， 1是玩游戏 0是退出 </span></span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        menu(); <span class="comment">//打印游戏选择菜单</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择：》&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">        <span class="keyword">switch</span> (choose) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            game(); <span class="comment">//进入猜数字游戏函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>); <span class="comment">//退出游戏</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;选择错误，请输入 1 | 0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (choose); <span class="comment">//用户选择0即退出整个程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line"><span class="number">1</span> play  <span class="number">0</span> <span class="built_in">exit</span></span><br><span class="line">--------------</span><br><span class="line">请选择：》<span class="number">1</span></span><br><span class="line">游戏开始，数字范围为<span class="number">1</span><span class="number">-100</span> ：》<span class="number">50</span></span><br><span class="line">猜小了</span><br><span class="line">请再猜：&gt;<span class="number">70</span></span><br><span class="line">猜小了</span><br><span class="line">请再猜：&gt;<span class="number">80</span></span><br><span class="line">猜小了</span><br><span class="line">请再猜：&gt;<span class="number">90</span></span><br><span class="line">猜大了</span><br><span class="line">请再猜：&gt;<span class="number">85</span></span><br><span class="line">猜大了</span><br><span class="line">请再猜：&gt;<span class="number">83</span></span><br><span class="line">猜小了</span><br><span class="line">请再猜：&gt;<span class="number">84</span></span><br><span class="line">恭喜你，猜对了</span><br><span class="line">--------------</span><br><span class="line"><span class="number">1</span> play  <span class="number">0</span> <span class="built_in">exit</span></span><br><span class="line">--------------</span><br><span class="line">请选择：》<span class="number">0</span></span><br><span class="line">退出成功</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
  </entry>
  <entry>
    <title>变量与static关键字</title>
    <url>/%E5%8F%98%E9%87%8F%E4%B8%8Estatic%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>一、变量</p>
<p><strong>变量：在内存中开辟一段空间，存储对应的值。这个空间存储的值是可以改变的</strong><br><strong>变量声明：告诉编译器有个变量，编译器在内存中开辟一段空间，若没有赋值，则存储的值是一个随机值</strong><br>变量声明语法：&emsp;类型 变量名; &emsp;如 int  i;即有个变量为i, i为int类型</p>
 <img src="https://i-blog.csdnimg.cn/blog_migrate/9a9b180bfce542578b4540ccf714b6b4.png"   width="50%">

<span id="more"></span>

<h2 id="1-1-全局变量与局部变量"><a href="#1-1-全局变量与局部变量" class="headerlink" title="1.1 全局变量与局部变量"></a>1.1 全局变量与局部变量</h2><p><strong>全局变量</strong>：定义在代码块 { }之外的变量<br><strong>局部变量</strong>：定义在代码块 { }之内的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s = <span class="number">20</span>; <span class="comment">//全局变量s</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">30</span>; <span class="comment">//局部变量j</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;局部变量： j = %d\n&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//局部变量i</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> z = <span class="number">40</span>; <span class="comment">//局部变量z</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;局部变量： z = %d\n&quot;</span>, z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;全局变量：s = %d\n&quot;</span>, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;局部变量：i = %d\n&quot;</span>, i);</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">局部变量：z = <span class="number">40</span></span><br><span class="line">全局变量：s = <span class="number">20</span></span><br><span class="line">局部变量：i = <span class="number">10</span></span><br><span class="line">局部变量：j = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>当全局变量与局部变量同名时，局部变量优先</strong>，所以建议名字不要相同，以免产生误会</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">20</span>; <span class="comment">//全局变量i</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//局部变量i</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><font color='red'> c++中可以通过域作用运算符<code>::</code>，放在变量前面，表示访问同名全局变量 </font></p>
<h2 id="1-2-变量的作用域"><a href="#1-2-变量的作用域" class="headerlink" title="1.2 变量的作用域"></a>1.2 变量的作用域</h2><p><strong>作用域：变量的有效范围，即变量在哪一部分代码范围内可以使用</strong><br><strong>全局变量作用域是整个项目<br>局部变量作用域是定义变量所在代码块{ }内</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">10</span>; <span class="comment">//局部变量i只在定义代码块&#123; &#125;内生效</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">//编译器会报错误，i为未声明变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>a.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>test.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num; <span class="comment">//引用其他文件的全局变量要使用extern关键字声明，告诉编译器去其他源文件内寻找num变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;全局变量 j = %d\n&quot;</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a.c文件的全局变量 num = %d\n&quot;</span>, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">全局变量 j = <span class="number">20</span></span><br><span class="line">a.c文件的全局变量 num = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-变量的生命周期"><a href="#1-3-变量的生命周期" class="headerlink" title="1.3 变量的生命周期"></a>1.3 变量的生命周期</h2><p><strong>生命周期：变量的生命周期指的是从变量创建到变量的销毁之间的一个时间段</strong><br>局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束。<br>全局变量的生命周期是：整个程序的生命周期。</p>
<h1 id="二、static关键字"><a href="#二、static关键字" class="headerlink" title="二、static关键字"></a>二、static关键字</h1><h2 id="2-1-修饰全局变量"><a href="#2-1-修饰全局变量" class="headerlink" title="2.1 修饰全局变量"></a>2.1 修饰全局变量</h2><p>static修饰全局变量：<strong>改变了变量的作用域</strong>，让静态全局变量只能在自己所在源文件内部使用，出了源文件就无法使用</p>
<p>a.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">//使用static修饰全局变量，使之成为静态全局变量</span></span><br></pre></td></tr></table></figure>

<p>test.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a.c文件的全局变量 num = %d\n&quot;</span>, num); <span class="comment">//错误，num变量作用域只能在a.c源文件内</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-修饰局部变量"><a href="#2-2-修饰局部变量" class="headerlink" title="2.2 修饰局部变量"></a>2.2 修饰局部变量</h2><p>static修饰局部变量：改变了变量的<strong>生命周期</strong>，局部变量生命周期变长，等同于程序生命周期<br>，但局部变量<strong>作用域不改变</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;  <span class="comment">//n为局部变量，进入函数n创建，出函数n变量销毁，所以调用多次，返回值也是1</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d次调用 n = %d\n&quot;</span>, i, test());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">2</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">3</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">4</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">5</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">6</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">7</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">8</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">9</span>次调用 n = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>使用static关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d次调用 n = %d\n&quot;</span>, i, test());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次调用 n = <span class="number">1</span></span><br><span class="line">第<span class="number">2</span>次调用 n = <span class="number">2</span></span><br><span class="line">第<span class="number">3</span>次调用 n = <span class="number">3</span></span><br><span class="line">第<span class="number">4</span>次调用 n = <span class="number">4</span></span><br><span class="line">第<span class="number">5</span>次调用 n = <span class="number">5</span></span><br><span class="line">第<span class="number">6</span>次调用 n = <span class="number">6</span></span><br><span class="line">第<span class="number">7</span>次调用 n = <span class="number">7</span></span><br><span class="line">第<span class="number">8</span>次调用 n = <span class="number">8</span></span><br><span class="line">第<span class="number">9</span>次调用 n = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-修饰函数"><a href="#2-3-修饰函数" class="headerlink" title="2.3 修饰函数"></a>2.3 修饰函数</h2><p>static修饰函数：<strong>改变了函数的作用域</strong>，让静态函数只能在自己所在源文件内部使用，出了源文件就无法使用</p>
<p>a.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123; <span class="comment">// 使用static修饰函数，使之成为静态函数</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">//错误，add函数作用域只能在a.c源文件内使用</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C language</category>
      </categories>
  </entry>
  <entry>
    <title>radosgw多站点</title>
    <url>/radosgw%E5%A4%9A%E7%AB%99%E7%82%B9.html</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-概念与术语"><a href="#1-1-概念与术语" class="headerlink" title="1.1 概念与术语"></a>1.1 概念与术语</h2><p><strong>radosgw多站点</strong>指的是在多个地理位置或数据中心之间进行数据复制和同步，用于实现负载均衡、灾备恢复以及满足数据在特定地理位置存储要求。</p>
<ul>
<li><p><strong>zone</strong>:<br>  多站点中最小的配置单元，通俗指在同一地域内，电力和网络互相独立的物理区域。每个 zone 都有一个或多个 ceph-radosgw 实例。</p>
</li>
<li><p><strong>zone group</strong>:</p>
<p>  由一个或多zone组成，包含一个master zone，其它zone称为secondary zone，zone group内的zone之间同步数据，以实现数据备份和灾难恢复。并且支持active-active与active-passive两种模式。</p>
</li>
<li><p><strong>realm</strong>:</p>
<p>  由一个或多zone group组成，包含一个master zone group,其它zone group称为secondary zone group。</p>
</li>
</ul>
<ul>
<li><p><strong>period</strong>：</p>
<p>  跟踪zone、zone group和realm的配置状态。</p>
</li>
</ul>
<span id="more"></span>

<p><strong>中英文对照表</strong></p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>zone</td>
<td>区域或站点</td>
</tr>
<tr>
<td>master zone</td>
<td>主区域或主站点</td>
</tr>
<tr>
<td>secondary zone</td>
<td>备区域或备站点</td>
</tr>
<tr>
<td>zone group</td>
<td>区域组</td>
</tr>
<tr>
<td>master zone group</td>
<td>主区域组</td>
</tr>
<tr>
<td>secondary zone group</td>
<td>备区域组</td>
</tr>
<tr>
<td>realm</td>
<td>域</td>
</tr>
</tbody></table>
<h2 id="1-2-演示环境说明"><a href="#1-2-演示环境说明" class="headerlink" title="1.2 演示环境说明"></a>1.2 演示环境说明</h2><div align=center><img src="radosgw多站点/rgw_multisite.png"></div>

<p>演示环境为单realm下的单zone group，zone group内有两个zone。<font color=red><strong>bingo-A为已存放数据的老集群，准备作为主站点，bingo-B为未存放数据的新集群，用来作为灾备的备站点</strong></font>。bingo-A与bingo-B的Ceph版本为12.2.x。</p>
<h1 id="二、主站点配置"><a href="#二、主站点配置" class="headerlink" title="二、主站点配置"></a>二、主站点配置</h1><h2 id="2-1-主站点环境查看"><a href="#2-1-主站点环境查看" class="headerlink" title="2.1 主站点环境查看"></a>2.1 主站点环境查看</h2><p>radosgw安装后会在Ceph集群创建一些带有<code>rgw</code>的名字的pool。如果上传过对象还会自动创建<code>default.rgw.buckets.index</code>和<code>default.rgw.buckets.data</code>这两个pool。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# ceph osd pool <span class="built_in">ls</span> | grep rgw</span><br><span class="line">.rgw.root</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br><span class="line">default.rgw.buckets.index</span><br><span class="line">default.rgw.buckets.data</span><br></pre></td></tr></table></figure>

<p>bingo-A已经存放了数据，为后续测试向bingo-B数据同步做铺垫。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# ceph <span class="built_in">df</span></span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE        AVAIL       RAW USED     %RAW USED </span><br><span class="line">    1.83TiB     1.81TiB      14.0GiB          0.75 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                          ID      USED        %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    .rgw.root                     157     1.09KiB         0        440GiB           4 </span><br><span class="line">    default.rgw.control           158          0B         0        440GiB           8 </span><br><span class="line">    default.rgw.meta              159        786B         0        440GiB           5 </span><br><span class="line">    default.rgw.log               160          0B         0        440GiB         175 </span><br><span class="line">    default.rgw.buckets.index     161          0B         0        440GiB          16 </span><br><span class="line">    default.rgw.buckets.data      162     15.3MiB         0        440GiB           5  <span class="comment"># 已存有数据</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意：配置主站点前如果<code>ceph.conf</code>中有<code>rgw_admin_entry</code>选项请先删掉。</strong></font></p>
<h2 id="2-2-创建域"><a href="#2-2-创建域" class="headerlink" title="2.2 创建域"></a>2.2 创建域</h2><p>radosgw多站点中，可能存在不同的zone group和zone。然而，它们必须在realm中协同工作。所有的radosgw从master zone group的master zone主机上的<code>ceph-radosgw</code>守护进程检索其配置。</p>
<h3 id="2-2-1创建前查看"><a href="#2-2-1创建前查看" class="headerlink" title="2.2.1创建前查看"></a>2.2.1创建前查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,   <span class="comment"># 可以看到当前没有realm</span></span><br><span class="line">    <span class="string">&quot;realms&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-创建"><a href="#2-2-2-创建" class="headerlink" title="2.2.2  创建"></a>2.2.2  创建</h3><p><code>radosgw-admin realm create --rgw-realm=&#123;realm-name&#125; [--default]</code></p>
<ul>
<li><p>参数说明：</p>
<p>  –default：设置该realm为默认realm。如果没有指定 <code>--default</code>，添加 zone-groups 和zone需要指定 <code>--rgw-realm 标志或 --realm-id</code> 标志，以便在添加 zone group 和 zone 时标识realm。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 在创建了realm 后，radosgw-admin 将回显 realm 配置</span><br><span class="line">[root@node-10 ~]# radosgw-admin realm create --rgw-realm=gz --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-验证"><a href="#2-2-3-验证" class="headerlink" title="2.2.3 验证"></a>2.2.3 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-重命名默认区域组和区域"><a href="#2-3-重命名默认区域组和区域" class="headerlink" title="2.3 重命名默认区域组和区域"></a>2.3 重命名默认区域组和区域</h2><h3 id="2-3-1-重命名前查看"><a href="#2-3-1-重命名前查看" class="headerlink" title="2.3.1 重命名前查看"></a>2.3.1 重命名前查看</h3><p>通常情况下，radosgw启动后会自动创建一个名为<strong>default</strong>的zone group，并且会在该zone group下自动创建一个名为<strong>default</strong>的zone。可以通过下面命令查看验证。</p>
<p><code>radosgw-admin zonegroup list </code> ：查看所有的zone group</p>
<p><code>radosgw-admin zonegroup get --rgw-zonegroup=&#123;zone-group-name&#125;</code>：查看某个zone group详细信息</p>
<p><code>radosgw-admin zone list </code> ：查看所有的zone</p>
<p><code>radosgw-admin zone get --rgw-zone=&#123;zone-name&#125;</code>：查看某个zone详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get --rgw-zonegroup=default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone list</span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone get --rgw-zone=default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-重命名"><a href="#2-3-2-重命名" class="headerlink" title="2.3.2 重命名"></a>2.3.2 重命名</h3><p><code>radosgw-admin zonegroup rename --rgw-zonegroup &#123;zone-group-name&#125; --zonegroup-new-name=&#123;new-zone-group-name&#125;</code></p>
<p><code> radosgw-admin zone rename --rgw-zonegroup &#123;zone-group-name&#125; --rgw-zone &#123;zone name&#125; --zone-new-name=&#123;new-zone-name&#125;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup rename --rgw-zonegroup default --zonegroup-new-name=bingo</span><br><span class="line">[root@node-10 ~]# radosgw-admin zone rename --rgw-zonegroup bingo --rgw-zone default --zone-new-name=bingo-A</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-验证"><a href="#2-3-3-验证" class="headerlink" title="2.3.3 验证"></a>2.3.3 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123; <span class="comment"># 如果还有名为default的zone group不用在意</span></span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;bingo&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get --rgw-zonegroup=bingo</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>, <span class="comment"># id 没有变</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>, <span class="comment"># zone group已改名</span></span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone list</span><br><span class="line">&#123; <span class="comment"># 如果还有名为default的zone不用在意</span></span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;bingo-A&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone get --rgw-zone=bingo-A</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># id没有改变</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>, <span class="comment"># zone已改名</span></span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-设置主区域组和主区域"><a href="#2-4-设置主区域组和主区域" class="headerlink" title="2.4 设置主区域组和主区域"></a>2.4 设置主区域组和主区域</h2><h3 id="2-4-1-设置主区域组"><a href="#2-4-1-设置主区域组" class="headerlink" title="2.4.1 设置主区域组"></a>2.4.1 设置主区域组</h3><p><code>radosgw-admin zonegroup modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --endpoints=&#123;url&#125; --master --default</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup modify --rgw-realm=gz --rgw-zonegroup=bingo --endpoints=http://10.16.205.10:80 --master --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># master zone group</span></span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-设置主区域"><a href="#2-4-2-设置主区域" class="headerlink" title="2.4.2 设置主区域"></a>2.4.2 设置主区域</h3><p><code>radosgw-admin zone modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125; --master --default </code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-realm=gz --rgw-zonegroup=bingo --rgw-zone=bingo-A --endpoints=http://10.16.205.10:80 --master --default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-验证"><a href="#2-4-3-验证" class="headerlink" title="2.4.3 验证"></a>2.4.3 验证</h3><p><code>radosgw-admin zonegroup get [ --rgw-zonegroup=&#123;zone-group-name&#125; ]</code></p>
<p>说明：</p>
<ul>
<li>在2.4.1节设置主区域组的时候已将bingo设置为default zone group，以后zone group操作如果没有指定名字，则默认是bingo这个zone group。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-创建系统同步用户"><a href="#2-5-创建系统同步用户" class="headerlink" title="2.5 创建系统同步用户"></a>2.5 创建系统同步用户</h2><p>secondary zone必须向master zone获取realm和period用于数据同步，获取前需要进行身份验证，我们需要在master zone上创建一个系统级别用户用于身份验证。</p>
<h3 id="2-5-1-创建前查看"><a href="#2-5-1-创建前查看" class="headerlink" title="2.5.1 创建前查看"></a>2.5.1 创建前查看</h3><p><code>radosgw-admin user info --uid=&#123;user-name&#125;</code>：查看用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user info --uid=sync-user</span><br><span class="line">could not fetch user info: no user info saved <span class="comment"># 此用户名不存在，可以创建</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-创建"><a href="#2-5-2-创建" class="headerlink" title="2.5.2 创建"></a>2.5.2 创建</h3><p><code>radosgw-admin user create --uid=&quot;&#123;user-name&#125;&quot; --display-name=&quot;&#123;display-name&#125;&quot; --system</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user create --uid=<span class="string">&quot;sync-user&quot;</span> --display-name=<span class="string">&quot;Sync User&quot;</span> --system</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display_name&quot;</span>: <span class="string">&quot;Sync User&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;suspended&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;max_buckets&quot;</span>: 100,</span><br><span class="line">    <span class="string">&quot;auid&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;subusers&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;keys&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;swift_keys&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;caps&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;op_mask&quot;</span>: <span class="string">&quot;read, write, delete&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 系统级别用户</span></span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;placement_tags&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;bucket_quota&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;check_on_raw&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;max_size&quot;</span>: -1,</span><br><span class="line">        <span class="string">&quot;max_size_kb&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;max_objects&quot;</span>: 10000000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;rgw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-验证"><a href="#2-5-3-验证" class="headerlink" title="2.5.3 验证"></a>2.5.3 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user info --uid=sync-user</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display_name&quot;</span>: <span class="string">&quot;Sync User&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;suspended&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;max_buckets&quot;</span>: 100,</span><br><span class="line">    <span class="string">&quot;auid&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;subusers&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;keys&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;swift_keys&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;caps&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;op_mask&quot;</span>: <span class="string">&quot;read, write, delete&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 系统级别用户</span></span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;placement_tags&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;bucket_quota&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;check_on_raw&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;max_size&quot;</span>: -1,</span><br><span class="line">        <span class="string">&quot;max_size_kb&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;max_objects&quot;</span>: 10000000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;rgw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-绑定域"><a href="#2-6-绑定域" class="headerlink" title="2.6 绑定域"></a>2.6 绑定域</h2><p>将zone和zone group与realm绑定。</p>
<h3 id="2-6-1-绑定前查看"><a href="#2-6-1-绑定前查看" class="headerlink" title="2.6.1 绑定前查看"></a>2.6.1 绑定前查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-绑定realm"><a href="#2-6-2-绑定realm" class="headerlink" title="2.6.2 绑定realm"></a>2.6.2 绑定realm</h3><p><code>radosgw-admin zone modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125; --access-key=&#123;key&#125; --secret=&#123;key&#125; --master --default</code></p>
<p><strong>说明：<code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-realm=<span class="string">&quot;gz&quot;</span> --rgw-zonegroup=<span class="string">&quot;bingo&quot;</span> --rgw-zone=<span class="string">&quot;bingo-A&quot;</span> --endpoints=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti --master --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span> <span class="comment"># 与gz这个realm绑定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-验证"><a href="#2-6-3-验证" class="headerlink" title="2.6.3 验证"></a>2.6.3 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-应用变更"><a href="#2-7-应用变更" class="headerlink" title="2.7 应用变更"></a>2.7 应用变更</h2><p>应用变更period，同一个zone group的其它zone会接收新的配置变更。</p>
<h3 id="2-7-1-变更前查看"><a href="#2-7-1-变更前查看" class="headerlink" title="2.7.1 变更前查看"></a>2.7.1 变更前查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-变更"><a href="#2-7-2-变更" class="headerlink" title="2.7.2 变更"></a>2.7.2 变更</h3><p><code> radosgw-admin period update --commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2 <span class="comment"># epoch从1变为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-验证"><a href="#2-7-3-验证" class="headerlink" title="2.7.3 验证"></a>2.7.3 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2 <span class="comment"># epoch从1变为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-重启服务"><a href="#2-8-重启服务" class="headerlink" title="2.8 重启服务"></a>2.8 重启服务</h2><p>更新master zone主机上的<code>ceph.conf</code>配置文件，添加<code>rgw_zone</code>配置选项。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[client.radosgw]下添加配置:</span><br><span class="line">rgw<span class="built_in">_</span>zone=bingo-A</span><br></pre></td></tr></table></figure>

<p>重启radosgw服务</p>
<p><code> systemctl restart ceph-radosgw@radosgw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<h2 id="2-9-查看同步状态"><a href="#2-9-查看同步状态" class="headerlink" title="2.9 查看同步状态"></a>2.9 查看同步状态</h2><p><code>radosgw-admin sync status</code> ：查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-A为主站点</span></span><br></pre></td></tr></table></figure>

<h1 id="三、备站点配置"><a href="#三、备站点配置" class="headerlink" title="三、备站点配置"></a>三、备站点配置</h1><h2 id="3-1-备站点环境查看"><a href="#3-1-备站点环境查看" class="headerlink" title="3.1 备站点环境查看"></a>3.1 备站点环境查看</h2><p>通常情况下，radosgw启动后会自动创建一个名为<strong>default</strong>的zone group，并且会在该zone group下自动创建一个名为<strong>default</strong>的zone。可以通过下面命令查看验证。</p>
<p><code>radosgw-admin zonegroup list</code> ：查看所有的zone group</p>
<p><code>radosgw-admin zone list</code> ：查看所有的zone</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;bd5c6fa4-695f-4017-8bc1-fd2fe5ee045f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;f01ddceb-92cb-4ffb-850f-099df6aecaab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>radosgw启动后会在集群中自动创建一些带有<code>rgw</code>名字的pool，<font color=red>本演示环境中bingo-B为全新集群，里面没存储任何数据。</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph osd pool <span class="built_in">ls</span> | grep rgw</span><br><span class="line">.rgw.root</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br></pre></td></tr></table></figure>

<p><font color=red>假设使用新安装的集群进行多站点配置，尚未使用默认<code>zone</code>及其<code>pool</code>来存储数据，那么可以把默认<code>zone</code>和<code>pool</code>删除。如果已存在数据将会丢失并不可恢复。</font></p>
<p>删除默认zone</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone delete --rgw-zone=default</span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除radosgw自动创建的默认pool（务必确认rgw尚未存数据）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph osd pool <span class="built_in">ls</span> | grep -F default.rgw.</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.control default.rgw.control --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.control</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.meta default.rgw.meta --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.meta</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.log default.rgw.log --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.log</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意：配置备站点前如果<code>ceph.conf</code>配置文件中有 <code>rgw_admin_entry</code>选项请先删掉此选项。</strong></font></p>
<h2 id="3-2-从主站点拉取域"><a href="#3-2-从主站点拉取域" class="headerlink" title="3.2 从主站点拉取域"></a>3.2 从主站点拉取域</h2><p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p>
<p>说明：</p>
<ul>
<li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti </span><br><span class="line">2023-09-10 19:04:56.407005 7f1b46286f80  1 error read_lastest_epoch .rgw.root:periods.2a11b308-6430-47d2-8059-76894abfb74c.latest_epoch <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:04:56.567897 7f1b46286f80  1 Set the period<span class="string">&#x27;s master zonegroup 89129545-7900-46a3-be71-943a85bba582 as the default</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;id&quot;: &quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;,</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;gz&quot;,</span></span><br><span class="line"><span class="string">    &quot;current_period&quot;: &quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;,</span></span><br><span class="line"><span class="string">    &quot;epoch&quot;: 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>设置<code>gz</code>为默认realm。</p>
<p><code>radosgw-admin realm default --rgw-realm=&#123;realm-name&#125;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm default --rgw-realm=gz</span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm get-default</span><br><span class="line">default realm: 31a49490-d7f4-42c6-ad88-15493474a3d5</span><br></pre></td></tr></table></figure>

<h2 id="3-3-从主站点拉取-period"><a href="#3-3-从主站点拉取-period" class="headerlink" title="3.3 从主站点拉取 period"></a>3.3 从主站点拉取 period</h2><p><code>radosgw-admin period pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p>
<p>说明：<code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period  pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti </span><br><span class="line">2023-09-10 19:07:24.203099 7f084e32ff80  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-创建备区域"><a href="#3-4-创建备区域" class="headerlink" title="3.4 创建备区域"></a>3.4 创建备区域</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">radosgw-admin zone create --rgw-zonegroup=&#123;zone-group-name&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                          --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                           --access-key=&#123;system-key&#125; --secret=&#123;secret&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                           [--read-only]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>–read-only：默认所有zone都以<code>active-active</code>模式运行；即客户端可能会将数据写入任何zone，zone会将数据复制到 zone group 中的所有其他 zone。如果 second zone 不接受写操作，请指定 <code>--read-only</code> 标志，以<code>active-passive</code>模式运行。</li>
<li><font color=red >本次演示环境会将bingo-B zone设置为read-only。</font></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone create --rgw-zonegroup=bingo --rgw-zone=bingo-B --endpoints=http://10.3.23.136:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti --read-only</span><br><span class="line">2023-09-10 19:10:40.661862 7faea03c2f80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:10:40.661947 7faea03c2f80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可以忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span> <span class="comment"># url为bingo-B的radosgw地址</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-应用变更"><a href="#3-5-应用变更" class="headerlink" title="3.5 应用变更"></a>3.5 应用变更</h2><p>应用变更period，其他zone会接收新的配置。</p>
<p><code>radosgw-admin period update --commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">2023-09-10 19:13:52.621606 7fb130a12f80  1 Cannot find zone <span class="built_in">id</span>=3b06b85f-8266-4e44-91ee-e0b334f619c5 (name=bingo-B), switching to <span class="built_in">local</span> zonegroup configuration <span class="comment"># 该信息可忽略</span></span><br><span class="line">Sending period to new master zone 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-重启服务"><a href="#3-6-重启服务" class="headerlink" title="3.6 重启服务"></a>3.6 重启服务</h2><p>更新备站点主机上的<code>ceph.conf</code>配置文件，添加<code>rgw_zone</code>配置选项。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[client.radosgw]下添加配置:</span><br><span class="line">rgw<span class="built_in">_</span>zone=bingo-B</span><br></pre></td></tr></table></figure>

<p>重启radosgw服务</p>
<p><code> systemctl restart ceph-radosgw@radosgw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<h2 id="3-7-验证同步"><a href="#3-7-验证同步" class="headerlink" title="3.7 验证同步"></a>3.7 验证同步</h2><p><code>radosgw-admin sync status</code>：查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing</span><br><span class="line">                full <span class="built_in">sync</span>: 3/64 shards</span><br><span class="line">                full <span class="built_in">sync</span>: 2 entries to <span class="built_in">sync</span></span><br><span class="line">                incremental <span class="built_in">sync</span>: 61/64 shards</span><br><span class="line">                metadata is behind on 3 shards</span><br><span class="line">                behind shards: [28,44,61]</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 16/128 shards</span><br><span class="line">                        full <span class="built_in">sync</span>: 16 buckets to <span class="built_in">sync</span></span><br><span class="line">                        incremental <span class="built_in">sync</span>: 112/128 shards</span><br><span class="line">                        data is behind on 16 shards</span><br><span class="line">                        behind shards: [50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65] <span class="comment"># 数据同步中</span></span><br><span class="line"><span class="comment"># 数据同步时间与数据量大小有关，可以隔一段时间再查看同步是否完成 </span></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-B为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span> <span class="comment"># 数据同步完成</span></span><br></pre></td></tr></table></figure>

<p>查看pool中是否有从<code>bingo-A master zone</code>同步过来的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph <span class="built_in">df</span></span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE       AVAIL      RAW USED     %RAW USED </span><br><span class="line">    240GiB     239GiB       502MiB          0.20 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                          ID      USED        %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    .rgw.root                     96      5.20KiB         0       75.8GiB          19 </span><br><span class="line">    bingo-B.rgw.control           100          0B         0       75.8GiB           8 </span><br><span class="line">    bingo-B.rgw.meta              101     1.12KiB         0       75.8GiB           7 </span><br><span class="line">    bingo-B.rgw.log               102     7.87KiB         0       75.8GiB         565 </span><br><span class="line">    default.rgw.meta              103          0B         0       75.8GiB           0 </span><br><span class="line">    bingo-B.rgw.buckets.index     104          0B         0       75.8GiB          16 </span><br><span class="line">    bingo-B.rgw.buckets.data      105     15.3MiB      0.02       75.8GiB           5 <span class="comment"># 数据通过过来了</span></span><br></pre></td></tr></table></figure>

<h1 id="四、故障切换和灾难恢复"><a href="#四、故障切换和灾难恢复" class="headerlink" title="四、故障切换和灾难恢复"></a>四、故障切换和灾难恢复</h1><h2 id="4-1-故障切换"><a href="#4-1-故障切换" class="headerlink" title="4.1 故障切换"></a>4.1 故障切换</h2><p>模拟<code>bingo-A master zone</code>故障，切换到<code>bingo-B secondary zone</code>。</p>
<h3 id="4-1-1-模拟主站点故障"><a href="#4-1-1-模拟主站点故障" class="headerlink" title="4.1.1 模拟主站点故障"></a>4.1.1 模拟主站点故障</h3><p>可将<code>bingo-A</code>的radosgw服务停止来模拟发生了故障。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl stop ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-切换到备站点"><a href="#4-1-2-切换到备站点" class="headerlink" title="4.1.2 切换到备站点"></a>4.1.2 切换到备站点</h3><p>在<code>bingo-B</code>上查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">2023-09-10 19:19:25.833927 7f02e814ff80  0 meta <span class="built_in">sync</span>: ERROR: failed to fetch mdlog info</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># 可以发现同步异常</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                failed to fetch <span class="built_in">local</span> <span class="built_in">sync</span> status: (5) Input/output error</span><br><span class="line">2023-09-10 19:19:25.835667 7f02e814ff80  0 data <span class="built_in">sync</span>: ERROR: failed to fetch datalog info</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        failed to retrieve <span class="built_in">sync</span> info: (5) Input/output error</span><br></pre></td></tr></table></figure>

<p>将<code>bingo-B</code> secondary zone设置为master和default zone。</p>
<p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default [ --read-only=false ]</code></p>
<p>说明：</p>
<ul>
<li>由于<code>bingo-B</code>zone为read-only，现在设置其为master zone需要将read-only取消，客户端才能写数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --master --default --read-only=<span class="literal">false</span></span><br><span class="line">2023-09-10 19:20:21.908757 7f746122ff80  0 NOTICE: overriding master zone: 2dfd246d-bf16-4053-93e4-1f78570f775b </span><br><span class="line">2023-09-10 19:20:21.909132 7f746122ff80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:20:21.909158 7f746122ff80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可以忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证<code>bingo-B</code>是否为master zone</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>, <span class="comment"># bingo-B为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>, <span class="comment"># 客户端可以写入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用变更。</p>
<p><code>radosgw-admin period update --commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-B</code>上重新启动radosgw服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<p>查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-B为主站点了</span></span><br><span class="line">2023-09-10 19:25:56.038789 7fefb3febf80  0 data <span class="built_in">sync</span>: ERROR: failed to fetch datalog info <span class="comment"># bingo-A故障了</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        failed to retrieve <span class="built_in">sync</span> info: (5) Input/output error</span><br></pre></td></tr></table></figure>

<h2 id="4-2-灾难恢复"><a href="#4-2-灾难恢复" class="headerlink" title="4.2 灾难恢复"></a>4.2 灾难恢复</h2><p>假设<code>bingo-A</code>恢复正常了，现在重新将master zone切换到<code>bingo-A</code>。</p>
<h3 id="4-2-1-主站点恢复"><a href="#4-2-1-主站点恢复" class="headerlink" title="4.2.1 主站点恢复"></a>4.2.1 主站点恢复</h3><p>将之前模拟故障的<code>bingo-A</code>的radosgw服务重新启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl status ceph-radosgw@radosgw</span><br><span class="line">○ ceph-radosgw@radosgw.service - Ceph rados gateway</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/ceph-radosgw@.service; enabled; vendor preset: disabled)</span><br><span class="line">     Active: inactive (dead) since 2023-09-10 19:27:01 CST; 11min ago</span><br><span class="line">    Process: 204125 ExecStart=/usr/bin/radosgw -f --cluster <span class="variable">$&#123;CLUSTER&#125;</span> --name client.radosgw --setuser ceph --setgroup ceph (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 204125 (code=exited, status=0/SUCCESS)</span><br><span class="line">[root@node-10 ~]# systemctl start ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# systemctl status ceph-radosgw@radosgw</span><br><span class="line">● ceph-radosgw@radosgw.service - Ceph rados gateway</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/ceph-radosgw@.service; enabled; vendor preset: disabled)</span><br><span class="line">     Active: active (running) since Sun 2023-09-10 19:27:08 CST; 30s ago</span><br><span class="line">   Main PID: 267097 (radosgw)</span><br><span class="line">      Tasks: 593</span><br><span class="line">     Memory: 51.9M</span><br><span class="line">     CGroup: /system.slice/system-ceph\x2dradosgw.slice/ceph-radosgw@radosgw.service</span><br><span class="line">             └─ 267097 /usr/bin/radosgw -f --cluster ceph --name client.radosgw --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure>

<p>查看当前<code>bingo-A</code>同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-A现在为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>在<code>bingo-A</code>上拉取realm</p>
<p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p>
<p>说明：</p>
<ul>
<li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm pull --url=http://10.3.23.136:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti</span><br><span class="line">2023-09-10 19:31:52.430554 7fe3e6f4e080  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-A</code>的radosgw上将<code>bingo-A</code>重新设为master和default zone。</p>
<p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-zone=bingo-A --master --default</span><br><span class="line">2023-09-10 19:32:19.697172 7fcb30974080  0 NOTICE: overriding master zone: 3b06b85f-8266-4e44-91ee-e0b334f619c5</span><br><span class="line">2023-09-10 19:32:19.698813 7fcb30974080  0 failed reading obj info from .rgw.root:zone_info.3b06b85f-8266-4e44-91ee-e0b334f619c5: (2) No such file or directory <span class="comment"># 该错误信息可忽略</span></span><br><span class="line">2023-09-10 19:32:19.698831 7fcb30974080  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=3b06b85f-8266-4e44-91ee-e0b334f619c5 name=bingo-B <span class="comment"># 该警告信息可忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-A</code>上应用更新。</p>
<p><code>radosgw-admin period update --commit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># bingo-A为master zone</span></span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-A</code>上重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<p>查看<code>bingo-A</code>同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-A变为主站点</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-设置备站点"><a href="#4-2-2-设置备站点" class="headerlink" title="4.2.2 设置备站点"></a>4.2.2 设置备站点</h3><p>在<code>bingo-B</code>上查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># 可以看到bingo-B现在还是master zone，需要拉取最新的realm</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>在<code>bingo-B</code>上拉取realm</p>
<p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p>
<p>说明：</p>
<ul>
<li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti</span><br><span class="line">2023-09-10 19:41:25.065698 7f21fb0d7f80  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># bingo-A为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>, <span class="comment"># bingo-B现在还不是只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>我们之前规划中<code>bingo-B</code>为read-only，所以现在需要将<code>bingo-B</code>状态设置为read-only。</font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --read-only</span><br><span class="line">2023-09-10 19:42:50.451069 7f3042436f80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可忽略</span></span><br><span class="line">2023-09-10 19:42:50.451088 7f3042436f80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证<code>bingo-B</code>是否为read-only</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-B</code>上应用变更</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">Sending period to new master zone 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>bingo-B</code>上重启服务</p>
<p><code> systemctl restart ceph-radosgw@radosgw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>



<p>查看<code>bingo-B</code>同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-B变为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h1 id="五、解除主备站点同步"><a href="#五、解除主备站点同步" class="headerlink" title="五、解除主备站点同步"></a>五、解除主备站点同步</h1><p>当<code>bingo-A和bingo-B</code>两个zone不需要同步时，解除之间的同步关系。</p>
<h2 id="5-1-主站点移除备站点"><a href="#5-1-主站点移除备站点" class="headerlink" title="5.1 主站点移除备站点"></a>5.1 主站点移除备站点</h2><h3 id="5-1-1-移除备站点"><a href="#5-1-1-移除备站点" class="headerlink" title="5.1.1 移除备站点"></a>5.1.1 移除备站点</h3><p>移除前查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>移除<code>bingo-B</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup remove --rgw-zonegroup=bingo --rgw-zone=bingo-B</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-应用变更"><a href="#5-1-2-应用变更" class="headerlink" title="5.1.2 应用变更"></a>5.1.2 应用变更</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 3,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-重启服务"><a href="#5-1-3-重启服务" class="headerlink" title="5.1.3 重启服务"></a>5.1.3 重启服务</h3><p><code> systemctl restart ceph-radosgw@radosgw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<h3 id="5-1-4-验证"><a href="#5-1-4-验证" class="headerlink" title="5.1.4 验证"></a>5.1.4 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A) <span class="comment"># bingo-B同步关系已经移除</span></span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-备站点移除主站点"><a href="#5-2-备站点移除主站点" class="headerlink" title="5.2 备站点移除主站点"></a>5.2 备站点移除主站点</h2><h3 id="5-2-1-移除主站点"><a href="#5-2-1-移除主站点" class="headerlink" title="5.2.1 移除主站点"></a>5.2.1 移除主站点</h3><p>移除前查看同步状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># 在主站点移除备站点后，bingo-B没有机会更新同步信息</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>移除<code>bingo-A</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup remove --rgw-zonegroup=bingo --rgw-zone=bingo-A</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span> <span class="comment"># zone group 还指向bingo-A的radosgw地址</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># master zone还指向bingo-A</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-设置主区域"><a href="#5-2-2-设置主区域" class="headerlink" title="5.2.2 设置主区域"></a>5.2.2 设置主区域</h3><p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default [ --read-only=false ]</code></p>
<p>说明：</p>
<ul>
<li>–read-only：可选，由于<code>bingo-B</code>在规划中是read-only，现在<code>bingo-B</code>变为master zone，客户端需要写数据，要取消read-only状态</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --master --default --read-only=<span class="literal">false</span></span><br><span class="line">2023-09-10 20:03:22.646446 7f2c932a9f80  0 NOTICE: overriding master zone: 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新zone group的url</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup modify --rgw-realm=gz --rgw-zonegroup=bingo --endpoints=http://10.3.23.136:80 --master --default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span> <span class="comment"># zone group的url已经更新</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>, <span class="comment"># bingo-B为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-应用变更"><a href="#5-2-3-应用变更" class="headerlink" title="5.2.3 应用变更"></a>5.2.3 应用变更</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;8f69cdf6-13af-476a-9647-6a174ea3bcc9&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;8f69cdf6-13af-476a-9647-6a174ea3bcc9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-重启服务"><a href="#5-2-4-重启服务" class="headerlink" title="5.2.4 重启服务"></a>5.2.4 重启服务</h3><p>重启radosgw服务</p>
<p><code> systemctl restart ceph-radosgw@radosgw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure>

<h3 id="5-2-5-验证"><a href="#5-2-5-验证" class="headerlink" title="5.2.5 验证"></a>5.2.5 验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line"></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>radosgw</tag>
      </tags>
  </entry>
  <entry>
    <title>可能是最好的RPC中文文档</title>
    <url>/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84RPC%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p><strong>阅读本文需要对TCP&#x2F;IP协议簇和linux系统有一定了解。</strong></p>
<h1 id="一、RPC介绍"><a href="#一、RPC介绍" class="headerlink" title="一、RPC介绍"></a>一、RPC介绍</h1><h2 id="1-1-RPC是什么"><a href="#1-1-RPC是什么" class="headerlink" title="1.1 RPC是什么"></a>1.1 RPC是什么</h2><p><strong>RPC (Remote Procedure Call)</strong>：一个计算机通信协议，基于扩展常规或本地过程调用的概念。因此被调用过程不必与调用过程存在于同一地址空间中。这两个进程可能位于同一系统上，也可能位于不同的系统上，并通过网络连接它们。程序员就像调用本地程序一样，无需额外地为这个交互编程（无需关注细节）。<br><img src="https://i-blog.csdnimg.cn/direct/4ee4133b8b3849c99e238b9d86986592.jpeg#pic_center" alt="在这里插入图片描述"><br> 上图表示两个联网系统之间 RPC 调用流程。客户端进行过程调用，向服务器发送请求并阻塞等待，直到收到答复或请求超时。当请求到达时，服务器执行对应的请求过程，并将执行结果发送给客户端。客户端收到应答消息后被唤醒继续运行。</p>
<span id="more"></span>

<h2 id="1-2-TI-RPC-相关说明"><a href="#1-2-TI-RPC-相关说明" class="headerlink" title="1.2 TI-RPC 相关说明"></a>1.2 TI-RPC 相关说明</h2><p>TI-RPC : Transport-independent RPC. </p>
<h3 id="1-2-1-参数传递"><a href="#1-2-1-参数传递" class="headerlink" title="1.2.1 参数传递"></a>1.2.1 参数传递</h3><p>TI-RPC允许一个参数从客户端传递到服务器。如果需要多个参数，则可以将这些参数组合成一个结构体，作为一个元素。从服务器传递给客户端的信息作为函数的返回值。</p>
<h3 id="1-2-2-传输协议"><a href="#1-2-2-传输协议" class="headerlink" title="1.2.2 传输协议"></a>1.2.2 传输协议</h3><p>传输协议指定了客户端和服务器之间如何传输call message 和 reply message。TS-RPC 使用 TCP 和 UDP 作为传输协议，但当前版本的 TI-RPC 是独立于传输的，因此它可以与任何传输协议一起使用。</p>
<p>您可以编写程序在特定传输类型上运行，或者在由系统选择或用户选择的传输上运行。两种网络选择机制是 <code>/etc/netconfig</code>数据库文件和环境变量 NETPATH。这些机制可以精细控制使用哪种网络传输类型 - 用户可以指定首选传输，应用程序将在可以的情况下使用该传输。如果指定的传输不合适，应用程序会自动尝试具有正确特征的其他传输。</p>
<p><code>/etc/netconfig</code>列出了主机可用的传输方式并按类型标识它们。如果未设置 NETPATH，则系统默认使用<code>/etc/netconfig</code>中指定的所有可见传输方式，按照它们在该文件中出现的顺序。</p>
<h3 id="1-2-3-调用语义"><a href="#1-2-3-调用语义" class="headerlink" title="1.2.3 调用语义"></a>1.2.3 调用语义</h3><p>调用语义定义了客户端可以对远程过程的执行做出何种假设；特别是，该过程执行了多少次。这些语义在处理错误情况时非常重要。三种选择分是<strong>恰好一次</strong>、 <strong>最多一次</strong>和<strong>至少一次</strong>。ONC+ 提供 <strong>至少一次</strong>语义。远程调用的过程是 <strong>幂等的</strong>。它们每次被调用时都应该返回相同的结果，即使经过多次迭代也是如此。</p>
<h3 id="1-2-4-数据表示"><a href="#1-2-4-数据表示" class="headerlink" title="1.2.4 数据表示"></a>1.2.4 数据表示</h3><p>数据表示描述了在进程之间传递参数和结果时所使用的格式。为了在各种系统架构上运行，RPC 需要标准的数据表示。TI-RPC 使用外部数据表示 (XDR)。XDR 是一种独立于系统的数据描述和编码协议。使用 XDR，RPC 可以处理任意数据结构，不必在意不同主机的字节顺序或结构布局约定如何。</p>
<h2 id="1-3-远程调用标识"><a href="#1-3-远程调用标识" class="headerlink" title="1.3 远程调用标识"></a>1.3 远程调用标识</h2><p>一个远程调用由以下三元组唯一标识：</p>
<ul>
<li>Program number ：标识一个远程程序</li>
<li>Procedure number：标识一个调用过程，即调用哪个函数</li>
<li>Version number：一个调用过程可以有多个版本</li>
</ul>
<p>说明：程序名到Program numbe的映射关系可参考 <code>/etc/rpc</code>文件</p>
<h2 id="1-4-动态端口"><a href="#1-4-动态端口" class="headerlink" title="1.4 动态端口"></a>1.4 动态端口</h2><p>RPC服务监听的端口并不固定，客户端如果想要访问这些服务要先向<code>rpcbind</code>守护进程查询对应服务监听的端口。<code>rpcbind</code>监听TCP&#x2F;UDP 111端口。<code>rpcbind</code>是唯一具有已知端口的RPC 服务。</p>
<p>RPC服务（程序）启动后会向<code>rpcbind</code>注册其自身信息，包括Program number、Version、Protocol type、Port。当客户端来查询时将这些信息回复给客户端。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/0e00b09c08554dd78fcaf19eaffdac2b.jpeg#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> PMAP_PORT = <span class="number">111</span>;       <span class="comment">/* portmapper port number */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * A mapping of (program, version, protocol) to port number</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pmap</span> &#123;</span></span><br><span class="line"> 	<span class="type">rpcprog_t</span> prog;</span><br><span class="line"> 	<span class="type">rpcvers_t</span> vers;</span><br><span class="line"> 	<span class="type">rpcprot_t</span> prot;</span><br><span class="line"> 	<span class="type">rpcport_t</span> port;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Supported values for the &quot;prot&quot; field</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">const</span> IPPROTO_TCP = <span class="number">6</span>; <span class="comment">/* protocol number for TCP/IP */</span></span><br><span class="line"> <span class="type">const</span> IPPROTO_UDP = <span class="number">17</span>; <span class="comment">/* protocol number for UDP/IP */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * A list of mappings</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pmaplist</span> &#123;</span></span><br><span class="line"> 	pmap <span class="built_in">map</span>;</span><br><span class="line"> 	pmaplist *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Arguments to callit</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">call_args</span> &#123;</span></span><br><span class="line"> 	<span class="type">rpcprog_t</span> prog;</span><br><span class="line">  <span class="type">rpcvers_t</span> vers;</span><br><span class="line">  <span class="type">rpcproc_t</span> proc;</span><br><span class="line"> 	opaque args&lt;&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Results of callit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">call_result</span> &#123;</span></span><br><span class="line"> 	<span class="type">rpcport_t</span> port;</span><br><span class="line"> 	opaque res&lt;&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Port mapper procedures</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> program PMAP_PROG &#123;</span><br><span class="line"> 	version PMAP_VERS &#123;</span><br><span class="line"> 		<span class="type">void</span></span><br><span class="line"> 		<span class="title function_">PMAPPROC_NULL</span><span class="params">(<span class="type">void</span>)</span> = <span class="number">0</span>;</span><br><span class="line"> 		<span class="type">bool</span></span><br><span class="line"> 		<span class="title function_">PMAPPROC_SET</span><span class="params">(pmap)</span> = <span class="number">1</span>;</span><br><span class="line"> 		<span class="type">bool</span></span><br><span class="line"> 		<span class="title function_">PMAPPROC_UNSET</span><span class="params">(pmap)</span> = <span class="number">2</span>;</span><br><span class="line"> 		<span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"> 		<span class="title function_">PMAPPROC_GETPORT</span><span class="params">(pmap)</span> = <span class="number">3</span>;</span><br><span class="line"> 		pmaplist</span><br><span class="line"> 		<span class="title function_">PMAPPROC_DUMP</span><span class="params">(<span class="type">void</span>)</span> = <span class="number">4</span>;</span><br><span class="line"> 		call_result</span><br><span class="line"> 		<span class="title function_">PMAPPROC_CALLIT</span><span class="params">(call_args)</span> = <span class="number">5</span>;</span><br><span class="line"> 	&#125; = <span class="number">2</span>;</span><br><span class="line"> &#125; = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二、RPC协议"><a href="#二、RPC协议" class="headerlink" title="二、RPC协议"></a>二、RPC协议</h1><h2 id="2-1-协议概述"><a href="#2-1-协议概述" class="headerlink" title="2.1 协议概述"></a>2.1 协议概述</h2><p>RPC 协议提供以下内容：</p>
<ul>
<li>被调用过程的唯一规范。</li>
<li>将响应消息与请求消息进行匹配的规定。</li>
<li>提供对服务的调用者进行身份验证以及反向验证的规定，此外，RPC还提供以下功能的检测<ul>
<li>RPC协议不匹配</li>
<li>远程程序协议版本不匹配</li>
<li>协议错误，例如对过程参数指定不正确</li>
<li>远程认证失败的原因</li>
</ul>
</li>
</ul>
<p>考虑由两个程序组成的网络文件服务。一个程序可能处理高级应用程序，例如文件系统访问控制和锁定。另一个程序可能处理低级文件 I&#x2F;O，并具有读取和写入等过程。网络文件服务的客户端系统将代表客户端系统上的某个用户调用与该服务的两个程序相关联的过程。在客户端-服务器模型中，使用远程过程调用来调用服务。</p>
<h3 id="2-1-1-RPC-模型"><a href="#2-1-1-RPC-模型" class="headerlink" title="2.1.1 RPC 模型"></a>2.1.1 RPC 模型</h3><p>RPC 模型类似于本地过程调用模型。在本地情况下，调用者将过程的参数放置在某个明确指定的位置。然后，调用者将控制权移交给过程，并最终重新获得控制权。此时，从明确指定的位置提取过程的结果，然后调用者继续运行。</p>
<p>RPC 模型与之类似，一个控制线程在逻辑上会经过两个进程。一个是调用者的进程，另一个是服务器的进程。从概念上讲，调用者进程向服务器进程发送调用消息并等待回复消息。调用消息包含过程的参数以及其他信息。回复消息包含过程的结果以及其他信息。收到回复消息后，将提取过程的结果并恢复调用者的执行。</p>
<p>在服务器端，进程处于休眠状态，等待调用消息的到来。当调用消息到达时，服务器进程提取过程的参数、计算结果、发送回复消息，然后等待下一个调用消息。</p>
<p>请注意，在此描述中，两个进程中只有一个在任何给定时间处于活动状态。但是，RPC 协议对实现并发模型没有任何限制。例如，实现可能选择让 RPC 调用异步，以便客户端可以在等待服务器回复时执行有用的工作。另一种可能性是让服务器创建一个任务来处理传入的请求，以便服务器可以自由接收其他请求。</p>
<h3 id="2-1-2-传输和语义"><a href="#2-1-2-传输和语义" class="headerlink" title="2.1.2 传输和语义"></a>2.1.2 传输和语义</h3><p>RPC 协议独立于传输协议。也就是说，RPC 不考虑消息如何通过网络从一个进程传递到另一个进程。该协议仅对消息处理进行规范和解释。</p>
<p>RPC 不会尝试确保传输可靠性。因此，您必须向应用程序提供有关 RPC 下使用的传输协议类型的信息。如果您告诉 RPC 服务它在可靠的传输（如 TCP）上运行，则该服务的大部分工作已经完成。另一方面，如果 RPC 在不可靠的传输（如 UDP）上运行，则该服务必须设计自己的重新传输和超时策略。RPC 不提供此服务。</p>
<p>由于传输独立性，RPC 协议不会将特定语义附加到远程过程或其执行。语义可以从底层传输协议推断出来，但应由底层传输协议明确指定。例如，假设 RPC 在不可靠的传输上运行。如果应用程序在短时间超时后未收到回复而重新传输 RPC 消息，则它只能推断该过程已执行零次或多次。如果应用程序收到了回复，它可以推断该过程至少执行了一次。</p>
<p>服务器可以选择记住以前授予的来自客户端的请求，并且不再重新授予它们，以确保某种程度的“最多执行一次”语义。服务器可以使用与每个 RPC 请求一起打包的事务 ID 来实现这一点。此事务 ID 的主要用途是供 RPC 客户端匹配对请求的回复。但是，客户端应用程序可以选择在重新传输请求时重用其以前的事务 ID。服务器应用程序检查这一事实后，可以选择在授予请求后记住此 ID，并且不再重新授予具有相同 ID 的请求。服务器不允许以任何其他方式检查此 ID，除非将其作为相等性测试。</p>
<p>另一方面，如果使用可靠的传输（如 TCP），应用程序可以从回复消息中推断该过程只执行了一次。如果应用程序没有收到回复消息，它就不能假设远程过程没有执行。请注意，即使使用面向连接的协议（如 TCP），应用程序仍然需要超时和重新连接来处理服务器崩溃。</p>
<h2 id="2-2-RPC消息字段说明"><a href="#2-2-RPC消息字段说明" class="headerlink" title="2.2 RPC消息字段说明"></a>2.2 RPC消息字段说明</h2><h3 id="2-2-1-Program-and-Procedure-Numbers"><a href="#2-2-1-Program-and-Procedure-Numbers" class="headerlink" title="2.2.1 Program and Procedure Numbers"></a>2.2.1 Program and Procedure Numbers</h3><p>RPC call message具有三个无符号字段，用于唯一标识要调用的过程：</p>
<ul>
<li>Remote program number</li>
<li>Remote program version number</li>
<li>Remote procedure number</li>
</ul>
<p><strong>Program numbers</strong>以<code>0x20000000</code>为一组分布，如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">Program Numbers</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00000000 - 1fffffff</td>
<td align="left">Defined by host</td>
</tr>
<tr>
<td align="left">20000000 - 3fffffff</td>
<td align="left">Defined by user</td>
</tr>
<tr>
<td align="left">40000000 - 5fffffff</td>
<td align="left">Transient (reserved for customer-written applications)</td>
</tr>
<tr>
<td align="left">60000000 - 7fffffff</td>
<td align="left">Reserved</td>
</tr>
<tr>
<td align="left">80000000 - 9fffffff</td>
<td align="left">Reserved</td>
</tr>
<tr>
<td align="left">a0000000 - bfffffff</td>
<td align="left">Reserved</td>
</tr>
<tr>
<td align="left">c0000000 - dfffffff</td>
<td align="left">Reserved</td>
</tr>
<tr>
<td align="left">e0000000 - ffffffff</td>
<td align="left">Reserved</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li><p>Oracle 负责管理第一组编号，这些编号对于所有客户来说都应该是相同的。如果客户开发的应用程序可能引起普遍的兴趣，那么应该为该应用程序分配第一个范围内的编号。</p>
</li>
<li><p>第二组数字是为特定客户应用程序保留的。此范围主要用于调试新程序。</p>
</li>
<li><p>第三组保留给动态生成程序编号的应用程序。</p>
</li>
<li><p>最后的组保留供将来使用，不应使用。</p>
</li>
<li><p>RPC Program Number由互联网编号分配机构 (IANA) 分配。获取程序编号分配的政策和程序在<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM1NTMx">RFC 5531<i class="fa fa-external-link-alt"></i></span>的第 13 节中进行了描述。已分配的 RPC 程序编号列表可在 <span class="exturl" data-url="aHR0cDovL3d3dy5pYW5hLm9yZy8=">IANA 网站<i class="fa fa-external-link-alt"></i></span> 上找到。</p>
</li>
</ol>
<p><strong>Version number</strong>  : 程序的首次实现很可能具有版本号 1。大多数新协议都会发展成为更好、更稳定、更成熟的协议。因此，call message的版本字段会标识调用者正在使用的协议的版本。版本号使得同一服务器进程使用新旧协议成为可能。</p>
<p><strong>Procedure numbe</strong> : 标识要调用的过程。这些编号记录在各个程序的协议规范中。</p>
<h3 id="2-2-2-RPC-version-number"><a href="#2-2-2-RPC-version-number" class="headerlink" title="2.2.2 RPC version number"></a>2.2.2 RPC version number</h3><p>正如Procedure有多个版本一样，RPC 协议本身也有多个版本。因此，call message中也包含 RPC 版本号，对于此处描述的 RPC 版本，<strong>该版本号始终等于 2</strong>。</p>
<p>对请求消息的回复消息具有足够的信息来区分以下错误情况：</p>
<ul>
<li>RPC 的远程实现不使用协议版本 2。返回支持的最低和最高 RPC 版本号。</li>
<li>remote program在远程系统上不可用。</li>
<li>remote program不支持请求的version number。返回支持的最低和最高remote program version number。</li>
<li>请求的procedure number不存在。此结果通常是调用方协议或编程错误。</li>
<li>服务器将remote procedure的参数解释为垃圾。同样，这种结果通常是由于客户端和服务之间的协议不一致造成的。</li>
</ul>
<h3 id="2-2-3-Authentication"><a href="#2-2-3-Authentication" class="headerlink" title="2.2.3 Authentication"></a>2.2.3 Authentication</h3><p>作为 RPC 协议的一部分，提供对服务的调用者进行身份验证以及反向验证。call message 有两个身份验证字段，即credentials和verifier。reply message有一个身份验证字段，即verifier。RPC 协议规范将这三个字段定义为以下不透明类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">auth_flavor</span> &#123;</span></span><br><span class="line">  	AUTH_NONE = <span class="number">0</span>,</span><br><span class="line">  	AUTH_SYS = <span class="number">1</span>,</span><br><span class="line">  	AUTH_SHORT = <span class="number">2</span>,</span><br><span class="line">  	AUTH_DES = <span class="number">3</span>,</span><br><span class="line"><span class="comment">/* and more to be defined */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opaque_auth</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span>         <span class="title">auth_flavor</span>;</span>        <span class="comment">/* style of credentials */</span></span><br><span class="line">  u_int        oa_length;        <span class="comment">/* not to exceed MAX_AUTH_BYTES */</span></span><br><span class="line">  <span class="type">caddr_t</span>      oa_base;          <span class="comment">/* address of more auth stuff */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>opaque_auth结构是一个auth_flavor枚举，后面是RPC协议实现不透明的字节。</p>
</li>
<li><p>认证字段中包含的数据的解释和语义由独立的认证协议规范指定。有关各种身份验证协议的定义，后文有介绍。</p>
</li>
<li><p>如果认证参数被拒绝，则响应消息中应说明被拒绝的原因。</p>
</li>
</ul>
<h2 id="2-3-RPC消息格式"><a href="#2-3-RPC消息格式" class="headerlink" title="2.3 RPC消息格式"></a>2.3 RPC消息格式</h2><p>下面以 XDR 数据描述语言定义 RPC消息格式。该消息以<strong>自上而下</strong>的方式定义，如以下代码示例所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">msg_type</span> &#123;</span></span><br><span class="line"> 	CALL = <span class="number">0</span>,</span><br><span class="line"> 	REPLY = <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对call message的回复可以采用两种形式：该消息被accepted or rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reply_stat</span> &#123;</span></span><br><span class="line"> 	MSG_ACCEPTED = <span class="number">0</span>,</span><br><span class="line"> 	MSG_DENIED = <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假如call message已被accepted，则以下是</span></span><br><span class="line"><span class="comment"> * 尝试调用remote procedure的状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">accept_stat</span> &#123;</span></span><br><span class="line"> 	SUCCESS = <span class="number">0</span>,       <span class="comment">/* RPC executed successfully */</span></span><br><span class="line"> 	PROG_UNAVAIL = <span class="number">1</span>,  <span class="comment">/* remote service hasn&#x27;t exported program */</span></span><br><span class="line"> 	PROG_MISMATCH = <span class="number">2</span>, <span class="comment">/* remote service can&#x27;t support version # */</span></span><br><span class="line"> 	PROC_UNAVAIL = <span class="number">3</span>,  <span class="comment">/* program can&#x27;t support procedure */</span></span><br><span class="line"> 	GARBAGE_ARGS = <span class="number">4</span>   <span class="comment">/* procedure can&#x27;t decode params */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * call message被rejected的原因：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reject_stat</span> &#123;</span></span><br><span class="line"> 	RPC_MISMATCH = <span class="number">0</span>,  <span class="comment">/* RPC version number != 2 */</span></span><br><span class="line"> 	AUTH_ERROR = <span class="number">1</span>     <span class="comment">/* remote can&#x27;t authenticate caller */</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * authentication失败的原因：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">auth_stat</span> &#123;</span></span><br><span class="line"> 	AUTH_BADCRED = <span class="number">1</span>,       <span class="comment">/* bad credentials */</span></span><br><span class="line"> 	AUTH_REJECTEDCRED = <span class="number">2</span>,  <span class="comment">/* clnt must do new session */</span></span><br><span class="line"> 	AUTH_BADVERF = <span class="number">3</span>,       <span class="comment">/* bad verifier */</span></span><br><span class="line"> 	AUTH_REJECTEDVERF = <span class="number">4</span>,  <span class="comment">/* verify expired or replayed */</span></span><br><span class="line"> 	AUTH_TOOWEAK = <span class="number">5</span>        <span class="comment">/* rejected for security */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RPC消息：</span></span><br><span class="line"><span class="comment"> * 1. 所有消息都以事务标识符 xid 开头，后面跟着一个联合体，联合体的判断标准是msg_type，</span></span><br><span class="line"><span class="comment"> * 根据它的值切换到两种消息类型之一。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. reply message的 xid 总是与call message的xid匹配。注意：xid 字段仅用于客户端将</span></span><br><span class="line"><span class="comment"> * reply message与call message进行匹配或者用于服务器检测重传；服务端不能将此ID视为任何类型的序列号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rpc_msg</span> &#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> xid;</span><br><span class="line"> 	<span class="keyword">union</span> <span class="title function_">switch</span> <span class="params">(msg_type mtype)</span> &#123;</span><br><span class="line"> 		<span class="keyword">case</span> CALL:</span><br><span class="line"> 			call_body cbody;</span><br><span class="line"> 		<span class="keyword">case</span> REPLY:</span><br><span class="line"> 			reply_body rbody;</span><br><span class="line"> 	&#125; body;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Body of an RPC request call：</span></span><br><span class="line"><span class="comment"> * 1. 在RPC协议V2版中，rpcvers必须等于 2。字段 prog、vers 和 proc 指定远程程序，其版本号和程序内部的过程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 紧接着是两个认证参数：cred（认证凭证 和 verf（身份验证验证器）。两个身份验证参数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 最后面参数由具体的程序协议指定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call_body</span> &#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> rpcvers; <span class="comment">/* must be equal to two (2) */</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> prog;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> vers;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> proc;</span><br><span class="line"> 	opaque_auth cred;</span><br><span class="line"> 	opaque_auth verf;</span><br><span class="line"> 	<span class="comment">/* procedure specific parameters start here */</span></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Body of a reply to an RPC request:</span></span><br><span class="line"><span class="comment"> * call messag已被accepted or rejected。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> reply_body <span class="title function_">switch</span> <span class="params">(reply_stat stat)</span> &#123;</span><br><span class="line"> 	<span class="keyword">case</span> MSG_ACCEPTED:</span><br><span class="line"> 		accepted_reply areply;</span><br><span class="line"> 	<span class="keyword">case</span> MSG_DENIED:</span><br><span class="line"> 		rejected_reply rreply;</span><br><span class="line">&#125; reply;</span><br><span class="line"></span><br><span class="line">所有消息都以事务标识符 xid 开头，后面跟着一个联合体，联合体的判断标准是msg_type，</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回复被服务器accepted的RPC请求,说明：即使请求被接受，也可能是错误。</span></span><br><span class="line"><span class="comment"> * 1. 第一个字段是服务器生成的身份验证验证器，用于向调用者验证自身</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 后面跟着一个联合体，其判断标准是accept_stat。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accepted_reply</span> &#123;</span></span><br><span class="line"> 	opaque_auth verf;</span><br><span class="line"> 	<span class="keyword">union</span> <span class="title function_">switch</span> <span class="params">(accept_stat stat)</span> &#123;</span><br><span class="line"> 		<span class="keyword">case</span> SUCCESS:</span><br><span class="line"> 			opaque results[<span class="number">0</span>];</span><br><span class="line"> 			<span class="comment">/* procedure-specific results start here */</span></span><br><span class="line"> 		<span class="keyword">case</span> PROG_MISMATCH:</span><br><span class="line"> 			<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 				<span class="type">unsigned</span> <span class="type">int</span> low;</span><br><span class="line"> 				<span class="type">unsigned</span> <span class="type">int</span> high;</span><br><span class="line"> 			&#125; mismatch_info;</span><br><span class="line"> 		<span class="keyword">default</span>:</span><br><span class="line"> 			<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 			 * Void. Cases include PROG_UNAVAIL, PROC_UNAVAIL, and</span></span><br><span class="line"><span class="comment">			    * GARBAGE_ARGS.</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line"> 			<span class="type">void</span>;</span><br><span class="line"> 	&#125; reply_data;</span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回复被服务器rejected的RPC请求：</span></span><br><span class="line"><span class="comment"> * 请求可能因两个原因被拒绝：</span></span><br><span class="line"><span class="comment"> * 1.服务器没有运行兼容版本的RPC协议(RPC_MISMATCH)，返回服务器支持的最低和最高RPC版本号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.服务器身份验证被拒绝(AUTH_ERROR),返回拒绝状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> rejected_reply <span class="title function_">switch</span> <span class="params">(reject_stat stat)</span> &#123;</span><br><span class="line"> 	<span class="keyword">case</span> RPC_MISMATCH:</span><br><span class="line"> 		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 			<span class="type">unsigned</span> <span class="type">int</span> low;</span><br><span class="line"> 			<span class="type">unsigned</span> <span class="type">int</span> high;</span><br><span class="line"> 		&#125; mismatch_info;</span><br><span class="line"> 	<span class="keyword">case</span> AUTH_ERROR:</span><br><span class="line"> 		auth_stat stat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-粘包问题"><a href="#2-4-粘包问题" class="headerlink" title="2.4 粘包问题"></a>2.4 粘包问题</h2><p>当 RPC 消息基于字节流传输（如 TCP）传递时，要将一个RPC消息与另一个RPC消息分隔开。RPC使用record marking (RM)解决这个问题。一个record即一个RPC消息，由一个或多个record fragments组成。record fragments有一个4字节大小的fragment header，后面跟着<code>0</code>到&#96;(2*31) - 1 字节的fragment数据。这些字节编码一个无符号二进制数，类似于XDR整数，<strong>字节顺序是网络字节顺序</strong>。</p>
<p>fragment header：</p>
<ul>
<li>布尔值，指定该fragment是否为record的最后一个fragment。位值 1 表示该fragment是最后一个fragment。</li>
<li>31 位无符号二进制值，表示fragment数据的长度（以字节为单位）。布尔值是header的最高位bit。长度是 31 个低位bit。此record规范不是 XDR 标准格式。</li>
</ul>
<h2 id="2-5-Authentication-Protocols"><a href="#2-5-Authentication-Protocols" class="headerlink" title="2.5 Authentication Protocols"></a>2.5 Authentication Protocols</h2><h3 id="2-5-1-AUTH-NONE-Authentication"><a href="#2-5-1-AUTH-NONE-Authentication" class="headerlink" title="2.5.1 AUTH_NONE Authentication"></a>2.5.1 AUTH_NONE Authentication</h3><p>调用者不进行身份验证，服务器也不理会调用者是谁。在这种情况下，RPC消息的credentials、verifier和response verifier的flavor值是AUTH_NONE。即opaque_auth中auth_flavor值。在使用AUTH_NONE身份验证类型时，opaque_auth中oa_length为0。</p>
<h3 id="2-5-2-AUTH-SYS-Authentication"><a href="#2-5-2-AUTH-SYS-Authentication" class="headerlink" title="2.5.2 AUTH_SYS Authentication"></a>2.5.2 AUTH_SYS Authentication</h3><p>AUTH_SYS与以前称为 AUTH_UNIX 的身份验证风格相同。远程过程的调用者可能希望使用传统的UNIX进程权限身份验证来标识自己。这种RPC call message的opaque_auth中auth_flavor值是AUTH_SYS。oa_base的字节编码为以下结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UNIX style credentials.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">auth_sysparms</span> &#123;</span></span><br><span class="line">  	<span class="type">unsigned</span> <span class="type">int</span> stamp;  <span class="comment">// credentials creation time</span></span><br><span class="line">  	<span class="built_in">string</span> machine_name&lt;<span class="number">255</span>&gt;; <span class="comment">// caller system的名字，最多不超过255字节</span></span><br><span class="line">  	<span class="type">uid_t</span> uid; <span class="comment">// caller的有效用户ID</span></span><br><span class="line">  	<span class="type">gid_t</span> gid; <span class="comment">// caller的有效组ID</span></span><br><span class="line">  	<span class="type">gids_t</span> gids; <span class="comment">// caller所属于所有组</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> machine_name&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> name_len; <span class="comment">// 主机名长度</span></span><br><span class="line">    <span class="type">char</span>* name; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">char</span>* padding; <span class="comment">// machine_name大小基于4字节对齐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gids_t</span>&#123;</span></span><br><span class="line">  	<span class="type">unsigned</span> <span class="type">int</span> gid_num; <span class="comment">// 所属组个数，最多不能超过16个</span></span><br><span class="line">  	<span class="type">gid_t</span> gid&lt;<span class="number">16</span>&gt;; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-AUTH-SHORT-Verifier"><a href="#2-5-3-AUTH-SHORT-Verifier" class="headerlink" title="2.5.3 AUTH_SHORT Verifier"></a>2.5.3 AUTH_SHORT Verifier</h3><p>当使用 AUTH_SYS 身份验证时， 来自服务器的reply message中response verifier类型可能是AUTH_NONE 或 AUTH_SHORT。如果是 AUTH_SHORT，response verifier字符串字节编码为short_hand_verf结构。这个不透明的结构现在可以传递给服务器，而不是原始的AUTH_SYS credentials。</p>
<p>说明：</p>
<ul>
<li>服务器会保留一个缓存，将简短不透明结构映射到调用者的original credentials。这些结构通过 AUTH_SHORT类型的response verifier返回。调用者可以使用new credentials节省网络带宽和服务器 CPU 周期。</li>
<li>服务器可以随时刷新简短不透明结构。如果发生刷新，则远程过程call message 会因身份验证错误而被拒绝。失败的原因是 <code>AUTH_REJECTEDCRED</code>。此时，调用者可能会尝试原始的 AUTH_SYS 类型的credentials。</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/direct/03a13933da1541d9bcf3fb889439c859.jpeg#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-5-4-AUTH-DES-Authentication"><a href="#2-5-4-AUTH-DES-Authentication" class="headerlink" title="2.5.4 AUTH_DES Authentication"></a>2.5.4 AUTH_DES Authentication</h3><p>使用 AUTH_SYS 身份验证的情况：1. 如果同一网络上有不同操作系统的系统，则无法保证呼叫者识别的唯一性。2. 由于不存在verifier，因此credentials很容易被伪造。AUTH_DES身份验证就是为了解决这两个问题，AUTH_DES比较复杂，有兴趣可以自行了解。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="RPC请求消息与响应消息数据包"><a href="#RPC请求消息与响应消息数据包" class="headerlink" title="RPC请求消息与响应消息数据包"></a>RPC请求消息与响应消息数据包</h2><p>下面捕捉的是客户端向远程服务器的<code>rpcbind</code>查询mount程序的端口所产生的RPC数据包</p>
<p>RPC 请求消息</p>
<p><img src="https://i-blog.csdnimg.cn/direct/bf24151d50a5462896cc33647d091e1c.png#pic_center" alt="在这里插入图片描述"></p>
<p>RPC 响应消息</p>
<p><img src="https://i-blog.csdnimg.cn/direct/1862267183f14d59845f7bce60c74d28.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="一个简单portmapper程序源码"><a href="#一个简单portmapper程序源码" class="headerlink" title="一个简单portmapper程序源码"></a>一个简单portmapper程序源码</h2><p>可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM1NTMx">libnfs<i class="fa fa-external-link-alt"></i></span>项目下<code>examples/portmap-server.c</code>文件</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考Oracle的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTM3ODM4XzAxL2h0bWwvRTYxMDU4L2luZGV4Lmh0bWw=">RPC文档<i class="fa fa-external-link-alt"></i></span>并对内容进行删改，版权所有为Oracle。</p>
]]></content>
      <categories>
        <category>通信框架</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 单链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、单链表定义"><a href="#一、单链表定义" class="headerlink" title="一、单链表定义"></a>一、单链表定义</h1><p>&emsp;单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。<br>&emsp;<strong>根据第一个节点是否存放数据：分为带头节点(带哨兵位)的单链表与不带头节点（不带哨兵位）的单链表两种</strong></p>
<span id="more"></span>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cebfb037ee4bbb6d7bdb106bd457b0df.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="二、不带头节点的单链表"><a href="#二、不带头节点的单链表" class="headerlink" title="二、不带头节点的单链表"></a>二、不带头节点的单链表</h1><h2 id="2-1-单链表结构及接口定义"><a href="#2-1-单链表结构及接口定义" class="headerlink" title="2.1 单链表结构及接口定义"></a>2.1 单链表结构及接口定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">()</span>; <span class="comment">// 创建一个单链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode **ppHead, ElemType elem)</span>; <span class="comment">// 头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">// 头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos, ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span>; <span class="comment">//打印单链表 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span>; <span class="comment">//查找指定值在单链表第一次出现位置，位置从1开始，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">// 销毁单链表</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-创建节点"><a href="#2-2-创建节点" class="headerlink" title="2.2 创建节点"></a>2.2 创建节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">(ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)  <span class="comment">// 开辟空间失败，终止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	newNode-&gt;data = elem;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-头插元素"><a href="#2-3-头插元素" class="headerlink" title="2.3 头插元素"></a>2.3 头插元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5fc6c646650610cfc76a277e1a26bc53.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	newNode-&gt;next = *ppHead;</span><br><span class="line">	*ppHead = newNode; <span class="comment">// 头指针指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-头删元素"><a href="#2-4-头删元素" class="headerlink" title="2.4 头删元素"></a>2.4 头删元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/36ad43f3318edad1c4a7bfc75e792119.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，头删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* next = (*ppHead)-&gt;next; <span class="comment">// 先保存第二个节点地址，防止第一个节点释放后找不到后续节点</span></span><br><span class="line">		<span class="built_in">free</span>(*ppHead); <span class="comment">// 释放第一个节点空间</span></span><br><span class="line">		*ppHead = next; <span class="comment">// 头指针指向原来第二个节点，当作第一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-尾插元素"><a href="#2-5-尾插元素" class="headerlink" title="2.5 尾插元素"></a>2.5 尾插元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5d13460bf532cc4903561164b2f61d27.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		*ppHead = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* tail = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tail-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-尾删元素"><a href="#2-6-尾删元素" class="headerlink" title="2.6 尾删元素"></a>2.6 尾删元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/701951b3e1b986288b20447142d6dc29.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，尾删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">//单链表至少有一个节点以上</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*ppHead)-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 单链表只有1个节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(*ppHead);</span><br><span class="line">			*ppHead = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 单链表有2个及以上节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">			ListNode* tail = *ppHead;</span><br><span class="line">			<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				prev = tail;</span><br><span class="line">				tail = tail-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(tail); </span><br><span class="line">			prev-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将原单链表倒数第二个节点的next置为NULL，作为新链表的尾节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-指定位置插入元素"><a href="#2-7-指定位置插入元素" class="headerlink" title="2.7 指定位置插入元素"></a>2.7 指定位置插入元素</h2><p><strong>位序（位置）从1开始，即第一个节点位序为1</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/dbed78da5b4f344db15477c6e1d8af83.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">1</span>) <span class="comment">// 头部插入</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* newNode = CreateNode(elem);</span><br><span class="line">		newNode-&gt;next = *ppHead;</span><br><span class="line">		*ppHead = newNode; <span class="comment">// 头指针指向新节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == pos)</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* newNode = CreateNode(elem);</span><br><span class="line">			newNode-&gt;next = cur;</span><br><span class="line">			prev-&gt;next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-指定位置删除元素"><a href="#2-7-指定位置删除元素" class="headerlink" title="2.7 指定位置删除元素"></a>2.7 指定位置删除元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d79366d6994dd84cb57eef9744c3f3a8.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* next = (*ppHead)-&gt;next; <span class="comment">// 先保存第二个节点地址，防止第一个节点释放后找不到后续节点</span></span><br><span class="line">		<span class="built_in">free</span>(*ppHead); <span class="comment">// 释放头节点</span></span><br><span class="line">		*ppHead = next; <span class="comment">// 头指针指向原来第二个节点，当作第一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev-&gt;next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-8-打印单链表"><a href="#2-8-打印单链表" class="headerlink" title="2.8 打印单链表"></a>2.8 打印单链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-9-查找指定元素位置"><a href="#2-9-查找指定元素位置" class="headerlink" title="2.9 查找指定元素位置"></a>2.9 查找指定元素位置</h2><p><strong>查找指定值在单链表第一次出现位置，位置从1开始，未找到返回-1</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;data == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-10-销毁单链表"><a href="#2-10-销毁单链表" class="headerlink" title="2.10 销毁单链表"></a>2.10 销毁单链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = *ppHead;</span><br><span class="line">	ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(cur);</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppHead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-11-源代码"><a href="#2-11-源代码" class="headerlink" title="2.11 源代码"></a>2.11 源代码</h2><p><strong>头文件<code>SinList.h</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">()</span>; <span class="comment">// 创建一个单链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode **ppHead, ElemType elem)</span>; <span class="comment">// 头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">// 头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos, ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span>; <span class="comment">//打印单链表 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span>; <span class="comment">//查找指定值在单链表第一次出现位置，位置从1开始，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(ListNode** ppHead)</span>; <span class="comment">// 销毁单链表</span></span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>SinList.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SinList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">(ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)  <span class="comment">// 开辟空间失败，终止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	newNode-&gt;data = elem;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	newNode-&gt;next = *ppHead;</span><br><span class="line">	*ppHead = newNode; <span class="comment">// 头指针指向新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，头删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* next = (*ppHead)-&gt;next; <span class="comment">// 先保存第二个节点地址，防止第一个节点释放后找不到后续节点</span></span><br><span class="line">		<span class="built_in">free</span>(*ppHead); <span class="comment">// 释放第一个节点空间</span></span><br><span class="line">		*ppHead = next; <span class="comment">// 头指针指向原来第二个节点，当作第一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode** ppHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		*ppHead = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* tail = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		tail-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>) <span class="comment">// 单链表为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，尾删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">//单链表至少有一个节点以上</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*ppHead)-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 单链表只有1个节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(*ppHead);</span><br><span class="line">			*ppHead = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 单链表有2个及以上节点</span></span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">			ListNode* tail = *ppHead;</span><br><span class="line">			<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				prev = tail;</span><br><span class="line">				tail = tail-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(tail); </span><br><span class="line">			prev-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将原单链表倒数第二个节点的next置为NULL，作为新链表的尾节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">1</span>) <span class="comment">// 头部插入</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* newNode = CreateNode(elem);</span><br><span class="line">		newNode-&gt;next = *ppHead;</span><br><span class="line">		*ppHead = newNode; <span class="comment">// 头指针指向新节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == pos)</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* newNode = CreateNode(elem);</span><br><span class="line">			newNode-&gt;next = cur;</span><br><span class="line">			prev-&gt;next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode** ppHead, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*ppHead == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* next = (*ppHead)-&gt;next; <span class="comment">// 先保存第二个节点地址，防止第一个节点释放后找不到后续节点</span></span><br><span class="line">		<span class="built_in">free</span>(*ppHead); <span class="comment">// 释放头节点</span></span><br><span class="line">		*ppHead = next; <span class="comment">// 头指针指向原来第二个节点，当作第一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = *ppHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev-&gt;next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;data == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(ListNode** ppHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = *ppHead;</span><br><span class="line">	ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(cur);</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	*ppHead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>main.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SinList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- H. 头插元素  h. 头删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- T. 尾插元素  t. 尾删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- I. 插入元素  D. 删除元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- F. 查找元素  P. 打印元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------    Q. 退出  --------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* pHead = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> choose = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">		choose = getchar(); <span class="comment">//接接收用户选择</span></span><br><span class="line">		ElemType elem; <span class="comment">//待插入（或查找）元素值</span></span><br><span class="line">		<span class="type">int</span> position = <span class="number">-1</span>; <span class="comment">//待插入（删除、查找）元素位序，位序从1开始</span></span><br><span class="line">		getchar(); <span class="comment">//从输入缓冲区读取回车符，避免影响下次输入</span></span><br><span class="line">		<span class="keyword">switch</span> (choose)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			SinListHeadInsert(&amp;pHead, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">			SinListHeadDelete(&amp;pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			SinListTailInsert(&amp;pHead,elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">			SinListTailDelete(&amp;pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素位序及值,例：2 5  &gt;&quot;</span>); <span class="comment">//位序：单链表的第几个元素，从1开始</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;position, &amp;elem);</span><br><span class="line">			SinListInsert(&amp;pHead, position, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待删除元素位序：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;position);</span><br><span class="line">			SinListDelete(&amp;pHead, position);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待查找元素的值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			position = SinListFind(pHead, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">if</span> (position == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;元素：%d 不在单链表中\n&quot;</span>, elem);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;元素：%d 的位序为：%d\n&quot;</span>, elem, position);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			SinListPrint(pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">			Destory(&amp;pHead);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;选择错误，请重新选择!!!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (choose != <span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、带头节点的单链表"><a href="#三、带头节点的单链表" class="headerlink" title="三、带头节点的单链表"></a>三、带头节点的单链表</h1><h2 id="3-1-单链表结构及接口定义"><a href="#3-1-单链表结构及接口定义" class="headerlink" title="3.1 单链表结构及接口定义"></a>3.1 单链表结构及接口定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">()</span>; <span class="comment">// 创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode *pHead, ElemType elem)</span>; <span class="comment">// 头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode *pHead)</span>; <span class="comment">// 头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode *pHead, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode *pHead)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode *pHead, <span class="type">int</span> pos, ElemType elem)</span>; <span class="comment">// 插入元素到pos位置,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode *pHead, <span class="type">int</span> pos)</span>; <span class="comment">// 删除pos位置元素,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode *pHead)</span>; <span class="comment">// 打印单链表 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode *pHead, ElemType value)</span>; <span class="comment">// 查找指定值在单链表第一次出现位置，位置从1开始，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">Destory</span><span class="params">(ListNode* pHead)</span>; <span class="comment">// 销毁单链表</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-创建节点"><a href="#3-2-创建节点" class="headerlink" title="3.2 创建节点"></a>3.2 创建节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">(ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)  <span class="comment">// 开辟空间失败，终止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	newNode-&gt;data = elem;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-头插元素"><a href="#3-3-头插元素" class="headerlink" title="3.3 头插元素"></a>3.3 头插元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode* pHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	newNode-&gt;next = pHead-&gt;next;</span><br><span class="line">	pHead-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-头删元素"><a href="#3-3-头删元素" class="headerlink" title="3.3 头删元素"></a>3.3 头删元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，头删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* Node = pHead-&gt;next;</span><br><span class="line">		pHead-&gt;next = pHead-&gt;next-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-尾插元素"><a href="#3-4-尾插元素" class="headerlink" title="3.4 尾插元素"></a>3.4 尾插元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode* pHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* tail = pHead;</span><br><span class="line">	<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	tail-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-尾删元素"><a href="#3-5-尾删元素" class="headerlink" title="3.5 尾删元素"></a>3.5 尾删元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，尾删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* tail = pHead;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = tail;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(tail);</span><br><span class="line">		prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-指定位置插入元素"><a href="#3-6-指定位置插入元素" class="headerlink" title="3.6 指定位置插入元素"></a>3.6 指定位置插入元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode* pHead, <span class="type">int</span> pos, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == pos)</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* newNode = CreateNode(elem);</span><br><span class="line">			newNode-&gt;next = cur;</span><br><span class="line">			prev-&gt;next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-指定位置删除元素"><a href="#3-7-指定位置删除元素" class="headerlink" title="3.7 指定位置删除元素"></a>3.7 指定位置删除元素</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode* pHead, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev-&gt;next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-打印单链表"><a href="#3-8-打印单链表" class="headerlink" title="3.8 打印单链表"></a>3.8 打印单链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* cur = pHead-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-查找指定元素位置"><a href="#3-9-查找指定元素位置" class="headerlink" title="3.9 查找指定元素位置"></a>3.9 查找指定元素位置</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead-&gt;next;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;data == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-销毁单链表"><a href="#3-10-销毁单链表" class="headerlink" title="3.10 销毁单链表"></a>3.10 销毁单链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">Destory</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead;</span><br><span class="line">	ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(cur);</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-源代码"><a href="#3-11-源代码" class="headerlink" title="3.11 源代码"></a>3.11 源代码</h2><p><strong>头文件<code>SinList.h</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">()</span>; <span class="comment">// 创建一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode *pHead, ElemType elem)</span>; <span class="comment">// 头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode *pHead)</span>; <span class="comment">// 头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode *pHead, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode *pHead)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode *pHead, <span class="type">int</span> pos, ElemType elem)</span>; <span class="comment">// 插入元素到pos位置,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode *pHead, <span class="type">int</span> pos)</span>; <span class="comment">// 删除pos位置元素,位置从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode *pHead)</span>; <span class="comment">// 打印单链表 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode *pHead, ElemType value)</span>; <span class="comment">// 查找指定值在单链表第一次出现位置，位置从1开始，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">Destory</span><span class="params">(ListNode* pHead)</span>; <span class="comment">// 销毁单链表</span></span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>SinList.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SinList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">CreateNode</span><span class="params">(ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	<span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)  <span class="comment">// 开辟空间失败，终止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	newNode-&gt;data = elem;</span><br><span class="line">	newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadInsert</span><span class="params">(ListNode* pHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	newNode-&gt;next = pHead-&gt;next;</span><br><span class="line">	pHead-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListHeadDelete</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，头删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* Node = pHead-&gt;next;</span><br><span class="line">		pHead-&gt;next = pHead-&gt;next-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailInsert</span><span class="params">(ListNode* pHead, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* tail = pHead;</span><br><span class="line">	<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* newNode = CreateNode(elem);</span><br><span class="line">	tail-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListTailDelete</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，尾删失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* tail = pHead;</span><br><span class="line">		<span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = tail;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(tail);</span><br><span class="line">		prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListInsert</span><span class="params">(ListNode* pHead, <span class="type">int</span> pos, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == pos)</span><br><span class="line">		&#123;</span><br><span class="line">			ListNode* newNode = CreateNode(elem);</span><br><span class="line">			newNode-&gt;next = cur;</span><br><span class="line">			prev-&gt;next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListDelete</span><span class="params">(ListNode* pHead, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">		ListNode* cur = pHead;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;位置不合法，删除失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev-&gt;next = cur-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SinListPrint</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;单链表为空\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* cur = pHead-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SinListFind</span><span class="params">(ListNode* pHead, ElemType value)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead-&gt;next;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;data == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* <span class="title function_">Destory</span><span class="params">(ListNode* pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* cur = pHead;</span><br><span class="line">	ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(cur);</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>main.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SinList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- H. 头插元素  h. 头删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- T. 尾插元素  t. 尾删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- I. 插入元素  D. 删除元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- F. 查找元素  P. 打印元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------    Q. 退出  --------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	ListNode* pHead = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">	pHead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> choose = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">		choose = getchar(); <span class="comment">//接接收用户选择</span></span><br><span class="line">		ElemType elem; <span class="comment">//待插入（或查找）元素值</span></span><br><span class="line">		<span class="type">int</span> position = <span class="number">-1</span>; <span class="comment">//待插入（删除、查找）元素位序，位序从1开始</span></span><br><span class="line">		getchar(); <span class="comment">//从输入缓冲区读取回车符，避免影响下次输入</span></span><br><span class="line">		<span class="keyword">switch</span> (choose)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			SinListHeadInsert(pHead, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">			SinListHeadDelete(pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			SinListTailInsert(pHead,elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">			SinListTailDelete(pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素位序及值,例：2 5  &gt;&quot;</span>); <span class="comment">//位序：单链表的第几个元素，从1开始</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;position, &amp;elem);</span><br><span class="line">			SinListInsert(pHead, position, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待删除元素位序：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;position);</span><br><span class="line">			SinListDelete(pHead, position);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入待查找元素的值：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">			position = SinListFind(pHead, elem);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">if</span> (position == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;元素：%d 不在单链表中\n&quot;</span>, elem);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;元素：%d 的位序为：%d\n&quot;</span>, elem, position);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			SinListPrint(pHead);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">			pHead = Destory(pHead);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;选择错误，请重新选择!!!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (choose != <span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 顺序表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%A1%BA%E5%BA%8F%E8%A1%A8.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h1><p>线性结构是指结构中的数据元素之间存在着一对一的关系。线性结构的基本特征如下:</p>
<p>&emsp;●有且只有一个“第一元素”;有且只有一个“最后元素”;<br>&emsp;●除第一元素之外,其他元素都有唯一的直接前趋;.<br>&emsp;●除最后元素之外,其他元素都有唯一的直接后继。</p>
<p><strong>线性表是一种常用的、简单的数据结构,属于线性结构的范畴</strong></p>
<span id="more"></span>

<h2 id="1-1-线性表定义"><a href="#1-1-线性表定义" class="headerlink" title="1.1 线性表定义"></a>1.1 线性表定义</h2><p>  <strong>线性表</strong>(linear list)是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限a序列,通常记为 </p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>(a₁,a₂,…,aₙ₋₁,aₙ)</strong><br>&emsp;其中,数据元素的个数n称为线性表的长度。当n&#x3D;0时称为空表。从线性表的定义可以看出它的逻辑特征是:在非空的线性表中,有且只有一个起始结点(第一元素)a₁,它没有直接前趋,只有一个直接后继a₂;有且只有一个终端结点(最后元素)aₙ它没有直接后继,只有一个直接前趋aₙ₋₁;而除了a₁和aₙ外,其他的每一个结点aᵢ(2&lt;i&lt;n-1)都有且只有一个直接前趋aᵢ₋₁和一个直接后继aᵢ₊₁</p>
<h2 id="1-2-顺序表定义"><a href="#1-2-顺序表定义" class="headerlink" title="1.2 顺序表定义"></a>1.2 顺序表定义</h2><p>&emsp;线性表的<strong>顺序存储</strong>是指用一组地址连续的内存单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表<br>&emsp;在C语言中顺序表通过数组方式实现，数组的创建有两种方式。<strong>使用定长数组的方式称为静态分配顺序表，使用动态内存分配的方式称为动态分配顺序表</strong>。不了解动态内存分配可参考这篇博客<code>https://blog.csdn.net/kjl167/article/details/123799963</code></p>
<h1 id="二、静态分配顺序表"><a href="#二、静态分配顺序表" class="headerlink" title="二、静态分配顺序表"></a>二、静态分配顺序表</h1><h2 id="2-1-顺序表结构及接口定义"><a href="#2-1-顺序表结构及接口定义" class="headerlink" title="2.1 顺序表结构及接口定义"></a>2.1 顺序表结构及接口定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20 <span class="comment">//数组大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度（已存放元素个数）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//查找指定值并返回下标，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span>; <span class="comment">//打印顺序表 </span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-顺序表初始化"><a href="#2-2-顺序表初始化" class="headerlink" title="2.2 顺序表初始化"></a>2.2 顺序表初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	p-&gt;length = <span class="number">0</span>; <span class="comment">//顺序表长度置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-头插元素"><a href="#2-3-头插元素" class="headerlink" title="2.3 头插元素"></a>2.3 头插元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/96bef819de29bf053f8a56ecdc0a4af1.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = p-&gt;length - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">		<span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) <span class="comment">//最后一个元素开始遍历所有元素分别将它们向后移动一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data[<span class="number">0</span>] = elem; <span class="comment">//将元素插入到顺序表头部</span></span><br><span class="line">		p-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-头删元素"><a href="#2-4-头删元素" class="headerlink" title="2.4 头删元素"></a>2.4 头删元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9ef225f5acd89eda689a3dc7fd2b552.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//第2个元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;length; i++) <span class="comment">//从第2个元素位置开始遍历到最后一个元素，分别将它们都向前移动1个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-尾插元素"><a href="#2-5-尾插元素" class="headerlink" title="2.5 尾插元素"></a>2.5 尾插元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ae51f75e9c69c125de5dc74cb1291938.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;data[p-&gt;length] = elem;</span><br><span class="line">		p-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-尾删元素"><a href="#2-6-尾删元素" class="headerlink" title="2.6 尾删元素"></a>2.6 尾删元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bdd9b22abe4f3bdb40832c699cd20718.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;length--; <span class="comment">//只需将元素个数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-指定位置插入元素"><a href="#2-7-指定位置插入元素" class="headerlink" title="2.7 指定位置插入元素"></a>2.7 指定位置插入元素</h2><p><strong>数组下标从0开始，位置从1开始</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/225b4abf547bcc12b5c6df1f6421bb8c.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;length+<span class="number">1</span>) <span class="comment">//当位置为1(表头)--表尾的后一个位置时合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> i = p-&gt;length - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">			<span class="keyword">for</span> (i; i &gt;= pos - <span class="number">1</span>; i--) <span class="comment">//pos-1为pos位置元素下标，从最后一个元素开始遍历到pos位置元素，分别将它们向后移动一个位置</span></span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">			&#125;</span><br><span class="line">			p-&gt;data[pos - <span class="number">1</span>] = elem;</span><br><span class="line">			p-&gt;length++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-8-指定位置删除元素"><a href="#2-8-指定位置删除元素" class="headerlink" title="2.8 指定位置删除元素"></a>2.8 指定位置删除元素</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4f2150534ff6bfbb7388d70ebc472ec1.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = pos; <span class="comment">//指定位置的后1个元素</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-9-查找指定元素下标"><a href="#2-9-查找指定元素下标" class="headerlink" title="2.9 查找指定元素下标"></a>2.9 查找指定元素下标</h2><p><strong>下标从0开始，当有多个元素的值相同时，返回找到的第一个元素下标</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data[i] == elem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-10-打印顺序表"><a href="#2-10-打印顺序表" class="headerlink" title="2.10 打印顺序表"></a>2.10 打印顺序表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-11-程序源代码"><a href="#2-11-程序源代码" class="headerlink" title="2.11 程序源代码"></a>2.11 程序源代码</h2><p><strong>头文件<code>SeqList.h</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20 <span class="comment">//数组大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度（已存放元素个数）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//查找指定值并返回下标，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span>; <span class="comment">//打印顺序表 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>SeqList.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	p-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = p-&gt;length - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">		<span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) <span class="comment">//最后一个元素开始遍历所有元素分别将它们向后移动一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data[<span class="number">0</span>] = elem; <span class="comment">//将元素插入到顺序表头部</span></span><br><span class="line">		p-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//第2个元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;length; i++) <span class="comment">//从第2个元素位置开始遍历到最后一个元素，分别将它们都向前移动1个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;data[p-&gt;length] = elem;</span><br><span class="line">		p-&gt;length++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;length--; <span class="comment">//只需将元素个数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;length+<span class="number">1</span>) <span class="comment">//当位置为1(表头)--表尾的后一个位置时合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;length == MAXSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;顺序表已满，插入失败\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> i = p-&gt;length - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">			<span class="keyword">for</span> (i; i &gt;= pos - <span class="number">1</span>; i--) <span class="comment">//pos-1为pos位置元素下标，从最后一个元素开始遍历到pos位置元素，分别将它们向后移动一个位置</span></span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">			&#125;</span><br><span class="line">			p-&gt;data[pos - <span class="number">1</span>] = elem;</span><br><span class="line">			p-&gt;length++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = pos; <span class="comment">//指定位置的后1个元素</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;length--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data[i] == elem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>main.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- H. 头插元素  h. 头删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- T. 尾插元素  t. 尾删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- I. 插入元素  D. 删除元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- F. 查找元素  P. 打印元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------    Q. 退出  --------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SeqList s = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	InitSeq(&amp;s);</span><br><span class="line">	<span class="type">char</span> choose = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">		choose = getchar(); <span class="comment">//接受用户选择</span></span><br><span class="line">		ElemType elem; <span class="comment">//待插入（或查找）元素值</span></span><br><span class="line">		<span class="type">int</span> position = <span class="number">0</span>; <span class="comment">//待插入（删除）元素位序</span></span><br><span class="line">		getchar(); <span class="comment">//从输入缓冲区读取回车符，避免影响下次输入</span></span><br><span class="line">		<span class="keyword">switch</span> (choose)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				SeqListHeadInsert(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">				SeqListHeadDelete(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				SeqListTailInsert(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">				SeqListTailDelete(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素位序及值,例：2 5  &gt;&quot;</span>); <span class="comment">//位序：顺序表的第几个元素，从1开始</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;position,&amp;elem);</span><br><span class="line">				SeqListInsert(&amp;s,position,elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待删除元素位序：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;position);</span><br><span class="line">				SeqListDelete(&amp;s, position);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待查找元素的值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				<span class="type">int</span> index = SeqListFind(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d 不在顺序表中\n&quot;</span>,elem);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d 元素的下标为：%d\n&quot;</span>, elem, index);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">				SeqListPrint(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;选择错误，请重新选择!!!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (choose != <span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、动态分配顺序表"><a href="#三、动态分配顺序表" class="headerlink" title="三、动态分配顺序表"></a>三、动态分配顺序表</h1><h2 id="3-1-顺序表结构及接口定义"><a href="#3-1-顺序表结构及接口定义" class="headerlink" title="3.1 顺序表结构及接口定义"></a>3.1 顺序表结构及接口定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType* data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line">	<span class="type">size_t</span> size; <span class="comment">//已存放元素个数</span></span><br><span class="line">	<span class="type">size_t</span> capacity; <span class="comment">//数组容量</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDestory</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表的销毁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CheckCapacity</span><span class="params">(SeqList* p)</span>; <span class="comment">//检查容量大小决定是否扩容</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//查找指定值并返回下标，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span>; <span class="comment">//打印顺序表 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-2-顺序表初始化"><a href="#3-2-顺序表初始化" class="headerlink" title="3.2 顺序表初始化"></a>3.2 顺序表初始化</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47952f982a141cf9c37939163f219e07.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	p-&gt;data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * initSize); <span class="comment">//先开辟容量为initSize大小的数组</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;data == <span class="literal">NULL</span>) <span class="comment">//动态内存分配失败则中止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;size = <span class="number">0</span>;</span><br><span class="line">	p-&gt;capacity = initSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-顺序表销毁"><a href="#3-3-顺序表销毁" class="headerlink" title="3.3 顺序表销毁"></a>3.3 顺序表销毁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListDestory</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="built_in">free</span>(p-&gt;data);</span><br><span class="line">	p-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;size = <span class="number">0</span>;</span><br><span class="line">	p-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-顺序表扩容"><a href="#3-4-顺序表扩容" class="headerlink" title="3.4 顺序表扩容"></a>3.4 顺序表扩容</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91df8cd6eb56c10728ed58d6b69752a7.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CheckCapacity</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == p-&gt;capacity) <span class="comment">//容量已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">size_t</span> new_capacity = p-&gt;capacity * <span class="number">2</span>; <span class="comment">//扩容到原来2倍</span></span><br><span class="line">		ElemType* tmp = <span class="built_in">realloc</span>(p-&gt;data, new_capacity * <span class="keyword">sizeof</span>(ElemType)); </span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="comment">//扩容失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;realloc fail\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data = tmp;</span><br><span class="line">		p-&gt;capacity = new_capacity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-头插元素"><a href="#3-5-头插元素" class="headerlink" title="3.5 头插元素"></a>3.5 头插元素</h2><p><strong>除了需要检查是否扩容外，其他与静态顺序表头插元素一致，可参考2-3的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	CheckCapacity(p); <span class="comment">//检查容量大小</span></span><br><span class="line">	<span class="type">int</span> i = p-&gt;size - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">	<span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) <span class="comment">//最后一个元素开始遍历所有元素分别将它们向后移动一个位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data[<span class="number">0</span>] = elem; <span class="comment">//将元素插入到顺序表头部</span></span><br><span class="line">	p-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-头删元素"><a href="#3-6-头删元素" class="headerlink" title="3.6 头删元素"></a>3.6 头删元素</h2><p><strong>可参考2-4的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//第2个元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;size; i++) <span class="comment">//从第2个元素位置开始遍历到最后一个元素，分别将它们都向前移动1个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-尾插元素"><a href="#3-7-尾插元素" class="headerlink" title="3.7 尾插元素"></a>3.7 尾插元素</h2><p><strong>除了需要检查是否扩容外，其他与静态顺序表尾插元素一致，可参考2-5的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	CheckCapacity(p); <span class="comment">//检查容量大小</span></span><br><span class="line">	p-&gt;data[p-&gt;size] = elem; </span><br><span class="line">	p-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-尾删元素"><a href="#3-8-尾删元素" class="headerlink" title="3.8 尾删元素"></a>3.8 尾删元素</h2><p><strong>可参考2-6的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;size--; <span class="comment">//只需将元素个数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-指定位置插入元素"><a href="#3-9-指定位置插入元素" class="headerlink" title="3.9 指定位置插入元素"></a>3.9 指定位置插入元素</h2><p><strong>除了需要检查是否扩容外，其他与静态顺序表尾插元素一致，可参考2-7的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;size+<span class="number">1</span>) <span class="comment">//当位置为1(表头)--表尾的后一个位置时合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		CheckCapacity(p);</span><br><span class="line">		<span class="type">int</span> i = p-&gt;size - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">		<span class="keyword">for</span> (i; i &gt;= pos - <span class="number">1</span>; i--) <span class="comment">//pos-1为pos位置元素下标，从最后一个元素开始遍历到pos位置元素，分别将它们向后移动一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data[pos - <span class="number">1</span>] = elem;</span><br><span class="line">		p-&gt;size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-指定位置删除元素"><a href="#3-10-指定位置删除元素" class="headerlink" title="3.10 指定位置删除元素"></a>3.10 指定位置删除元素</h2><p><strong>可参考2-8的图</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = pos; <span class="comment">//指定位置的后1个元素</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-查找指定元素下标"><a href="#3-11-查找指定元素下标" class="headerlink" title="3.11 查找指定元素下标"></a>3.11 查找指定元素下标</h2><p><strong>下标从0开始，当有多个元素的值相同时，返回找到的第一个元素下标</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data[i] == elem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-12-打印顺序表"><a href="#3-12-打印顺序表" class="headerlink" title="3.12 打印顺序表"></a>3.12 打印顺序表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-程序源代码"><a href="#3-13-程序源代码" class="headerlink" title="3.13 程序源代码"></a>3.13 程序源代码</h2><p><strong>头文件<code>SeqList.h</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType* data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line">	<span class="type">size_t</span> size; <span class="comment">//已存放元素个数</span></span><br><span class="line">	<span class="type">size_t</span> capacity; <span class="comment">//数组容量</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDestory</span><span class="params">(SeqList* p)</span>; <span class="comment">//顺序表的销毁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CheckCapacity</span><span class="params">(SeqList* p)</span>; <span class="comment">//检查容量大小决定是否扩容</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//头部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span>; <span class="comment">//尾部删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span>; <span class="comment">//插入元素到pos位置,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span>; <span class="comment">//删除pos位置元素,位序从1开始算，数组下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span>; <span class="comment">//查找指定值并返回下标，未找到返回-1 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span>; <span class="comment">//打印顺序表 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>SeqList.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSeq</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	p-&gt;data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * initSize); <span class="comment">//先开辟容量为initSize大小的数组</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;data == <span class="literal">NULL</span>) <span class="comment">//动态内存分配失败则中止程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;size = <span class="number">0</span>;</span><br><span class="line">	p-&gt;capacity = initSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDestory</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="built_in">free</span>(p-&gt;data);</span><br><span class="line">	p-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;size = <span class="number">0</span>;</span><br><span class="line">	p-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CheckCapacity</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == p-&gt;capacity) <span class="comment">//容量已满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">size_t</span> new_capacity = p-&gt;capacity * <span class="number">2</span>; <span class="comment">//扩容到原来2倍</span></span><br><span class="line">		ElemType* tmp = <span class="built_in">realloc</span>(p-&gt;data, new_capacity * <span class="keyword">sizeof</span>(ElemType)); </span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) <span class="comment">//扩容失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;realloc fail\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data = tmp;</span><br><span class="line">		p-&gt;capacity = new_capacity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	CheckCapacity(p); <span class="comment">//检查容量大小</span></span><br><span class="line">	<span class="type">int</span> i = p-&gt;size - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">	<span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) <span class="comment">//最后一个元素开始遍历所有元素分别将它们向后移动一个位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data[<span class="number">0</span>] = elem; <span class="comment">//将元素插入到顺序表头部</span></span><br><span class="line">	p-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListHeadDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//第2个元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;size; i++) <span class="comment">//从第2个元素位置开始遍历到最后一个元素，分别将它们都向前移动1个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailInsert</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	CheckCapacity(p); <span class="comment">//检查容量大小</span></span><br><span class="line">	p-&gt;data[p-&gt;size] = elem; </span><br><span class="line">	p-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListTailDelete</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;size--; <span class="comment">//只需将元素个数-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SeqList* p, <span class="type">int</span> pos,ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;size+<span class="number">1</span>) <span class="comment">//当位置为1(表头)--表尾的后一个位置时合法</span></span><br><span class="line">	&#123;</span><br><span class="line">		CheckCapacity(p);</span><br><span class="line">		<span class="type">int</span> i = p-&gt;size - <span class="number">1</span>; <span class="comment">//最后一个元素下标 </span></span><br><span class="line">		<span class="keyword">for</span> (i; i &gt;= pos - <span class="number">1</span>; i--) <span class="comment">//pos-1为pos位置元素下标，从最后一个元素开始遍历到pos位置元素，分别将它们向后移动一个位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i + <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;data[pos - <span class="number">1</span>] = elem;</span><br><span class="line">		p-&gt;size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,插入失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListDelete</span><span class="params">(SeqList* p, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空，删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pos &gt;= <span class="number">1</span> &amp;&amp; pos &lt;= p-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = pos; <span class="comment">//指定位置的后1个元素</span></span><br><span class="line">		<span class="keyword">for</span> (i; i &lt; p-&gt;size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;data[i - <span class="number">1</span>] = p-&gt;data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置越界,删除失败\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SeqList* p, ElemType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data[i] == elem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPrint</span><span class="params">(SeqList* p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源文件<code>main.c</code>内容：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- H. 头插元素  h. 头删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- T. 尾插元素  t. 尾删元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- I. 插入元素  D. 删除元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-- F. 查找元素  P. 打印元素 --\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------    Q. 退出  --------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	SeqList s = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	InitSeq(&amp;s);</span><br><span class="line">	<span class="type">char</span> choose = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">		choose = getchar(); <span class="comment">//接受用户选择</span></span><br><span class="line">		ElemType elem; <span class="comment">//待插入（或查找）元素值</span></span><br><span class="line">		<span class="type">int</span> position = <span class="number">0</span>; <span class="comment">//待插入（删除）元素位序</span></span><br><span class="line">		getchar(); <span class="comment">//从输入缓冲区读取回车符，避免影响下次输入</span></span><br><span class="line">		<span class="keyword">switch</span> (choose)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				SeqListHeadInsert(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">				SeqListHeadDelete(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				SeqListTailInsert(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">				SeqListTailDelete(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待插入元素位序及值,例：2 5  &gt;&quot;</span>); <span class="comment">//位序：顺序表的第几个元素，从1开始</span></span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;position,&amp;elem);</span><br><span class="line">				SeqListInsert(&amp;s,position,elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待删除元素位序：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;position);</span><br><span class="line">				SeqListDelete(&amp;s, position);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请输入待查找元素的值：&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;elem);</span><br><span class="line">				<span class="type">int</span> index = SeqListFind(&amp;s, elem);</span><br><span class="line">				getchar();</span><br><span class="line">				<span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d 不在顺序表中\n&quot;</span>,elem);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d 元素的下标为：%d\n&quot;</span>, elem, index);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">				SeqListPrint(&amp;s);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">				SeqListDestory(&amp;s);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;退出成功\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;选择错误，请重新选择!!!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (choose != <span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 在assert中不要使用带有副作用的表达式</title>
    <url>/C-C-%E5%9C%A8assert%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content><![CDATA[<p>   最近在项目中使用<code>assert</code>出现了一个bug，排查了半天才定位到错误，在讲这个陷阱之前先铺垫一下<code>assert</code>基础知识。 <code>assert</code>是 C&#x2F;C++ 中的一个<strong>宏</strong>，定义在<code>assert.h</code>文件中。<code>assert</code> 宏将在 <em>expression</em> 计算结果为 <strong>false</strong>(0) 时打印错误信息并调用<code>abort</code>函数终止进程。 如果 <em><code>expression</code></em> 为 <strong>true</strong> （非0），则不执行任何操作。 错误信息包括失败的expression、源文件名以及失败的行号。<strong>如果定义了<code>NDEBUG</code>宏，<code>assert</code>不会被启用</strong>。<code>assert</code>适用于捕捉不应该发生的非法情况，而不是错误处理，因为错误是可以预料的。</p>
<span id="more"></span>

<p>  现在讲讲我遇到的坑，最近准备将项目中使用的一个nfs客户端库切换到新版本，并想对比下新版本对性能提升多少，所以我准备一个简单测试程序，向nfs服务器写入1G数据， 测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">1</span> , <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfsfh</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="type">int</span> r = nfs_open(<span class="string">&quot;file1&quot;</span>, O_RDWR, &amp;fd);</span><br><span class="line"><span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Failed to create file\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++) <span class="comment">// Write 1G</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(<span class="keyword">sizeof</span>(buf) == nfs_write(fd, buf, <span class="keyword">sizeof</span>(buf)));</span><br><span class="line">&#125;</span><br><span class="line">nfs_close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当运行测试程序，程序正常结束。检查文件大小，也是符合预期。突然想起是测性能，所以我在项目<code>cmake</code>中指定编译为Release版本，之前为Debug版本。然后运行，发现文件虽然在nfs服务器中创建了，但是文件大小为0。这让我一脸懵，因为如果向文件写入数据失败一定会触发断言，程序应该崩溃才对。最开始怀疑是不是新版本库有bug，排查了后发现没问题。想了半天突然想起来，我现在是Release版本，<code>cmake</code> 会在编译时定义<code>NDEBUG</code>宏，<code>assert</code>不会被启用，所以nfs_write函数根本没有执行。<strong>所以千万不要在<code>assert</code>中使用带有副作用的表达式，不然发现程序在Debug中正常运行，在Release中会产生不可预料的后果</strong>。</p>
<blockquote>
<p><strong>有副作用的表达式</strong>指的是<strong>除了返回一个值之外，还会修改进程状态的表达式</strong>。这些状态变化可能包括：修改变量、执行IO、影响文件、网络、线程状态等。</p>
</blockquote>
]]></content>
      <categories>
        <category>编程陷阱</category>
      </categories>
      <tags>
        <tag>assert</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序与希尔排序</title>
    <url>/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>直接插入排序与希尔排序)<br>前言：直接插入排序与希尔排序都属于插入排序，它们排序的思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止得到一个新的有序序列<br><img src="https://i-blog.csdnimg.cn/blog_migrate/99a4736df5f1de28a91327d1d4890329.jpeg#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p><font color=#FF0000 >注意：下文中所有排序都是升序</font></p>
<h1 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a>一、直接插入排序</h1><p>&emsp;直接插入排序思想：<strong>每一趟将一个待排序的记录（元素），按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止</strong></p>
<h2 id="1-1-单趟排序实现"><a href="#1-1-单趟排序实现" class="headerlink" title="1.1 单趟排序实现"></a>1.1 单趟排序实现</h2><p>将待插入元素x插入[0,end]的有序序列，从后向前比较，当x值小于arr[end]时,<code>arr[end+1] = arr[end]</code>,end减1。当<code>end &lt; 0</code>或<code>x &gt;= arr[end]</code>时候，退出循环,并<code>arr[end+1] = x</code></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6fb27ca364db42b6d04918df7faa65cd.png#pic_center" alt="在这里插入图片描述"></p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>	<span class="title function_">Sort</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> size,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> end = size<span class="number">-1</span>; </span><br><span class="line">	<span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; arr[end])</span><br><span class="line">		&#123;</span><br><span class="line">			arr[end+<span class="number">1</span>] = arr[end];</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[end+<span class="number">1</span>] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-直接插入排序实现"><a href="#1-2-直接插入排序实现" class="headerlink" title="1.2 直接插入排序实现"></a>1.2 直接插入排序实现</h2><p>&emsp;当一个数组有n个元素，数组下标范围为: [0,n-1],可以将第1个元素作为一个有序序列，将第2个元素进行单趟排序，然后将前2个元素作为一个有序序列，将第3个元素进行单趟排序… …直到将前n-1个元素作为有序序列，将第n个元素进行单趟排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>;i++) <span class="comment">// 待排序趟数为n-1,下标小于等于i的元素已经是有序的，默认第一个元素有序，所以下标从0开始</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="type">int</span> end = i;  </span><br><span class="line">		<span class="type">int</span> elem = arr[end+<span class="number">1</span>]; <span class="comment">// 待插入元素</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (elem &lt; arr[end])</span><br><span class="line">			&#123;</span><br><span class="line">				arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">				end--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end + <span class="number">1</span>] = elem; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-时间复杂度与空间复杂度"><a href="#1-3-时间复杂度与空间复杂度" class="headerlink" title="1.3 时间复杂度与空间复杂度"></a>1.3 时间复杂度与空间复杂度</h2><p>当待排序序列是逆序时，时间复杂度最坏：<code>O(N^2)</code>  当待排序序列本身是有序时，时间复杂度最好：<code>O(N)</code> 。直接插入排序只用了常数个辅助变量空间，空间复杂度：<code>O(1)</code></p>
<p>说明：<br> &emsp;●序列中元素越接近有序，直接插入排序的时间效率越高，序列逆序，效率很低<br>  &emsp;●直接插入排序是一个稳定的排序算法</p>
<h1 id="二、希尔排序"><a href="#二、希尔排序" class="headerlink" title="二、希尔排序"></a>二、希尔排序</h1><p>&emsp;<strong>直接插入排序在两种情况下效率很高，情况一：当待排序的序列本身接近有序时候，只需要少量插入操作可以完成整个序列的排序。情况二：待排序序列元素个数比较少的时候</strong>。</p>
<p>&emsp;<strong>希尔排序是对直接插入排序的优化</strong>，希尔排序的思想：先选定一个整数gap，把<strong>待排序序列分为gap个子序列</strong>（组），所有距离为gap的元素分在同个子序列中，此时每个子序列元素个数比较少，然后<strong>对每个子序列进行直接插入排序</strong>。<strong>重复上述分组和排序的工作。当整个序列基本有序时进行一次直接插入排序，让序列中元素全部有序</strong></p>
<ol>
<li>多次分组预排序（让序列接近有序）</li>
<li>直接插入排序（让序列有序）<br><img src="https://i-blog.csdnimg.cn/blog_migrate/632d9bedc372bc4aad0163b4831a89b1.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2 id="2-1-对一组子序列的第一趟排序"><a href="#2-1-对一组子序列的第一趟排序" class="headerlink" title="2.1 对一组子序列的第一趟排序"></a>2.1 对一组子序列的第一趟排序</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9e18ac2610bf82a52b327d5e856a8de4.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> end = <span class="number">0</span>; <span class="comment">// 因为是第一组子序列，end=0</span></span><br><span class="line"><span class="type">int</span> elem = arr[end+gap];</span><br><span class="line"><span class="keyword">while</span>(end&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(elem &lt; arr[end])</span><br><span class="line">	&#123;</span><br><span class="line">		arr[end+gap] = arr[end];</span><br><span class="line">		end-=gap;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[end+gap] = elem;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-对一组子序列的直接插入排序"><a href="#2-2-对一组子序列的直接插入排序" class="headerlink" title="2.2 对一组子序列的直接插入排序"></a>2.2 对一组子序列的直接插入排序</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c7cacb09e1cda510775d5488b0dd9d42.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n-gap;i += gap) <span class="comment">// n 为数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> end = i; </span><br><span class="line">	<span class="type">int</span> elem = arr[end+gap];</span><br><span class="line">	<span class="keyword">while</span>(end &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(elem &lt; arr[end])</span><br><span class="line">		&#123;</span><br><span class="line">			arr[end+gap] = arr[end];</span><br><span class="line">			end-=gap;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[end+gap] = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-一次预排序"><a href="#2-3-一次预排序" class="headerlink" title="2.3 一次预排序"></a>2.3 一次预排序</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7721a36bb014c4686de4e1104ccc3768.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> gap = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;gap;j++) <span class="comment">// 对gap组子序列分别进行直接插入排序</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = j;i &lt; n-gap;i += gap) <span class="comment">// 对每一组子序列进行直接插入排序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> end = i; </span><br><span class="line">		<span class="type">int</span> elem = arr[end+gap];</span><br><span class="line">		<span class="keyword">while</span>(end &gt;= <span class="number">0</span>) <span class="comment">// 对某一组的某一趟排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(elem &lt; arr[end])</span><br><span class="line">			&#123;</span><br><span class="line">				arr[end+gap] = arr[end];</span><br><span class="line">				end-=gap;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end+gap] = elem;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-一次预排序（代码简单版）"><a href="#2-4-一次预排序（代码简单版）" class="headerlink" title="2.4 一次预排序（代码简单版）"></a>2.4 一次预排序（代码简单版）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2.3 一次预排序思想：是对gap组子序列分别进行直接插入排序，即先对第一组子序列直接插入排序、</span></span><br><span class="line"><span class="comment">	然后对第二组子序列直接插入排序......最后对第gap组子序列直接插入排序</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	2.4 一次预排序思想：对gap组子序列混合进行直接插入排序，因为某一组子序列需要进行多趟排序，可以首先对</span></span><br><span class="line"><span class="comment">	第一组子序列进行第一趟排序、对第二组子序列进行第一趟排序......对第gap组子序列进行第一趟排序。</span></span><br><span class="line"><span class="comment">	然后对第一组子序列进行第二趟排序、对第二组子序列进行第二趟排序......对第gap组子序列进行第二趟排序。</span></span><br><span class="line"><span class="comment">	......</span></span><br><span class="line"><span class="comment">	最后第一组子序列进行最后一趟排序、然后对第二组子序列进行最后一趟排序......最后对第gap组子序列进行最后一趟排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> gap = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n-gap;i++) <span class="comment">// 对gap组子序列混合进行直接插入排序</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> end = i; </span><br><span class="line">	<span class="type">int</span> elem = arr[end+gap];</span><br><span class="line">	<span class="keyword">while</span>(end &gt;= <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(elem &lt; arr[end])</span><br><span class="line">		&#123;</span><br><span class="line">			arr[end+gap] = arr[end];</span><br><span class="line">			end-=gap;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[end+gap] = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-5-希尔排序"><a href="#2-5-希尔排序" class="headerlink" title="2.5 希尔排序"></a>2.5 希尔排序</h2><p>希尔排序：1. 进行多次分组预排序  2. 直接插入排序</p>
<p><strong>进行多次分组预排序首先要确定gap的值，但是对gap怎样取值使希尔排序时间效率最高是一个数学难题</strong>。这里用gap&#x3D;[n&#x2F;2]<br>gap &#x3D; [gap&#x2F;2]的取法，即第一次分组预排序gap值为数组元素个数一半，后续分组预排序gap值为上次分组预排序gap值的一半，当gap&#x3D;1时相当于进行了直接插入排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="type">int</span> gap = n;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gap /= <span class="number">2</span>; <span class="comment">// 当gap大于1时是多次分组预排序，当gap等于1时是直接插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> elem = arr[end + gap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (elem &lt; arr[end])</span><br><span class="line">				&#123;</span><br><span class="line">					arr[end + gap] = arr[end];</span><br><span class="line">					end -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[end + gap] = elem;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-时间复杂度与空间复杂度"><a href="#2-6-时间复杂度与空间复杂度" class="headerlink" title="2.6 时间复杂度与空间复杂度"></a>2.6 时间复杂度与空间复杂度</h2><p>对于gap取值有多种方法，并且进行多次分组预排序后数组接近有序，后续分组预排序以及直接插入排序每趟比较次数越来越少。所以希尔排序的时间复杂度分析是一个十分复杂问题，时间复杂度大约为<code>O(N^1.3)</code>  。空间复杂度：<code>O(1)</code></p>
<p>说明：<br> &emsp;●希尔排序适合序列中元素个数较多情况<br>  &emsp;●希尔排序是一个不稳定的排序算法</p>
<h1 id="三、直接插入排序与希尔排序性能测试"><a href="#三、直接插入排序与希尔排序性能测试" class="headerlink" title="三、直接插入排序与希尔排序性能测试"></a>三、直接插入排序与希尔排序性能测试</h1><p><strong>排序时间效率与CPU紧密相关，不同计算机上测出结果可能不同，我们只需要关注同一计算机下两种排序所耗费时间相差倍数</strong></p>
<h2 id="3-1-基础代码"><a href="#3-1-基础代码" class="headerlink" title="3.1 基础代码"></a>3.1 基础代码</h2><p>因为要进行多种情况测试，为了避免代码庸余，在后续测试中只需要把基础代码粘贴进去即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>;i++) <span class="comment">// 待排序次数为n-1,下标小于等于i的元素已经是有序的</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="type">int</span> end = i;  </span><br><span class="line">		<span class="type">int</span> elem = arr[end+<span class="number">1</span>]; <span class="comment">// 待插入元素</span></span><br><span class="line">		<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (elem &lt; arr[end])</span><br><span class="line">			&#123;</span><br><span class="line">				arr[end + <span class="number">1</span>] = arr[end];</span><br><span class="line">				end--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[end + <span class="number">1</span>] = elem; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="type">int</span> gap = n;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		gap /= <span class="number">2</span>; <span class="comment">// 当gap大于1时是多次分组预排序，当gap等于1时是直接插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> end = i;</span><br><span class="line">			<span class="type">int</span> elem = arr[end + gap];</span><br><span class="line">			<span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (elem &lt; arr[end])</span><br><span class="line">				&#123;</span><br><span class="line">					arr[end + gap] = arr[end];</span><br><span class="line">					end -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[end + gap] = elem;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-数组元素个数较少情况"><a href="#3-2-数组元素个数较少情况" class="headerlink" title="3.2 数组元素个数较少情况"></a>3.2 数组元素个数较少情况</h2><p>数组元素个数为：1万，两个数组元素完全相同，分别使用直接插入排序与希尔排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">10000</span>; <span class="comment">// 数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* arr2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr1[i] = rand()%<span class="number">1000</span>; <span class="comment">// 生成[0,999]范围内随机数</span></span><br><span class="line">		arr2[i] = arr1[i]; <span class="comment">// 数组arr2元素等于数组arr1元素</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin1 = clock(); <span class="comment">// 排序前时间</span></span><br><span class="line">	InsertSort(arr1, N);</span><br><span class="line">	<span class="type">int</span> end1 = clock(); <span class="comment">// 排序后时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin2 = clock();</span><br><span class="line">	ShellSort(arr2, N);</span><br><span class="line">	<span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InsertSort：%d\n&quot;</span>, end1 - begin1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ShellSort：%d\n&quot;</span>, end2 - begin2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(arr1);</span><br><span class="line">	<span class="built_in">free</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 <strong>（单位为毫秒）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InsertSort：<span class="number">15</span></span><br><span class="line">ShellSort：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：元素个数较少情况，直接插入排序与希尔排序所花时间没有太大差距，在元素个数极少情况下，直接插入排序比希尔排序所花时间更少</strong></p>
<h2 id="3-3-数组元素个数较多情况"><a href="#3-3-数组元素个数较多情况" class="headerlink" title="3.3 数组元素个数较多情况"></a>3.3 数组元素个数较多情况</h2><p>数组元素个数为：100万，两个数组元素完全相同，分别使用直接插入排序与希尔排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">1000000</span>; <span class="comment">// 数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* arr2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr1[i] = rand()%<span class="number">1000</span>; <span class="comment">// 生成[0,999]范围内随机数</span></span><br><span class="line">		arr2[i] = arr1[i]; <span class="comment">// 数组arr2元素等于数组arr1元素</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin1 = clock(); <span class="comment">// 排序前时间</span></span><br><span class="line">	InsertSort(arr1, N);</span><br><span class="line">	<span class="type">int</span> end1 = clock(); <span class="comment">// 排序后时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin2 = clock();</span><br><span class="line">	ShellSort(arr2, N);</span><br><span class="line">	<span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InsertSort：%d\n&quot;</span>, end1 - begin1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ShellSort：%d\n&quot;</span>, end2 - begin2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(arr1);</span><br><span class="line">	<span class="built_in">free</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 <strong>（单位为毫秒）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InsertSort：<span class="number">148991</span></span><br><span class="line">ShellSort：<span class="number">121</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：元素个数较多情况，直接插入排序与希尔排序所花时间有着巨大差距，希尔排序远优于直接插入排序</strong></p>
<h2 id="3-4-直接插入排序有序与逆序情况测试"><a href="#3-4-直接插入排序有序与逆序情况测试" class="headerlink" title="3.4 直接插入排序有序与逆序情况测试"></a>3.4 直接插入排序有序与逆序情况测试</h2><p>数组元素个数为：1万，arr1为有序，arr2为逆序，都用直接插入排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">10000</span>; <span class="comment">// 数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* arr2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr1[i] = i; <span class="comment">// arr1为有序</span></span><br><span class="line">		arr2[i] = N-arr1[i]; <span class="comment">// arr2为逆序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin1 = clock(); <span class="comment">// 排序前时间</span></span><br><span class="line">	InsertSort(arr1, N);</span><br><span class="line">	<span class="type">int</span> end1 = clock(); <span class="comment">// 排序后时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin2 = clock();</span><br><span class="line">	InsertSort(arr2, N);</span><br><span class="line">	<span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InsertSort 有序情况：%d\n&quot;</span>, end1 - begin1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InsertSort 逆序情况：%d\n&quot;</span>, end2 - begin2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(arr1);</span><br><span class="line">	<span class="built_in">free</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出 （单位为毫秒）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InsertSort 有序情况：<span class="number">0</span></span><br><span class="line">InsertSort 逆序情况：<span class="number">1948</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：当数组接近有序，使用直接插入排序效率最高，时间复杂度为<code>O(N)</code>。当数组接近逆序,使用直接插入排序效率很低，时间复杂度为<code>O(N^2)</code></strong></p>
<h2 id="3-5-希尔排序有序与逆序情况测试"><a href="#3-5-希尔排序有序与逆序情况测试" class="headerlink" title="3.5 希尔排序有序与逆序情况测试"></a>3.5 希尔排序有序与逆序情况测试</h2><p>数组元素个数为：100万，arr1为有序，arr2为逆序，都用希尔排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">1000000</span>; <span class="comment">// 数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="type">int</span>* arr2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr1[i] = i; <span class="comment">// arr1为有序</span></span><br><span class="line">		arr2[i] = N-arr1[i]; <span class="comment">// arr2为逆序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin1 = clock(); <span class="comment">// 排序前时间</span></span><br><span class="line">	ShellSort(arr1, N);</span><br><span class="line">	<span class="type">int</span> end1 = clock(); <span class="comment">// 排序后时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin2 = clock();</span><br><span class="line">	ShellSort(arr2, N);</span><br><span class="line">	<span class="type">int</span> end2 = clock();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ShellSort 有序情况：%d\n&quot;</span>, end1 - begin1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ShellSort 逆序情况：%d\n&quot;</span>, end2 - begin2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(arr1);</span><br><span class="line">	<span class="built_in">free</span>(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出 （单位为毫秒）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ShellSort 有序情况：<span class="number">36</span></span><br><span class="line">ShellSort 逆序情况：<span class="number">42</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：希尔排序相对于直接插入排序，面对逆序情况下有了很好的优化</strong></p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>简单选择排序与堆排序</title>
    <url>/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>
前言：简单选择排序与堆排序都属于选择排序，它们排序的思想是：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置。然后再从剩余的未排序元素中寻找到最小（大）元素，放到已排序的序列的末尾，直到全部待排序的数据元素排完

<p><font color=#FF0000 >注意：下文中所有排序都是升序</font></p>
<h1 id="一、简单选择排序"><a href="#一、简单选择排序" class="headerlink" title="一、简单选择排序"></a>一、简单选择排序</h1><p>&emsp;简单选择排序思想：在待排序序列中选择关键码最小(大)的数据元素，若它不是序列中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换，重复上面步骤，直到序列只有1个元素为止。</p>
<span id="more"></span>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c41e5a1f5e2646f0984ab00d0fee466.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-1-简单选择排序"><a href="#1-1-简单选择排序" class="headerlink" title="1.1 简单选择排序"></a>1.1 简单选择排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end) <span class="comment">// 待排序序列元素个数小于等于1时退出循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 存放待排序序列最大值元素的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++) <span class="comment">// 单趟排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[i])</span><br><span class="line">			&#123;</span><br><span class="line">				max = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(max != end) <span class="comment">// 当最大值元素不是待排序序列最后一个元素时，将最大值元素与序列最后一个元素交换</span></span><br><span class="line">			swap(&amp;arr[max], &amp;arr[end]); </span><br><span class="line">		end--; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-简单选择排序优化"><a href="#1-2-简单选择排序优化" class="headerlink" title="1.2 简单选择排序优化"></a>1.2 简单选择排序优化</h2><p>&emsp;1.1 中每次排序找到序列中值最大的元素并与序列中最后一个元素交换。<strong>我们可以每次排序找到序列中值最小的元素和值最大的元素，分别与序列第一个元素和序列中最后一个元素交换</strong>,<font color=#FF0000 >需要注意如果最大值元素是序列第一个元素时，需要特殊处理，因为最大值元素与序列最后一个元素交换前，最小值元素与序列第一个元素已经交换了，此时最大值元素位置存放的是最小值了</font><br><img src="https://i-blog.csdnimg.cn/blog_migrate/477ac8d51acce9782f33eb6e55da7274.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>下面是错误代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>; </span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = begin; <span class="comment">// 存放待排序序列最大值元素的下标</span></span><br><span class="line">		<span class="type">int</span> min = begin; <span class="comment">// 存放待排序序列最小值元素的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[max])</span><br><span class="line">				max = i;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; arr[min])</span><br><span class="line">				min = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != begin) <span class="comment">// 当最小值元素不是待排序序列第一个元素时,将最小值元素与序列第一个元素交换</span></span><br><span class="line">			swap(&amp;arr[min], &amp;arr[begin]);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (max != end) <span class="comment">// 当最大值元素不是待排序序列最后一个元素时，将最大值元素与序列最后一个元素交换</span></span><br><span class="line">			swap(&amp;arr[max], &amp;arr[end]);</span><br><span class="line"></span><br><span class="line">		begin++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="type">int</span> begin = <span class="number">0</span>; </span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = begin; <span class="comment">// 存放待排序序列最大值元素的下标</span></span><br><span class="line">		<span class="type">int</span> min = begin;<span class="comment">// 存放待排序序列最小值元素的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[max])</span><br><span class="line">				max = i;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; arr[min])</span><br><span class="line">				min = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != begin) <span class="comment">// 当最小值元素不是待排序序列第一个元素时,将最小值元素与序列第一个元素交换</span></span><br><span class="line">			swap(&amp;arr[min], &amp;arr[begin]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (max == begin) <span class="comment">// 当max等于begin，上面操作将最大值换走了，需要调整最大值下标位置</span></span><br><span class="line">			max = min;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (max != end) <span class="comment">// 当最大值元素不是待排序序列最后一个元素时，将最大值元素与序列最后一个元素交换</span></span><br><span class="line">			swap(&amp;arr[max], &amp;arr[end]);</span><br><span class="line"></span><br><span class="line">		begin++;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-时间复杂度与空间复杂度"><a href="#1-3-时间复杂度与空间复杂度" class="headerlink" title="1.3 时间复杂度与空间复杂度"></a>1.3 时间复杂度与空间复杂度</h2><p>无论是最好还是最坏情况下简单选择排序时间复杂度都是：<code>O(N^2)</code>。简单选择排序只用了常数个辅助变量空间，空间复杂度：<code>O(1)</code></p>
<p>说明：<br> ●简单选择排序思想与代码实现比较简单，但是效率很低，一般很少使用<br> ●简单选择排序是一个不稳定的排序算法</p>
<h1 id="二、堆排序"><a href="#二、堆排序" class="headerlink" title="二、堆排序"></a>二、堆排序</h1><p>堆排序排升序一般构造大根堆，降序一般构造小根堆</p>
<p>&emsp;<strong>堆排序思想：利用堆的性质，将待排序的序列构造成一个大根堆，此时，整个序列的最大值就是堆顶的根节点。将它与堆数组的末尾元素交换，此时末尾元素就是最大值，然后将剩余的n-1个元素重新构造成一个大根堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列</strong></p>
<h2 id="2-1-向下调整构建大根堆"><a href="#2-1-向下调整构建大根堆" class="headerlink" title="2.1 向下调整构建大根堆"></a>2.1 向下调整构建大根堆</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/38b57689b4c2aac4ceb9f109a8603a2d.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* data, <span class="type">int</span> size, <span class="type">int</span> parent)</span> <span class="comment">// 向下调整算法前提，左右子树必须为堆</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		data为数组首元素地址,size为数组元素个数,parent为当前节点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子</span></span><br><span class="line">	<span class="keyword">while</span> (child &lt; size) <span class="comment">// 循环结束条件：1 调整到叶子节点（节点没有左孩子） 2. 孩子节点小于等于父节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 选出左右孩子中较大的一个 </span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; data[child + <span class="number">1</span>] &gt; data[child])</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data[child] &gt; data[parent]) <span class="comment">// 交换元素值，继续向下调整</span></span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;data[child], &amp;data[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a081be23fc5024910e9abae7c3c03199.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> parent = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; parent &gt;= <span class="number">0</span>; parent--) <span class="comment">// 建立大堆</span></span><br><span class="line">	&#123;</span><br><span class="line">		AdjustDown(arr, n ,parent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>; <span class="comment">// 堆中最后一个元素下标</span></span><br><span class="line">	<span class="keyword">for</span> (end; end &gt; <span class="number">0</span>; end--)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(&amp;arr[<span class="number">0</span>], &amp;arr[end]);</span><br><span class="line">		AdjustDown(arr, end, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-测试堆排序"><a href="#2-3-测试堆排序" class="headerlink" title="2.3 测试堆排序"></a>2.3 测试堆排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintArray</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdjustDown</span><span class="params">(<span class="type">int</span>* data, <span class="type">int</span> size, <span class="type">int</span> parent)</span> <span class="comment">// 向下调整算法前提，左右子树必须为堆</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; size) <span class="comment">// 循环结束条件：1 调整到叶子节点（节点没有左孩子） 2. 孩子节点大于等于（小于等于）父节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 选出左右孩子中较小（较大）的一个 </span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt; size &amp;&amp; data[child + <span class="number">1</span>] &gt; data[child])</span><br><span class="line">		&#123;</span><br><span class="line">			child++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (data[child] &gt; data[parent]) <span class="comment">// 交换元素值，继续向下调整</span></span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;data[child], &amp;data[parent]);</span><br><span class="line">			parent = child;</span><br><span class="line">			child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> parent = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; parent &gt;= <span class="number">0</span>; parent--) <span class="comment">// 建立大堆</span></span><br><span class="line">	&#123;</span><br><span class="line">		AdjustDown(arr, n ,parent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> end = n - <span class="number">1</span>; <span class="comment">// 堆中最后一个元素下标</span></span><br><span class="line">	<span class="keyword">for</span> (end; end &gt; <span class="number">0</span>; end--)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(&amp;arr[<span class="number">0</span>], &amp;arr[end]);</span><br><span class="line">		AdjustDown(arr, end, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	PrintArray(arr, <span class="number">10</span>);</span><br><span class="line">	HeapSort(arr,<span class="number">10</span>);</span><br><span class="line">	PrintArray(arr, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">9</span> <span class="number">7</span> <span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-时间复杂度"><a href="#2-4-时间复杂度" class="headerlink" title="2.4 时间复杂度"></a>2.4 时间复杂度</h2><p>堆排序主要消耗时间在建堆和排序上，使用向下调整建堆时间复杂度：<code>O(N)</code>,排序时间复杂度：<code>O(Nlog₂N)</code>，所以堆排序时间复杂度：<code>O(Nlog₂N)</code>，堆排序只用了常数个辅助变量空间，空间复杂度：<code>O(1)</code></p>
<p>说明：<br> ●堆排序是一个不稳定的排序算法<br> ●堆排序前需要建堆</p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 新特性</title>
    <url>/C-%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    <content><![CDATA[<h1 id="一、基于范围for循环"><a href="#一、基于范围for循环" class="headerlink" title="一、基于范围for循环"></a>一、基于范围for循环</h1><p>&emsp; 在C&#x2F;C++中经常需要遍历数组做某些事情，数组的遍历边界由程序员自己控制，经常有人粗心导致数组越界。并且遍历写起来比较繁琐</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>C++11中引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的对象</strong>。由于不知道被迭代对象的元素是什么类型，我们可以使用<code>auto</code>。</p>
<span id="more"></span>

<h2 id="1-1-遍历对象"><a href="#1-1-遍历对象" class="headerlink" title="1.1 遍历对象"></a>1.1 遍历对象</h2><p>&emsp;遍历对象有两种方式，方式一：将对象中每个元素值拷贝到迭代的变量中，方式二：使用引用，迭代的变量就是对象元素的引用，<strong>推荐方式二</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">        cout &lt;&lt; &amp;arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次循环读取数组元素值并赋值给临时变量e中，对e打印,e的生命周期是循环结束才销毁</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> e : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&amp;e = &quot;</span> &lt;&lt; &amp;e &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次循环引用对应数组元素，e的生命周期是单次循环后销毁</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&amp;e = &quot;</span> &lt;&lt; &amp;e &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span>9FF958</span><br><span class="line"><span class="number">00</span>9FF95C</span><br><span class="line"><span class="number">00</span>9FF960</span><br><span class="line"><span class="number">00</span>9FF964</span><br><span class="line"><span class="number">00</span>9FF968</span><br><span class="line">&amp;e = <span class="number">00</span>9FF91C</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF91C</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF91C</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF91C</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF91C</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF958</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF95C</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF960</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF964</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&amp;e = <span class="number">00</span>9FF968</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-修改对象"><a href="#1-2-修改对象" class="headerlink" title="1.2 修改对象"></a>1.2 修改对象</h2><p>&emsp;由于要修改对象中每个元素，只能使用引用方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : arr) <span class="comment">// 每次循环e引用对应数组元素，e的生命周期是单次循环后销毁</span></span><br><span class="line">	&#123;</span><br><span class="line">		e = e + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-范围for限制条件"><a href="#1-3-范围for限制条件" class="headerlink" title="1.3 范围for限制条件"></a>1.3 范围for限制条件</h2><p>&emsp;范围for迭代的对象范围必须是确定的，下面这种使用是错误的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> arr[])</span> <span class="comment">// arr是数组首元素地址，没有范围概念</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; elem;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">print</span>(arr); <span class="comment">// 错误使用</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、nullptr"><a href="#二、nullptr" class="headerlink" title="二、nullptr"></a>二、nullptr</h1><p>&emsp;C&#x2F;C++中指针让我们可以随心所欲的操作数据，但也带来了许多陷阱。在C语言中对于一个指针变量不用时让它指向NULL。但在C++中却不能这样，<strong>因为NULL本质是一个宏，C和C++对NULL宏定义不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出在C语言中，NULL被定义为<code>((void *)0)</code>，类型为指针.而在C++中被定为<code>0</code>,类型为int。<strong>C++11 引入关键字<code>nullptr</code>用来定义空指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在C++11 中定义空指针方法</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>; <span class="comment">// 推荐方式</span></span><br><span class="line"><span class="type">int</span>* p = ((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span>* p = ((<span class="type">void</span> *)<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 缺省参数</title>
    <url>/C-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="一、什么是缺省参数"><a href="#一、什么是缺省参数" class="headerlink" title="一、什么是缺省参数"></a>一、什么是缺省参数</h1><p>缺省参数：<strong>是在函数声明或函数定义时为形参指定一个默认值，当调用函数时没有传入对应实参则将默认值做为实参传给形参</strong></p>
<p><strong>注意：函数声明与函数定义中不能同时定义缺省参数，下面代码为错误代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>,<span class="type">int</span> y = <span class="number">20</span>,<span class="type">int</span> z = <span class="number">30</span>)</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>,<span class="type">int</span> y = <span class="number">20</span>,<span class="type">int</span> z = <span class="number">30</span>)</span></span>; </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;z = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>在函数声明与函数定义时都写缺省参数，极容易将两个地方默认值设置的不一致，导致编译器不知道以哪一个默认值为准，所以编译器直接不允许在两处同时写缺省参数</li>
<li>推荐将缺省参数写在函数声明处，一般调用其他人实现函数我们只需要看函数声明知道用法，而不会去看函数定义了解函数怎么实现</li>
</ol>
<span id="more"></span>

<h1 id="二、缺省参数定义"><a href="#二、缺省参数定义" class="headerlink" title="二、缺省参数定义"></a>二、缺省参数定义</h1><h2 id="2-1-全缺省参数"><a href="#2-1-全缺省参数" class="headerlink" title="2.1 全缺省参数"></a>2.1 全缺省参数</h2><p>全缺省参数：函数中每个形参都有对应默认值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x = <span class="number">10</span>,<span class="type">int</span> y = <span class="number">20</span>,<span class="type">int</span> z = <span class="number">30</span>)</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;z = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		当实参个数少于形参时，实参从左到右依次赋值给形参，剩下形参使用默认值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">Print</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl; </span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">z = <span class="number">30</span></span><br><span class="line">-------------</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">z = <span class="number">30</span></span><br><span class="line">-------------</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = <span class="number">30</span></span><br><span class="line">-------------</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = <span class="number">3</span></span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>
<h2 id="2-2-半缺省参数"><a href="#2-2-半缺省参数" class="headerlink" title="2.2 半缺省参数"></a>2.2 半缺省参数</h2><p>半缺省参数：函数中部分形参有对应默认值，半缺省参数必须从右到左给出，不能跳跃给</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// void Print(int x = 10, int y,int z = 30);   错误，形参z有默认值，形参x有默认值，形参y没有默认值，形成了跳跃</span></span><br><span class="line"><span class="comment">// void Print(int x = 10, int y,int z);  错误，半缺省参数必须从右到左给</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">20</span>,<span class="type">int</span> z = <span class="number">30</span>)</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> z)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;z = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">z = <span class="number">30</span></span><br><span class="line">-------------</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = <span class="number">30</span></span><br><span class="line">-------------</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = <span class="number">3</span></span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>
<h1 id="三、缺省参数与函数重载带来的二义性"><a href="#三、缺省参数与函数重载带来的二义性" class="headerlink" title="三、缺省参数与函数重载带来的二义性"></a>三、缺省参数与函数重载带来的二义性</h1><p><strong>使用缺省参数可以提高函数的易用性，但是当缺省参数与函数重载不恰当的结合会产生二义性，降低函数的清晰性</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x = <span class="number">1</span>,<span class="type">double</span> y = <span class="number">0.00</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int、double&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>, <span class="number">0.0</span>); <span class="comment">// 正常调用Print(int x,double y)</span></span><br><span class="line">	<span class="built_in">Print</span>(); <span class="comment">// 正常调用Print(int x,double y)</span></span><br><span class="line">	<span class="built_in">Print</span>(<span class="number">1</span>); <span class="comment">// 错误，对重载函数调用不明确，有二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>缺省参数</tag>
      </tags>
  </entry>
  <entry>
    <title>C++17 工具类optional、variant、any</title>
    <url>/C-17-%E5%B7%A5%E5%85%B7%E7%B1%BBoptional%E3%80%81variant%E3%80%81any.html</url>
    <content><![CDATA[<h1 id="一、std-optional"><a href="#一、std-optional" class="headerlink" title="一、std::optional"></a>一、std::optional</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>在开发中，经常会处理一些“可能为空”的函数返回值，该返回值可能赋予了一个有效值，也可能没有被赋予有效值。为了区分这两种情况，需要写一些额外的代码，导致代码可读性较差，甚至更容易出错。常见的做法有：</p>
<ul>
<li>返回一个<em>magic value</em>，表示“为空”，不是有效值。但它存在语义不清晰，稍不注意就会与合法值冲突。</li>
<li>函数形参增加一个输出型参数，表示函数返回值是否被赋值。但它会导致接口隐晦，代码可读性差。</li>
</ul>
<p>例如：有个函数查找一个值是否在数组中存在，如果存在则返回在数组中首次出现的下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用-1作为 magic value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_value</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (vec[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用输出型参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_value</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> val, <span class="type">bool</span> &amp;exists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    exists = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (vec[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="1-2-std-optional是什么"><a href="#1-2-std-optional是什么" class="headerlink" title="1.2 std::optional是什么"></a>1.2 std::optional是什么</h2><p><code>std::optional</code> 是 C++17 引入的一个 <strong>模板类</strong>，定义在<code>optional</code>头文件中。它是一个容器，要么包含一个类型为<em>T</em>的值，要么为“空状态”。“空状态”也有自己的类型和值：类型是<code>std::nullopt_t</code>，值为<code>std::nullopt</code>。</p>
<p>声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">optional</span>;</span><br></pre></td></tr></table></figure>



<p>有了<code>std::optional</code>可以很优雅处理变量可能“为空”问题，<em>1.1</em>节中代码可以改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">find_value</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="keyword">if</span> (vec[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">find_value</span>(v, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">has_value</span>()) <span class="comment">// 检查值是否设置</span></span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;index=&quot;</span> &lt;&lt; result.<span class="built_in">value</span>() &lt;&lt; std::endl; <span class="comment">// 访问值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;does not exist&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::optional</code>对象初始化非常简单，可以默认初始化为空，或使用<code>std::nullopt</code>显式初始化为空。可以用任何一个<em>T</em>类型或可以隐式转换成<em>T</em>类型的变量来构造它，也可以传入<em>T</em>类型构造参数，调用<em>T</em>类型的构造函数进行构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化为空</span></span><br><span class="line">std::optional&lt;std::string&gt; obj;</span><br><span class="line">std::optional&lt;std::string&gt; obj = std::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化不为空</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">obj</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">std::optional&lt;std::string&gt; obj = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::optional&lt;std::string&gt; obj = std::<span class="built_in">make_optional</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">obj</span><span class="params">(std::in_place, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-相关函数"><a href="#1-3-相关函数" class="headerlink" title="1.3 相关函数"></a>1.3 相关函数</h2><p>下面为<code>std::optional</code>常用成员函数</p>
<p><strong>has_value</strong>与<strong>operator bool</strong>：如果不为空返回<code>true</code>，否则返回<code>false</code></p>
<p><strong>value</strong>：如果不为空返回值的引用，否则抛出<code>std::bad_optional_access</code>异常</p>
<p><strong>value_or</strong>：如果不为空则返回该值（非引用），否则返回传入的默认值</p>
<p><strong>operator</strong>*：如果不为空返回值的引用，为空则是未定义行为</p>
<p><strong>operator-&gt;</strong>：如果不为空返回值的指针，为空则是未定义行为</p>
<p><strong>reset</strong>：置为空</p>
<p><strong>emplace</strong>:在内部就地构造一个<em>T</em>类型的值，如果之前有值，会先析构然后再构造新的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::optional&lt;std::string&gt; obj; <span class="comment">// 初始化为空</span></span><br><span class="line">    <span class="keyword">if</span> (!obj.<span class="built_in">has_value</span>()) <span class="comment">// obj为空，执行该条件语句，将值设置为&quot;hello&quot;</span></span><br><span class="line">      	obj = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;当前字符串=&quot;</span> &lt;&lt; obj.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">reset</span>(); <span class="comment">// 置为空</span></span><br><span class="line">    <span class="keyword">auto</span> str = obj.<span class="built_in">value_or</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 由于为空，所以返回默认值&quot;world&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str=&quot;</span> &lt;&lt; str &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="comment">// 调用operator bool函数，函数返回false</span></span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;当前字符串=&quot;</span> &lt;&lt; *obj &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      	obj = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">emplace</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// obj值为&quot;abc&quot;，先析构，然后构造为&quot;hello world&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前字符串长度=&quot;</span> &lt;&lt; obj-&gt;<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 调用operator-&gt;函数，返回字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-原地构造"><a href="#1-4-原地构造" class="headerlink" title="1.4 原地构造"></a>1.4 原地构造</h2><p>将使用<code>std::in_place</code>或<code>std::make_optional</code>把参数直接转发给 <em>T</em>类型的构造函数的方式称为原地构造，那么什么时候需要原地构造呢？主要有以下情况：</p>
<ol>
<li>类型<em>T</em>需要使用默认构造函数进行构造</li>
</ol>
<p>如果有一个类，它只提供了一个默认构造函数，那么怎么使用该类默认构造函数构造<code>std::optional</code>内部的值呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">A</span>() : _a(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可能想到先构造一个类A的临时对象，然后将该临时对象拷贝构造给<code>std::optional</code>内的值。但是这种会有额外开销，并且如果类A的拷贝构造函数被删除的话，将会编译失败。在这种情况下，可以使用<code>std::in_place</code>或<code>std::make_optional</code>来原地构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">std::optional&lt;A&gt; obj&#123;<span class="built_in">A</span>()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">std::optional&lt;A&gt; obj&#123;std::in_place&#125;;</span><br><span class="line">std::optional&lt;A&gt; obj = std::<span class="built_in">make_optional</span>&lt;A&gt;();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拷贝构造函数或移动构造函数被删除</li>
</ol>
<p>如果类型<em>T</em>的拷贝构造或移动构造函数被删除了，将一个<em>T</em>类型对象拷贝或移动给<code>std::optional</code>内的要构造的值会编译失败。在这种情况下，可以使用<code>std::in_place</code>或<code>std::make_optional</code>来原地构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : _a(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;) = <span class="keyword">delete</span>;      <span class="comment">// 删除移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>类型<em>T</em> 的构造函数有多个参数</li>
</ol>
<p>如果类型<em>T</em>的构造函数中有多个参数也推荐使用原地构造方式将这些参数直接转发给 <em>T</em>的构造函数。避免先创建一个类型<em>T</em>对象，然后再将该对象移动到<code>std::optional</code>内，这样会有额外开销。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function">A <span class="title">obj</span><span class="params">(<span class="number">20</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">std::optional&lt;A&gt; x = std::<span class="built_in">move</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function">std::optional&lt;A&gt; <span class="title">x</span><span class="params">(std::in_place, <span class="number">20</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">std::optional&lt;A&gt; x = std::<span class="built_in">make_optional</span>&lt;A&gt;(<span class="number">20</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h1 id="二、std-variant"><a href="#二、std-variant" class="headerlink" title="二、std::variant"></a>二、std::variant</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p>如果有个变量需要存放多种类型，但在任一时间点内只会存放其中一种类型，我们第一时间会想到<code>union</code>。<code>union</code>内所有成员共享同一块内存，所占内存大小等于最大成员变量的大小（不考虑内存对齐）。<code>union</code>在内存敏感、网络协议解析等场景普遍应用。但是<code>union</code>需要手动维护标志位才能知道当前存的是哪种类型，并且缺乏类型安全检查，对非POD类型限制较多（C++11之前）。</p>
<h2 id="2-2-std-variant是什么"><a href="#2-2-std-variant是什么" class="headerlink" title="2.2 std::variant是什么"></a>2.2 std::variant是什么</h2><p><code>std::variant</code> 是 C++17 引入的一个 <strong>模板类</strong>，定义在<code>variant</code>头文件中。它是一个类型安全联合体，只需要在定义时指定可能需要存放的类型。</p>
<p>声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">variant</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：类型不允许为引用、数组、void</strong>。</p>
<p>下面为一个简单例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">10</span>; <span class="comment">// 存放int</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var) &lt;&lt; std::endl; <span class="comment">// 访问类型index为0的值，即int类型</span></span><br><span class="line"></span><br><span class="line">    var = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl; <span class="comment">// 访问类型为double的值</span></span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">emplace</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 构造类型为std::string的值</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">emplace</span>&lt;<span class="type">float</span>&gt;(<span class="number">2.22f</span>); <span class="comment">// 编译错误，var定义时没有指定float类型</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h2><p><strong><code>std::variant</code>如果没有显式初始化，默认会调用第一个类型的默认构造函数进行初始化，即默认初始化第一个类型。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::variant&lt;A, B, C&gt; var;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>



<p>如果默认初始化且第一个类型没有默认构造函数的话，编译会失败，此时可以使用<code>std::monostate</code>。<strong><code>std::monostate</code> 是一个辅助类，里面没有任何成员变量，并且提供默认构造函数，可以作为 <code>std::variant</code> 的“空值”类型</strong>。即把 <code>std::monostate</code> 放在第一个位置，就又能让<code>std::variant</code>默认初始化了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 提供一个有参构造函数，编译器不再生成默认构造函数</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> a) :_a(a)&#123; std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::variant&lt;std::monostate, A, B, C&gt; var;</span><br></pre></td></tr></table></figure>



<p><strong>如果<code>std::variant</code>中第一个类型没有默认构造函数、想初始化非第一个类型、类型拷贝构造&#x2F;移动构造函数被删除时的情况下。可以显式初始化<code>std::variant</code></strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var1 = <span class="number">2025</span>;        <span class="comment">// int</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var2 = <span class="number">3.14</span>;        <span class="comment">// double</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; var3 = <span class="string">&quot;hello&quot;</span>;     <span class="comment">// const char* 会隐式转换为 std::string</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, std::string&gt; <span class="title">var4</span><span class="params">(std::in_place_type&lt;<span class="type">const</span> <span class="type">char</span> *&gt;, <span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">// const char *</span></span><br><span class="line"><span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">v5</span><span class="params">(std::in_place_index&lt;<span class="number">2</span>&gt;, <span class="string">&quot;world&quot;</span>)</span></span>; <span class="comment">// std::string</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-相关函数"><a href="#2-4-相关函数" class="headerlink" title="2.4 相关函数"></a>2.4 相关函数</h2><p>下面为<code>std::variant</code>常用成员函数</p>
<p><strong>index</strong>：返回当前存放值的类型index</p>
<p><strong>emplace</strong>:在内部就地构造一个指定类型的值，如果之前有值，会先析构然后再构造新值</p>
<p>下面为常用非成员函数</p>
<p><strong>std::get</strong>：返回存储值的引用，可以基于index或类型。如果存放的不是该类型的值，则抛出<code>std::bad_variant_access</code>异常</p>
<p><strong>std::get_if</strong>：返回存储值的指针，可以基于index或类型。如果存放的不是该类型的值，则返回空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">const</span> <span class="type">char</span> *, std::string&gt; var;</span><br><span class="line">    var = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">1</span> == var.<span class="built_in">index</span>());</span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">emplace</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::bad_variant_access <span class="type">const</span> &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;: var contained string, not const char*&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">2025</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">double</span> *p = std::<span class="built_in">get_if</span>&lt;<span class="type">double</span>&gt;(&amp;var); p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;variant value: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;failed to get_if value!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; *(std::<span class="built_in">get_if</span>&lt;<span class="type">int</span>&gt;(&amp;var)) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bad_variant_access: var contained string, <span class="keyword">not</span> <span class="type">const</span> <span class="type">char</span>*</span><br><span class="line">hello</span><br><span class="line">failed to get_if value!</span><br><span class="line"><span class="number">2025</span></span><br></pre></td></tr></table></figure>

<h1 id="三、std-any"><a href="#三、std-any" class="headerlink" title="三、std::any"></a>三、std::any</h1><h2 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h2><p>C++ 是一个<strong>静态类型语言</strong>，变量类型需要在编译期确定。但在有些场景下，我们在运行时才知道类型，例如解析配置文件、解析JSON串等。如果想单个变量存储任意类型的值，常用方法是通过<code>void*</code>。<code>void*</code> 是 <strong>无类型指针</strong>， 可以指向任意类型的数据。但它 <strong>不保存类型信息</strong>，使用时需要自己知道类型并强制转换回来，并且存在对象内存管理麻烦等缺点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">2025</span>;</span><br><span class="line">p = &amp;i;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;val=&quot;</span> &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(p) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">p = &amp;s;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;val=&quot;</span> &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;std::string*&gt;(p) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-std-any是什么"><a href="#3-2-std-any是什么" class="headerlink" title="3.2 std::any是什么"></a>3.2 std::any是什么</h2><p><code>std::any</code> 是 C++17 引入的一个 <strong>工具类</strong>，定义在<code>any</code>头文件中。它是一个类型安全的容器，可以存放任意类型的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::any var;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">2025</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    var = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">emplace</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(var) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-初始化"><a href="#3-3-初始化" class="headerlink" title="3.3 初始化"></a>3.3 初始化</h2><p><strong><code>std::any</code>如果没有显式初始化，则默认为空，不包含任何值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::any var;</span><br><span class="line"><span class="built_in">assert</span>(!var.<span class="built_in">has_value</span>());</span><br></pre></td></tr></table></figure>

<p><strong>下面为显式初始化，它包含一个值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::any var1 = <span class="number">2025</span>; <span class="comment">// int</span></span><br><span class="line">std::any var2 = <span class="number">3.14</span>; <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::any <span class="title">var3</span><span class="params">(std::in_place_type&lt;std::string&gt;, <span class="string">&quot;hello&quot;</span>)</span></span>; <span class="comment">// std::string</span></span><br><span class="line"></span><br><span class="line">std::any var4 = std::<span class="built_in">make_any</span>&lt;<span class="type">float</span>&gt;(<span class="number">1.23f</span>); <span class="comment">// float</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-相关函数"><a href="#3-4-相关函数" class="headerlink" title="3.4 相关函数"></a>3.4 相关函数</h2><p>下面为<code>std::any</code>常用成员函数</p>
<p><strong>has_value</strong>：如果包含一个值返回<code>true</code>，否则返回<code>false</code></p>
<p><strong>type</strong>：返回所包含值的类型标识符，不包含值时返回值没有意义</p>
<p><strong>emplace</strong>：在内部就地构造一个指定类型的值，如果之前有值，会先析构然后再构造新值</p>
<p><strong>reset</strong>：置为空</p>
<p>下面为常用非成员函数</p>
<p><strong>any_cast</strong>：对所包含的值进行类型安全的访问，通过值或引用获取时，如果类型不匹配，抛<code>std::bad_any_cast</code>异常。通过指针获取时，如果类型不匹配，返回空指针。</p>
<p><strong>make_any</strong>：构造一个 <code>std::any</code> 对象，内部包含一个类型为 <em>T</em>的值，该值通过提供的参数进行构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::any var = std::<span class="built_in">make_any</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(var.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(std::string));</span><br><span class="line">    std::string str = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(var); <span class="comment">// 存在拷贝</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">reset</span>(); <span class="comment">// 置为空</span></span><br><span class="line">    <span class="built_in">assert</span>(!var.<span class="built_in">has_value</span>());</span><br><span class="line"></span><br><span class="line">    var.emplace&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="keyword">auto</span> v = std::any_cast&lt;std::vector&lt;<span class="type">double</span>&gt; &amp;&gt;(var); <span class="comment">// 获取值的引用，不存在拷贝，但是此时any内部值类型为vector&lt;int&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var.<span class="built_in">emplace</span>&lt;<span class="type">int</span>&gt;(<span class="number">2025</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> *p = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(&amp;var); p != <span class="literal">nullptr</span>) <span class="comment">// 获取值的指针，如果值类型不匹配，则返回空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      	std::cout &lt;&lt; <span class="string">&quot;var is not an int, real_type=&quot;</span> &lt;&lt; var.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">error: bad any cast</span><br><span class="line"><span class="type">int</span>: <span class="number">2025</span></span><br></pre></td></tr></table></figure>



<h2 id="3-5-部分细节"><a href="#3-5-部分细节" class="headerlink" title="3.5 部分细节"></a>3.5 部分细节</h2><h3 id="3-5-1-存储结构"><a href="#3-5-1-存储结构" class="headerlink" title="3.5.1 存储结构"></a>3.5.1 存储结构</h3><p><code>std::any</code>的存储结构取决于存储的值的类型和大小。对于小的或者是POD（Plain Old Data）类型，<code>std::any</code>通常会使用一种称为”小对象优化”（Small Object Optimization）的技术，直接在<code>std::any</code>对象内部存储这些值。对于大的或者是非POD类型，<code>std::any</code>则会动态分配内存来存储这些值。</p>
<p>这种设计使得<code>std::any</code>可以有效地存储各种类型的值，同时避免了不必要的动态内存分配开销。然而，这也意味着<code>std::any</code>的大小并不是固定的，而是取决于存储的值的类型和大小。</p>
<h3 id="3-5-2-类型擦除"><a href="#3-5-2-类型擦除" class="headerlink" title="3.5.2 类型擦除"></a>3.5.2 类型擦除</h3><p><code>std::any</code>的实现通常使用了一种称为”类型擦除”（Type Erasure）的技术。类型擦除是一种允许程序在运行时处理不同类型的数据，同时保持类型安全的技术。在C++中，类型擦除通常通过使用模板和虚函数来实现。</p>
<p>此外，<code>std::any</code>的类型擦除特性也会带来一些性能开销。每次我们查询或转换<code>std::any</code>对象的类型时，都需要进行一些额外的运行时检查确保安全性。</p>
]]></content>
      <categories>
        <category>C plus plus</category>
      </categories>
      <tags>
        <tag>C++ 17</tag>
      </tags>
  </entry>
</search>
