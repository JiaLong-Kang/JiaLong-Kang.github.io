<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>四季</title>
  
  <subtitle>Seasons</subtitle>
  <link href="https://blog.kjlcloud.com/atom.xml" rel="self"/>
  
  <link href="https://blog.kjlcloud.com/"/>
  <updated>2025-03-10T07:29:00.263Z</updated>
  <id>https://blog.kjlcloud.com/</id>
  
  <author>
    <name>JiaLong Kang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C/C++ 在assert中不要使用带有副作用的表达式</title>
    <link href="https://blog.kjlcloud.com/2025/03/10/C-C-%E5%9C%A8assert%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.kjlcloud.com/2025/03/10/C-C-%E5%9C%A8assert%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2025-03-10T06:31:08.000Z</published>
    <updated>2025-03-10T07:29:00.263Z</updated>
    
    <content type="html"><![CDATA[<p>   最近在项目中使用<code>assert</code>出现了一个bug，排查了半天才定位到错误，在讲这个陷阱之前先铺垫一下<code>assert</code>基础知识。 <code>assert</code>是 C&#x2F;C++ 中的一个<strong>宏</strong>，定义在<code>assert.h</code>文件中。<code>assert</code> 宏将在 <em>expression</em> 计算结果为 <strong>false</strong>(0) 时打印错误信息并调用<code>abort</code>函数终止进程。 如果 <em><code>expression</code></em> 为 <strong>true</strong> （非0），则不执行任何操作。 错误信息包括失败的expression、源文件名以及失败的行号。<strong>如果定义了<code>NDEBUG</code>宏，<code>assert</code>不会被启用</strong>。<code>assert</code>适用于捕捉不应该发生的非法情况，而不是错误处理，因为错误是可以预料的。</p><p>  现在讲讲我遇到的坑，最近准备将项目中使用的一个nfs客户端库切换到新版本，并想对比下新版本对性能提升多少，所以我准备一个简单测试程序，向nfs服务器写入1G数据， 测试代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">1</span> , <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfsfh</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="type">int</span> r = nfs_open(<span class="string">&quot;file1&quot;</span>, O_RDWR, &amp;fd);</span><br><span class="line"><span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Failed to create file\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1024</span>; i++) <span class="comment">// Write 1G</span></span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="keyword">sizeof</span>(buf) == nfs_write(fd, buf, <span class="keyword">sizeof</span>(buf)));</span><br><span class="line">&#125;</span><br><span class="line">nfs_close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当运行测试程序，程序正常结束。检查文件大小，也是符合预期。突然想起是测性能，所以我在项目<code>cmake</code>中指定编译为Release版本，之前为Debug版本。然后运行，发现文件虽然在nfs服务器中创建了，但是文件大小为0。这让我一脸懵，因为如果向文件写入数据失败一定会触发断言，程序应该崩溃才对。最开始怀疑是不是新版本库有bug，排查了后发现没问题。想了半天突然想起来，我现在是Release版本，<code>cmake</code> 会在编译时定义<code>NDEBUG</code>宏，<code>assert</code>不会被启用，所以nfs_write函数根本没有执行。<strong>所以千万不要在<code>assert</code>中使用带有副作用的表达式，不然发现程序在Debug中正常运行，在Release中会产生不可预料的后果</strong>。</p><blockquote><p><strong>有副作用的表达式</strong>指的是<strong>除了返回一个值之外，还会修改进程状态的表达式</strong>。这些状态变化可能包括：修改变量、执行IO、影响文件、网络、线程状态等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;   最近在项目中使用&lt;code&gt;assert&lt;/code&gt;出现了一个bug，排查了半天才定位到错误，在讲这个陷阱之前先铺垫一下&lt;code&gt;assert&lt;/code&gt;基础知识。 &lt;code&gt;assert&lt;/code&gt;是 C&amp;#x2F;C++ 中的一个&lt;strong&gt;宏&lt;/s</summary>
      
    
    
    
    <category term="编程陷阱" scheme="https://blog.kjlcloud.com/categories/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/"/>
    
    
    <category term="assert" scheme="https://blog.kjlcloud.com/tags/assert/"/>
    
  </entry>
  
  <entry>
    <title>gtest 快速入门</title>
    <link href="https://blog.kjlcloud.com/2025/02/20/gtest-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.kjlcloud.com/2025/02/20/gtest-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2025-02-20T10:00:00.000Z</published>
    <updated>2025-02-20T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：之前在工作中简单用过gtest，但当时项目比较赶时间，对测试并不是很重视。经常出现一个人改完代码后，模块之间出现bug情况，然后花很长时间排查bug。吸取教训后准备在新项目中引入gtest，花了两天时间学习了gtest文档，发现它功能还是蛮多的。准备整理一个gtest系列的专栏，也是检验自己学习成果。</p><h1 id="一、-gtest快速入门"><a href="#一、-gtest快速入门" class="headerlink" title="一、 gtest快速入门"></a>一、 gtest快速入门</h1><h2 id="1-1-gtest是什么"><a href="#1-1-gtest是什么" class="headerlink" title="1.1 gtest是什么"></a>1.1 gtest是什么</h2><p><code>gtest</code> 是 Google Test 的简称，是一个由 Google 开发与维护的 C++ 测试框架。它提供了丰富的断言和测试工具，帮助开发者编写更好的 C++ 测试代码。</p><span id="more"></span><p><strong>特点</strong>：</p><ul><li>丰富的断言：支持多种断言宏，如 <code>EXPECT_TRUE</code>、<code>ASSERT_TRUE</code> 等，便于验证测试结果。</li><li>支持多种测试结构：例如<code>TEST</code>、<code>TEST_F</code> 和 <code>TEST_P</code>等，以满足不同的测试场景。</li><li>自动生成测试报告：可指定生成xml、json格式测试报告</li><li>跨平台：支持 Windows、Linux、macOS 等多个平台。</li><li>与构建系统集成：可与 CMake、Bazel 等构建工具无缝集成。</li></ul><h2 id="1-2-构建一个gtest项目"><a href="#1-2-构建一个gtest项目" class="headerlink" title="1.2 构建一个gtest项目"></a>1.2 构建一个gtest项目</h2><p>我们可以直接从github上下载<code>gtest</code>作为一个独立项目来学习，也可将<code>gtest</code>合并到现有的项目中去。</p><p><strong>将gtest作为独立项目</strong></p><p><code>gtest</code>本身提供了许多示例供我们学习，示例代码位于<code>googletest/samples</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/googletest.git <span class="comment"># 下载gtest最新代码</span></span><br><span class="line"><span class="built_in">cd</span> googletest </span><br><span class="line"><span class="built_in">mkdir</span> build <span class="comment"># 创建编译目录</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake3 .. <span class="comment"># 如果想构建这些示例程序，需要加上 -Dgtest_build_samples=ON</span></span><br><span class="line">make </span><br></pre></td></tr></table></figure><p><strong>整合到现有的项目中</strong></p><p>修改现有项目的<code>CMakeLists.txt</code>文件，声明对<code>gtest</code> 的依赖关系。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">        googletest</span><br><span class="line">        URL https://github.com/google/googletest/archive/refs/tags/release-<span class="number">1.10</span>.<span class="number">0</span>.zip</span><br><span class="line">)</span><br><span class="line"><span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line"><span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br></pre></td></tr></table></figure><p>上述配置声明了对从 GitHub 下载的<code>gtest</code>依赖，1.10.0表示要下载的<code>gtest</code>版本，因为我系统上<code>gcc</code>编译器比较老，不支持c++ 14，所以我下的<code>gtest</code>版本较低，大家可以根据自身环境下载合适版本。</p><p>将 <code>gtest</code> 声明为依赖项后，便可以在自己的项目中使用<code>gtest</code>了。例如创建一个<code>hello_test.cc</code>的文件，测试计算阶乘的函数是否正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, Negative)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-5</span>)); <span class="comment">// 测试-5的阶乘是否等于1</span></span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-1</span>)); <span class="comment">// 测试-1的阶乘是否等于1</span></span><br><span class="line"><span class="built_in">EXPECT_GT</span>(<span class="built_in">Factorial</span>(<span class="number">-10</span>), <span class="number">0</span>); <span class="comment">// 测试-10的阶乘是否大于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gtest</code>提供了<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcHJpbWVyLmh0bWwjYXNzZXJ0aW9ucw==">一些断言<i class="fa fa-external-link-alt"></i></span>，您可以使用它们来测试代码的行为。上面的示例演示了一些基本断言，后面将会详细讲解这些断言的功能。</p><p>可以发现上述测试代码中没有<code>main</code>函数，那么怎么编译运行呢？我们只需要链接<code>gtest-main</code>库，它提供了一个默认的 <code>main</code> 函数实现，用于运行所有的测试。</p><p>要编译测试程序，请将以下内容添加到<code>CMakeLists.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        hello_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        gtest_main</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在，让我们运行测试程序看下效果吧，可以看到运行成功，所以断言都通过了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test</span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from FactorialTest</span><br><span class="line">[ RUN      ] FactorialTest.Negative</span><br><span class="line">[       OK ] FactorialTest.Negative (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from FactorialTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure><h2 id="1-3-gtest入门"><a href="#1-3-gtest入门" class="headerlink" title="1.3 gtest入门"></a>1.3 gtest入门</h2><h3 id="1-3-1-基本概念"><a href="#1-3-1-基本概念" class="headerlink" title="1.3.1 基本概念"></a>1.3.1 基本概念</h3><p><code>gtest</code>使用断言（Assertion）来检查某些条件是否为真，以此验证代码的行为，可以认为断言就是一个检查点。**断言的结果有成功、 非致命失败和致命失败三种。**当断言失败时，会打印断言所处的文件名与行号，以便我们快速定位错误位置。</p><p>在<code>gtest</code>中，断言主要分为两类，<strong><code>ASSERT_*</code>版本失败时会产生致命失败，并中止当前函数。<code>EXPECT_*</code>版本会产生非致命失败，不会中止当前函数</strong>。通常<code>EXPECT_*</code>是首选，因为它们允许在测试中报告多个错误。如果在某个断言失败后，后续测试代码继续运行没有任何意义则应使用<code>ASSERT_*</code>。</p><p>可以通过 <code>&lt;&lt;</code> 运算符向断言中添加自定义错误信息，当断言失败时，这些信息会显示在测试输出中，帮助快速定位问题。任何可以流式传输到<code>ostream</code>的内容都可以流式传入到断言中——特别是C风格字符串和C++ string对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ASSERT_EQ</span>(x.<span class="built_in">size</span>(), y.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++i) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个测试程序可以包含多个测试套件（test suite），一个测试套件包含一个或多个测试</strong>。应该将测试分组到能够反映测试代码结构的测试套件中。<strong>测试使用断言来验证测试代码的行为</strong>，如果测试崩溃或断言失败（不管是否为致命失败），则认为该测试失败；否则认为测试成功。</p><blockquote><p>已知限制：<code>gtest</code>的设计是线程安全的。在<code>pthread</code>库可用的系统上，实现是线程安全的。目前，在其他系统（例如Windows）上从两个线程并发地使用<code>gtest</code>断言是不安全的。在大多数测试中，这不是问题，因为断言通常在主线程中完成。如果您想提供帮助，您可以自愿为您的平台实现<code>gtest-port.h</code>中必要的同步原语。</p></blockquote><h3 id="1-3-2-TEST"><a href="#1-3-2-TEST" class="headerlink" title="1.3.2 TEST"></a>1.3.2 TEST</h3><p><code>TEST</code>是一个宏，用于定义<strong>测试套件（Test Suite）<strong>相关的测试。 <code>TEST</code>宏有两个参数，第一个参数是</strong>测试套件的名称</strong>，第二个参数是<strong>测试名称</strong>，两个名称都必须是有效的 C++ 标识符，并且<strong>不应包含任何下划线字符</strong>。测试的全名由测试套件+测试名组成。来自不同测试套件的测试名可以相同。</p><p>要创建测试：</p><ol><li>使用<code>TEST</code>宏定义并命名测试函数。这是一个没有返回值的 C++ 函数。</li><li>在此函数中，除了您想要包含的任何有效 C++ 语句外，还使用<code>gtest</code>提供的各种断言来检查条件是否满足。</li><li>测试结果由断言决定；如果测试中的任何断言失败（无论是致命的还是非致命的），或者测试崩溃，则整个测试失败。否则，测试成功。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(TestSuiteName, TestName) </span><br><span class="line">&#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们有一个计算阶乘的函数，此功能的测试套件可能如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, HandlesEvenInput)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">2</span>), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">4</span>), <span class="number">23</span>); <span class="comment">// 4的阶乘为24，使用EXPECT_EQ，非致命失败，该测试后续代码继续运行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;t1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">6</span>), <span class="number">720</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, HandlesOddInput)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">3</span>), <span class="number">5</span>); <span class="comment">// 3的阶乘为6，使用ASSERT_EQ，致命失败，该测试后续代码不会运行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;t2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">ASSERT_EQ</span>(<span class="built_in">Factorial</span>(<span class="number">5</span>), <span class="number">120</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gtest</code>按测试套件对测试结果进行分组，因此逻辑上相关的测试应该在同一个测试套件中；换句话说，它们在<code>TEST</code>宏中第一个参数应该相同。在上面的例子中，我们有两个测试， <code>HandlesZeroInput</code>和<code>HandlesPositiveInput</code>，它们属于同一个测试<code>FactorialTest</code>。</p><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from FactorialTest</span><br><span class="line">[ RUN      ] FactorialTest.HandlesEvenInput</span><br><span class="line">/xxx/hello_test.cpp:18: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  Factorial(4)</span><br><span class="line">    Which is: 24</span><br><span class="line">  23</span><br><span class="line">t1</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesEvenInput (0 ms)</span><br><span class="line">[ RUN      ] FactorialTest.HandlesOddInput</span><br><span class="line">/xxx/hello_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  Factorial(3)</span><br><span class="line">    Which is: 6</span><br><span class="line">  5</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesOddInput (0 ms)</span><br><span class="line">[----------] 2 tests from FactorialTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 2 tests, listed below:</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesEvenInput</span><br><span class="line">[  FAILED  ] FactorialTest.HandlesOddInput</span><br><span class="line"></span><br><span class="line"> 2 FAILED TESTS</span><br></pre></td></tr></table></figure><h3 id="1-3-3-TEST-F"><a href="#1-3-3-TEST-F" class="headerlink" title="1.3.3 TEST_F"></a>1.3.3 TEST_F</h3><p><code>TEST_F</code>是一个宏，用于定义<strong>测试夹具（Test Fixture）<strong>相关的测试。它是 <code>TEST</code> 宏的扩展（<code>_F</code>代表“Fixture”），允许在同一测试夹具的多个测试之间共享相同的配置和资源。使用 <code>TEST_F</code> 可以避免重复代码，并确保测试环境的一致性。<code>TEST</code>宏有两个参数，第一个参数是</strong>测试夹具的名称</strong>，第二个参数是<strong>测试名称</strong>，两个名称都必须是有效的 C++ 标识符，并且<strong>不应包含任何下划线字符</strong>。</p><p>要创建夹具：</p><ol><li>定义一个测试夹具类，它必须继承<code>testing::Test</code>类</li><li>在夹具类内部，声明您计划使用的任何资源。</li><li>如果有必要，编写一个默认构造函数或override <code>SetUp</code>函数初始化资源。</li><li>如果需要，请编写一个析构函数或override  <code>TearDown</code>函数来释放资源。要了解何时应使用构造函数&#x2F;析构函数以及何时应使用<code>SetUp()/TearDown()</code>，请阅读<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvZmFxLmh0bWwjQ3RvclZzU2V0VXA=">常见问题解答<i class="fa fa-external-link-alt"></i></span>。</li><li>如果需要，请定义要共享的测试子程序。</li></ol><p>当使用夹具时，使用<code>TEST_F()</code>而不是<code>TEST()</code>，因为它允许您访问测试夹具中的对象和子例程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(TestFixtureClassName, TestName) </span><br><span class="line">&#123;</span><br><span class="line">  ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：对于使用<code>TEST_F</code>定义的每个测试，<code>gtest</code>将在运行时创建一个新的测试夹具对象，并调用<code>SetUp</code>函数初始化资源。运行完一个测试后，通过调用<code>TearDown</code>函数进行资源清理，然后删除这个对象。即同一测试夹具中的不同测试不会复用夹具对象，一个测试对夹具所做的任何更改都不会影响其他测试。</p><p>比如我们有个计算器类，要对它进行功能测试。我们希望每个测试都使用一些相同数据，并且不同测试之间互不影响，所以使用测试夹具，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试夹具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTest</span> : <span class="keyword">public</span> ::testing::Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 在每个测试运行前调用，进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个 Calculator 对象</span></span><br><span class="line">calculator = <span class="keyword">new</span> <span class="built_in">Calculator</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Setting up the test environment.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每个测试运行后调用，进行清理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 删除 Calculator 对象，清理资源</span></span><br><span class="line"><span class="keyword">delete</span> calculator;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Tearing down the test environment.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享的测试数据</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2024</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">Calculator *calculator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试加法功能</span></span><br><span class="line"><span class="built_in">TEST_F</span>(CalculatorTest, AddTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在 SetUp 中初始化了 calculator，可以直接使用它</span></span><br><span class="line"><span class="type">int</span> result = calculator-&gt;<span class="built_in">add</span>(x, y);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(result, <span class="number">2025</span>);  <span class="comment">// 验证加法是否正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试减法功能</span></span><br><span class="line"><span class="built_in">TEST_F</span>(CalculatorTest, SubtractTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在 SetUp 中初始化了 calculator，可以直接使用它</span></span><br><span class="line"><span class="type">int</span> result = calculator-&gt;<span class="built_in">subtract</span>(x, y);</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(result, <span class="number">2023</span>);  <span class="comment">// 验证减法是否正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行测试程序时</p><ol><li><code>gtest</code>先创建一个CalculatorTest对象（我们称之为<code>t1</code>）</li><li>调用<code>SetUp</code>函数对计算器资源初始化，使用t1测试完加法功能后，调用<code>TearDown</code>清理资源，并删除t1对象</li><li>创建另一个对象重复上述步骤测试减法功能</li></ol><p>不过上面示例可以不override <code>SetUp</code>和<code>TearDown</code>，使用构造与析构函数也能实现一样功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from CalculatorTest</span><br><span class="line">[ RUN      ] CalculatorTest.AddTest</span><br><span class="line">Setting up the <span class="built_in">test</span> environment.</span><br><span class="line">Tearing down the <span class="built_in">test</span> environment.</span><br><span class="line">[       OK ] CalculatorTest.AddTest (0 ms)</span><br><span class="line">[ RUN      ] CalculatorTest.SubtractTest</span><br><span class="line">Setting up the <span class="built_in">test</span> environment.</span><br><span class="line">Tearing down the <span class="built_in">test</span> environment.</span><br><span class="line">[       OK ] CalculatorTest.SubtractTest (0 ms)</span><br><span class="line">[----------] 2 tests from CalculatorTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><h3 id="1-3-4-编写main函数"><a href="#1-3-4-编写main函数" class="headerlink" title="1.3.4 编写main函数"></a>1.3.4 编写main函数</h3><p>在上文的所有示例中我们都没有编写<code>main</code>函数，而是链接<code>gtest-main</code>库，库中提供了一个默认 <code>main</code>函数，它会自动初始化测试框架并运行所有的测试，这在绝大多数情况下适用。</p><p>如果需要在测试运行之前执行一些无法在测试套件和测试夹具内表达的自定义操作，我们需要自己编写<code>main</code>函数，这个<code>main</code>函数通常包含以下步骤：</p><ol><li>测试运行前自定义操作</li><li>调用<code>::testing::InitGoogleTest</code>函数解析<code>gtest</code>可以识别的命令行参数（标志），这允许用户通过各种参数控制测试程序的行为</li><li>调用 <code>RUN_ALL_TESTS</code> 来运行所有的测试，如果所有测试运行成功返回0，否则返回1</li></ol><p>当调用该<code>RUN_ALL_TESTS</code>：</p><ul><li>保存所有<code>gtest</code> 标志的状态</li><li>为第一个测试创建一个测试夹具对象</li><li>调用<code>SetUp</code>初始化</li><li>在夹具对象上运行测试</li><li>调用<code>TearDown</code>清理</li><li>删除该对象</li><li>恢复所有<code>gtest</code>标志的状态。</li><li>对下一个测试重复上述步骤，直到所有测试都运行完毕。</li></ul><blockquote><p>重要提示：您不能忽略<code>RUN_ALL_TESTS</code>的返回值，否则将得到编译器错误。这样设计的理由是：自动测试服务应根据其退出码确定测试是否通过，而不是根据其<code>stdout</code>&#x2F;<code>stderr</code>输出；</p><p>另外，<code>RUN_ALL_TESTS</code>只应调用一次。多次调用会与某些高级<code>gtest</code>功能（例如线程安全 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCNkZWF0aC10ZXN0cw==">死亡测试<i class="fa fa-external-link-alt"></i></span>）相冲突。</p></blockquote><p>假设我们有一个全局的日志系统，需要在运行测试之前初始化日志配置，并在所有测试结束后关闭日志系统。这时，我们需要自定义 <code>main</code> 函数来完成这些操作，例如创建一个<code>hello_test.cc</code>的文件，文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个日志系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Logger initialized!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Logger shutdown!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, Test1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MyTestSuite, Test2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EXPECT_NE</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 main 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Logger::<span class="built_in">Initialize</span>(); <span class="comment">// 启动日志系统</span></span><br><span class="line"></span><br><span class="line">::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv); <span class="comment">// 初始化 Google Test</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = <span class="built_in">RUN_ALL_TESTS</span>(); <span class="comment">// 运行所有测试</span></span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Shutdown</span>(); <span class="comment">// 自定义清理：关闭日志系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要编译测试程序，请将以下内容添加到<code>CMakeLists.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        hello_test.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        hello_test</span><br><span class="line">        gtest <span class="comment"># 我们自己编写了main函数，所有链接gtest库而不是gtest_main库</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-3-5-断言参考"><a href="#1-3-5-断言参考" class="headerlink" title="1.3.5 断言参考"></a>1.3.5 断言参考</h3><p><code>gtest</code>使用断言来验证代码行为，要使用断言，添加<code>#include &lt;gtest/gtest.h&gt;</code>。本节将列出<code>gtest</code>提供的所有断言，以后有需要可作参考。</p><p><code>gtest</code>提供的断言宏大多数是<code>EXPECT_*</code>和<code>ASSER_*</code>配对出现。当失败时，<code>EXPECT_*</code>宏会产生非致命失败并允许当前函数继续运行，而<code>ASSERT_*</code> 宏会产生致命失败并中止当前函数。</p><h4 id="1-3-5-1-布尔"><a href="#1-3-5-1-布尔" class="headerlink" title="1.3.5.1 布尔"></a>1.3.5.1 布尔</h4><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_TRUE(condition)</code>;</td><td><code>EXPECT_TRUE(condition)</code>;</td><td>condition is <em>true</em></td></tr><tr><td><code>ASSERT_FALSE(condition)</code>;</td><td><code>EXPECT_FALSE(condition)</code>;</td><td>condition is <em>false</em></td></tr></tbody></table><h4 id="1-3-5-2-整数、指针、string"><a href="#1-3-5-2-整数、指针、string" class="headerlink" title="1.3.5.2 整数、指针、string"></a>1.3.5.2 整数、指针、string</h4><p>以下断言比较两个值。值参数必须能被断言的比较运算符比较，否则编译器会报错。</p><p>如果参数支持<code>&lt;&lt;</code>运算符，则在断言失败时将调用它来打印参数。否则，GoogleTest 将尝试以最佳方式打印它们 - 请参阅 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCN0ZWFjaGluZy1nb29nbGV0ZXN0LWhvdy10by1wcmludC15b3VyLXZhbHVlcw==">教 GoogleTest 如何打印您的值<i class="fa fa-external-link-alt"></i></span>。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_EQ(val1, val2);</code></td><td><code>EXPECT_EQ(val1, val2);</code></td><td><em>val1</em> &#x3D;&#x3D; <em>val2</em></td></tr><tr><td><code>ASSERT_NE(val1, val2);</code></td><td><code>EXPECT_NE(val1, val2);</code></td><td><em>val1</em> !&#x3D; <em>val2</em></td></tr><tr><td><code>ASSERT_LT(val1, val2);</code></td><td><code>EXPECT_LT(val1, val2);</code></td><td><em>val1</em> &lt; <em>val2</em></td></tr><tr><td><code>ASSERT_LE(val1, val2);</code></td><td><code>EXPECT_LE(val1, val2);</code></td><td><em>val1</em> &lt;&#x3D; <em>val2</em></td></tr><tr><td><code>ASSERT_GT(val1, val2);</code></td><td><code>EXPECT_GT(val1, val2);</code></td><td><em>val1</em> &gt; <em>val2</em></td></tr><tr><td><code>ASSERT_GE(val1, val2);</code></td><td><code>EXPECT_GE(val1, val2);</code></td><td><em>val1</em> &gt;&#x3D; <em>val2</em></td></tr></tbody></table><p><code>ASSERT_EQ</code>、<code>EXPECT_EQ</code>和<code>ASSERT_NE</code>、<code>EXPECT_NE</code>还可以比较：</p><ol><li>C++ <code>std::string</code></li><li>指针，当比较指针是否为空应使用<code>EXPECT_EQ(ptr, nullptr)</code>而不是<code>EXPECT_EQ(ptr, NULL)</code>，对于<code>ASSERT_NE</code>也适用</li></ol><h4 id="1-3-5-3-C-风格字符串"><a href="#1-3-5-3-C-风格字符串" class="headerlink" title="1.3.5.3 C 风格字符串"></a>1.3.5.3 C 风格字符串</h4><p>以下断言比较两个C 风格字符串。要比较两个<code>std::string</code> 对象或 C风格字符串与空指针比较，请改用<code>EXPECT_EQ</code>或<code>EXPECT_NE</code></p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_STREQ(str1, str2);</code></td><td><code>EXPECT_STREQ(str1, str2);</code></td><td>the two C strings have the same content</td></tr><tr><td><code>ASSERT_STRNE(str1, str2);</code></td><td><code>EXPECT_STRNE(str1, str2);</code></td><td>the two C strings have different content</td></tr><tr><td><code>ASSERT_STRCASEEQ(str1,str2);</code></td><td><code>EXPECT_STRCASEEQ(str1, str2);</code></td><td>the two C strings have the same content, ignoring case</td></tr><tr><td><code>ASSERT_STRCASENE(str1,str2);</code></td><td><code>EXPECT_STRCASENE(str1, str2);</code></td><td>the two C strings have different content, ignoring case</td></tr></tbody></table><h4 id="1-3-5-4-浮点"><a href="#1-3-5-4-浮点" class="headerlink" title="1.3.5.4 浮点"></a>1.3.5.4 浮点</h4><p>由于舍入误差，两个浮点值完全匹配的可能性很小，因此<code>EXPECT_EQ</code>不合适。通常，为了使浮点比较有意义，用户需要仔细选择误差界限。GoogleTest 还提供了使用基于最后单位 (ULP) 的默认错误界限的断言。要了解有关 ULP 的更多信息，请参阅文章 <span class="exturl" data-url="aHR0cHM6Ly9yYW5kb21hc2NpaS53b3JkcHJlc3MuY29tLzIwMTIvMDIvMjUvY29tcGFyaW5nLWZsb2F0aW5nLXBvaW50LW51bWJlcnMtMjAxMi1lZGl0aW9uLw==">比较浮点数<i class="fa fa-external-link-alt"></i></span>。</p><p>彼此之间的差异在 4 个 ULP 以内则认为相等。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_FLOAT_EQ(val1,val2);</code></td><td><code>EXPECT_FLOAT_EQ(val1,val2);</code></td><td>the two <code>float</code> values are almost equal</td></tr><tr><td><code>ASSERT_DOUBLE_EQ(val1,val2);</code></td><td><code>EXPECT_DOUBLE_EQ(val1,val2);</code></td><td>the two <code>double</code> values are almost equa</td></tr></tbody></table><p>验证val1和val2之间的差值不会超过绝对误差界限<code>abs_error</code>。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_NEAR(val1, val2, abs_error);</code></td><td><code>EXPECT_NEAR(val1, val2, abs_error);</code></td><td>the difference between <em>val1</em> and <em>val2</em> doesn’t exceed the given absolute error</td></tr></tbody></table><h4 id="1-3-5-5-异常"><a href="#1-3-5-5-异常" class="headerlink" title="1.3.5.5 异常"></a>1.3.5.5 异常</h4><p>以下断言验证一段代码是否抛出异常。使用时需要在构建环境中启用异常。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_THROW(statement, exception_type);</code></td><td><code>EXPECT_THROW(statement, exception_type);</code></td><td><em>statement</em> throws an exception of the given type</td></tr><tr><td><code>ASSERT_ANY_THROW(statement);</code></td><td><code>EXPECT_ANY_THROW(statement);</code></td><td><em>statement</em> throws an exception of any type</td></tr><tr><td><code>ASSERT_NO_THROW(statement);</code></td><td><code>EXPECT_NO_THROW(statement);</code></td><td><em>statement</em> doesn’t throw any exception</td></tr></tbody></table><p>测试例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throws_invalid_argument</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Invalid argument&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">throws_out_of_range</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectThrowTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">EXPECT_THROW</span>(<span class="built_in">throws_invalid_argument</span>(), std::invalid_argument); <span class="comment">// 断言成功</span></span><br><span class="line"><span class="built_in">EXPECT_THROW</span>(<span class="built_in">throws_out_of_range</span>(), std::invalid_argument); <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectAnyThrowTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 测试是否抛出了任何类型的异常</span></span><br><span class="line"><span class="built_in">EXPECT_ANY_THROW</span>(<span class="built_in">throws_invalid_argument</span>()); <span class="comment">// 断言成功</span></span><br><span class="line"><span class="built_in">EXPECT_ANY_THROW</span>(<span class="built_in">throws_out_of_range</span>()); <span class="comment">// 断言成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(ExceptionTest, ExpectNoThrowTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 测试是否没有抛出异常</span></span><br><span class="line"><span class="built_in">EXPECT_NO_THROW</span>(<span class="built_in">throws_invalid_argument</span>()); <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 3 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 3 tests from ExceptionTest</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectThrowTest</span><br><span class="line">/xxx/hello_test.cpp:16: Failure</span><br><span class="line">Expected: throws_out_of_range() throws an exception of <span class="built_in">type</span> std::invalid_argument.</span><br><span class="line">  Actual: it throws a different <span class="built_in">type</span>.</span><br><span class="line">[  FAILED  ] ExceptionTest.ExpectThrowTest (0 ms)</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectAnyThrowTest</span><br><span class="line">[       OK ] ExceptionTest.ExpectAnyThrowTest (0 ms)</span><br><span class="line">[ RUN      ] ExceptionTest.ExpectNoThrowTest</span><br><span class="line">/xxx/hello_test.cpp:30: Failure</span><br><span class="line">Expected: throws_invalid_argument() doesn<span class="string">&#x27;t throw an exception.</span></span><br><span class="line"><span class="string">  Actual: it throws.</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectNoThrowTest (0 ms)</span></span><br><span class="line"><span class="string">[----------] 3 tests from ExceptionTest (0 ms total)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[----------] Global test environment tear-down</span></span><br><span class="line"><span class="string">[==========] 3 tests from 1 test suite ran. (1 ms total)</span></span><br><span class="line"><span class="string">[  PASSED  ] 1 test.</span></span><br><span class="line"><span class="string">[  FAILED  ] 2 tests, listed below:</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectThrowTest</span></span><br><span class="line"><span class="string">[  FAILED  ] ExceptionTest.ExpectNoThrowTest</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 2 FAILED TESTS</span></span><br></pre></td></tr></table></figure><h4 id="1-3-5-6-谓词"><a href="#1-3-5-6-谓词" class="headerlink" title="1.3.5.6 谓词"></a>1.3.5.6 谓词</h4><p>以下断言可以验证更复杂的谓词(Predicate，一个返回bool的可调用对象)，并打印比<code>EXPECT_TRUE</code>更清晰的失败信息。</p><p>参数<code>pred</code>是一个可调用对象，它接受与相应宏相同数量的参数。如果<code>pred</code>对给定的参数返回true，则断言成功，否则断言失败。当断言失败时，它打印出每个实参的值，便于排错，它最多接受5个参数。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_PRED1(pred, val1);</code></td><td><code>EXPECT_PRED1(pred, val1);</code></td><td><em>pred(val1)</em> return true</td></tr><tr><td><code>ASSERT_PRED2(pred, val1, val2);</code></td><td><code>EXPECT_PRED2(pred, val1, val2);</code></td><td><em>pred(val1, val2)</em> return true</td></tr><tr><td><code>ASSERT_PRED3(pred, val1, val2, val3);</code></td><td><code>EXPECT_PRED3(pred, val1, val2, val3);</code></td><td><em>pred(val1, val2, val3)</em> return true</td></tr><tr><td><code>ASSERT_PRED4(pred, val1, val2, val3, val4);</code></td><td><code>EXPECT_PRED2(pred, val1, val2, val3 ,val4);</code></td><td><em>pred(val1, val2, val3 ,val4)</em> return true</td></tr><tr><td><code>ASSERT_PRED5(pred, val1, val2, val3, val4 ,val5);</code></td><td><code>EXPECT_PRED2(pred, val1, val2, val3, val4, val5);</code></td><td><em>pred(val1, val2, val3, val4, val5)</em> return true</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词函数：检查 value 是否在 [low, high] 范围内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInRange</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt;= low &amp;&amp; value &lt;= high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(PredicateTest, IsInRangeTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">2000</span>;</span><br><span class="line"><span class="type">int</span> high = <span class="number">2025</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">2012</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED3</span>(IsInRange, value, low, high); <span class="comment">// 断言成功</span></span><br><span class="line"><span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsInRange</span>(value, low, high));  <span class="comment">// 断言成功</span></span><br><span class="line"></span><br><span class="line">value = <span class="number">2026</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED3</span>(IsInRange, value, low, high); <span class="comment">// 断言失败</span></span><br><span class="line"><span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsInRange</span>(value, low, high));  <span class="comment">// 断言失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>ASSERT_PRED2</code>可以打印所有参数的值，有助于快速定位问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateTest</span><br><span class="line">[ RUN      ] PredicateTest.IsInRangeTest</span><br><span class="line">/xxx/hello_test.cpp:20: Failure</span><br><span class="line">IsInRange(value, low, high) evaluates to <span class="literal">false</span>, <span class="built_in">where</span></span><br><span class="line">value evaluates to 2026</span><br><span class="line">low evaluates to 2000</span><br><span class="line">high evaluates to 2025</span><br><span class="line">/xxx/hello_test.cpp:21: Failure</span><br><span class="line">Value of: IsInRange(value, low, high)</span><br><span class="line">  Actual: <span class="literal">false</span></span><br><span class="line">Expected: <span class="literal">true</span></span><br><span class="line">[  FAILED  ] PredicateTest.IsInRangeTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] PredicateTest.IsInRangeTest</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果给定的谓词是重载函数或函数模板，断言宏可能无法确定调用哪个版本，并且可能需要明确指定函数的类型。</p></blockquote><p>对于<code>IsPositive</code>重载为单个参数为<code>int</code>或<code>double</code>版本，使用时需要显式指定函数的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(<span class="type">double</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>); </span><br></pre></td></tr></table></figure><p>对于函数模版也是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPositive</span><span class="params">(T n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">int</span>&gt;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED1</span>(IsPositive&lt;<span class="type">double</span>&gt;, <span class="number">3.14</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果您想自定义断言失败的错误信息，可以使用下面这类宏。参数<code>pred_formatter</code>是一个具有以下签名的可调用对象，其中<code>val1</code>、<code>val2</code>、 …<code>valn</code>是谓词参数的值，而<code>expr1</code>、<code>expr2</code>、 …<code>exprn</code>是源代码中对应的表达式。类型<code>T1</code>、<code>T2</code>、 …<code>Tn</code> 可以是值类型或引用类型，例<code>T</code>、<code>T&amp;</code>、<code>const T&amp;</code>等。有关返回类型的更多信息<code>testing::AssertionResult</code>，请参阅 <span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCN1c2luZy1hLWZ1bmN0aW9uLXRoYXQtcmV0dXJucy1hbi1hc3NlcnRpb25yZXN1bHQ=">返回 AssertionResult 的函数<i class="fa fa-external-link-alt"></i></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">testing::AssertionResult <span class="title">PredicateFormatter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* expr1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> <span class="type">char</span>* expr2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ...</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> <span class="type">char</span>* exprn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            T1 val1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            T2 val2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ...</span></span></span><br><span class="line"><span class="params"><span class="function">                                            Tn valn)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_PRED_FORMAT1(pred_formatter, val1);</code></td><td><code>EXPECT_PRED_FORMAT1(pred_formatter, val1);</code></td><td><em>pred_formatter(expr1, val1)</em> return true</td></tr><tr><td><code>ASSERT_PRED_FORMAT2(pred_formatter, val1, val2);</code></td><td><code>EXPECT_PRED_FORMAT2(pred_formatter, val1, val2);</code></td><td>…</td></tr><tr><td><code>ASSERT_PRED_FORMAT3(pred_formatter, val1, val2, val3);</code></td><td><code>EXPECT_PRED_FORMAT3(pred_formatter, val1, val2, val3);</code></td><td>…</td></tr><tr><td><code>ASSERT_PRED_FORMAT4(pred_formatter, val1, val2, val3, val4);</code></td><td><code>EXPECT_PRED_FORMAT4(pred_formatter, val1, val2, val3 ,val4);</code></td><td>…</td></tr><tr><td><code>ASSERT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4 ,val5);</code></td><td><code>EXPECT_PRED_FORMAT5(pred_formatter, val1, val2, val3, val4, val5);</code></td><td>…</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsInRange</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt;= low &amp;&amp; value &lt;= high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="function">testing::AssertionResult <span class="title">IsInRangeFormat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">char</span> *value_expr, <span class="type">const</span> <span class="type">char</span> *low_expr, <span class="type">const</span> <span class="type">char</span> *high_expr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsInRange</span>(value, low, high))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ::testing::<span class="built_in">AssertionSuccess</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ::testing::<span class="built_in">AssertionFailure</span>()</span><br><span class="line">&lt;&lt; <span class="string">&quot;Value &quot;</span> &lt;&lt; value_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; value</span><br><span class="line">&lt;&lt; <span class="string">&quot; is not in range [&quot;</span> &lt;&lt; low_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; low</span><br><span class="line">&lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; high_expr &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; high &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(PredicateFormatTest, IsInRangeTest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">2000</span>;</span><br><span class="line"><span class="type">int</span> high = <span class="number">2025</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">2026</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_PRED_FORMAT3</span>(IsInRangeFormat, value, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[user1@develop tests]$ ./hello_test </span><br><span class="line">Running main() from xxx</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateFormatTest</span><br><span class="line">[ RUN      ] PredicateFormatTest.IsInRangeTest</span><br><span class="line">/xxx/hello_test.cpp:32: Failure</span><br><span class="line">Value value = 2026 is not <span class="keyword">in</span> range [low = 2000, high = 2025]</span><br><span class="line">[  FAILED  ] PredicateFormatTest.IsInRangeTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from PredicateFormatTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 0 tests.</span><br><span class="line">[  FAILED  ] 1 <span class="built_in">test</span>, listed below:</span><br><span class="line">[  FAILED  ] PredicateFormatTest.IsInRangeTest</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure><h4 id="1-3-5-7-显式的成功和失败"><a href="#1-3-5-7-显式的成功和失败" class="headerlink" title="1.3.5.7 显式的成功和失败"></a>1.3.5.7 显式的成功和失败</h4><p>本节中的断言直接生成成功或失败，而不是测试值或表达式。当由控制流而不是布尔表达式决定测试的成功或失败时，这很有用。</p><p><code>SUCCEED()</code> ： 生成成功，这并不会使整个测试成功。只有当测试在执行过程中没有任何断言失败时，测试才被视为成功。该<code>SUCCEED</code>断言纯粹是记录性的，目前不会生成任何用户可见的输出。但是，我们可能会在未来将<code>SUCCEED</code>消息添加到<code>gtest</code>输出中。</p><p><code>FAIL()</code> ：生成致命失败并从当前函数返回。只能在返回 <code>void </code>的函数中使用。 有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvYWR2YW5jZWQuaHRtbCNhc3NlcnRpb24tcGxhY2VtZW50">断言放置。<i class="fa fa-external-link-alt"></i></span></p><p><code>ADD_FAILURE()</code>：生成非致命失败，允许当前函数继续运行。</p><p><code>ADD_FAILURE_AT(file_path, line_number)</code>：在指定的文件和行号处生成非致命失败</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(AdditionTest, HandlesVariousConditions)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> == result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SUCCEED</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FAIL</span>() &lt;&lt; <span class="string">&quot;Unexpected result for 1 + 1: &quot;</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">4</span>)  <span class="comment">// 使用 ADD_FAILURE来记录一个失败，但不中止测试</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ADD_FAILURE</span>() &lt;&lt; <span class="string">&quot;Expected 2 + 2 to be 4, but got &quot;</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">6</span>) <span class="comment">// 使用 ADD_FAILURE_AT() 来记录失败，指定文件和行号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ADD_FAILURE_AT</span>(__FILE__, __LINE__ - <span class="number">3</span>) &lt;&lt; <span class="string">&quot;Expected 3 + 3 to be 6, but got &quot;</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-8-匹配器"><a href="#1-3-5-8-匹配器" class="headerlink" title="1.3.5.8 匹配器"></a>1.3.5.8 匹配器</h4><p>以下断言使用匹配器对测试值进行更灵活、可读性更强的验证。可以使用<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcmVmZXJlbmNlL21hdGNoZXJzLmh0bWw=">内置<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvZ21vY2tfY29va19ib29rLmh0bWwjTmV3TWF0Y2hlcnM=">自定义的匹配器<i class="fa fa-external-link-alt"></i></span>来验证值是否与匹配器匹配。使用时需要链接<code>gmock</code>库。</p><p><code>EXPECT_THAT(value, matcher);</code><br><code>ASSERT_THAT(value, matcher);</code></p><p>value：要测试的值。<br>matcher：匹配器，可以是内置的匹配器（如 <code>Eq()</code>, <code>Le()</code>, <code>Gt()</code> 等），也可以是自定义的匹配器。</p><p>例如，以下代码验证val是否介于 5 和 10 之间，字符串str是否以”Hello”开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gmock/gmock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ::testing::AllOf;</span><br><span class="line"><span class="keyword">using</span> ::testing::Gt;</span><br><span class="line"><span class="keyword">using</span> ::testing::Lt;</span><br><span class="line"><span class="keyword">using</span> ::testing::StartsWith;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(MathTest, AssertThatExample)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="number">4</span>;</span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hi World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPECT_THAT</span>(val, <span class="built_in">AllOf</span>(<span class="built_in">Gt</span>(<span class="number">5</span>), <span class="built_in">Lt</span>(<span class="number">10</span>))); </span><br><span class="line"><span class="built_in">EXPECT_THAT</span>(str, <span class="built_in">StartsWith</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-5-9-Windows-HRESULT"><a href="#1-3-5-9-Windows-HRESULT" class="headerlink" title="1.3.5.9 Windows HRESULT"></a>1.3.5.9 Windows HRESULT</h4><p>以下断言测试<code>HRESULT</code>成功或失败。</p><table><thead><tr><th><strong>Fatal assertion</strong></th><th><strong>Nonfatal assertion</strong></th><th><strong>Verifies</strong></th></tr></thead><tbody><tr><td><code>ASSERT_HRESULT_SUCCEEDED(expression);</code></td><td><code>EXPECT_HRESULT_SUCCEEDED(expression);</code></td><td>expression is a success <code>HRESULT</code></td></tr><tr><td><code>ASSERT_HRESULT_FAILED(expression);</code></td><td><code>EXPECT_HRESULT_FAILED(expression);</code></td><td>expression is a failure <code>HRESULT</code></td></tr></tbody></table><h4 id="1-3-5-10-死亡断言"><a href="#1-3-5-10-死亡断言" class="headerlink" title="1.3.5.10 死亡断言"></a>1.3.5.10 死亡断言</h4><p><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3QvcmVmZXJlbmNlL2Fzc2VydGlvbnMuaHRtbCNkZWF0aA==">死亡断言<i class="fa fa-external-link-alt"></i></span>与后续进阶主题中死亡测试息息相关，因此将它们融为一节，将在后续进阶主题中讲解。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2dvb2dsZXRlc3Qv">GoogleTest User’s Guide<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：之前在工作中简单用过gtest，但当时项目比较赶时间，对测试并不是很重视。经常出现一个人改完代码后，模块之间出现bug情况，然后花很长时间排查bug。吸取教训后准备在新项目中引入gtest，花了两天时间学习了gtest文档，发现它功能还是蛮多的。准备整理一个gtest系列的专栏，也是检验自己学习成果。&lt;/p&gt;
&lt;h1 id=&quot;一、-gtest快速入门&quot;&gt;&lt;a href=&quot;#一、-gtest快速入门&quot; class=&quot;headerlink&quot; title=&quot;一、 gtest快速入门&quot;&gt;&lt;/a&gt;一、 gtest快速入门&lt;/h1&gt;&lt;h2 id=&quot;1-1-gtest是什么&quot;&gt;&lt;a href=&quot;#1-1-gtest是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 gtest是什么&quot;&gt;&lt;/a&gt;1.1 gtest是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gtest&lt;/code&gt; 是 Google Test 的简称，是一个由 Google 开发与维护的 C++ 测试框架。它提供了丰富的断言和测试工具，帮助开发者编写更好的 C++ 测试代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Google Test" scheme="https://blog.kjlcloud.com/categories/Google-Test/"/>
    
    
    <category term="gtest" scheme="https://blog.kjlcloud.com/tags/gtest/"/>
    
  </entry>
  
  <entry>
    <title>RocksDB是什么</title>
    <link href="https://blog.kjlcloud.com/2025/02/17/RocksDB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://blog.kjlcloud.com/2025/02/17/RocksDB%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2025-02-17T06:19:23.000Z</published>
    <updated>2025-02-17T06:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>RocksDB 是一个持久、内嵌型 K&#x2F;V存储引擎，键和值是任意大小的字节流（没有类型）。它支持<code>point lookup</code>和<code>range scan</code>，并提供不同类型的 ACID 保证。它是一个 C++ 库。RocksDB 借鉴了开源<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9sZXZlbGRiLw==">leveldb<i class="fa fa-external-link-alt"></i></span>项目的重要代码以及<span class="exturl" data-url="aHR0cDovL2hiYXNlLmFwYWNoZS5vcmcv">Apache HBase<i class="fa fa-external-link-alt"></i></span>的设计理念。初始代码是从开源 leveldb 1.5 fork而来的。它还以 Meta 在 RocksDB 之前开发的代码和理念为基础。</p><p>RocksDB 具有高度灵活的设置，可以根据不同的生产环境进行调优，包括 SSD、硬盘、ramfs 或远程存储。它支持多种压缩算法，并提供了良好的生产支持和调试工具。另一方面，RocksDB 也努力限制可调参数的数量，提供足够好的开箱即用性能，并在适用的地方使用一些自适应算法。</p><span id="more"></span><p>“内嵌” 意味着：</p><ul><li>该数据库没有独立进程，而是被集成进应用中，和应用共享内存等资源，从而避免了跨进程通信的开销。</li><li>它没有内置服务器，无法通过网络进行远程访问。</li><li>它不是分布式的，这意味着它不提供容错性、冗余或分片（sharding）机制。</li></ul><p>如有必要，需依赖于应用层来实现上述功能。</p><p>RocksDB 提供了很少的几个用于修改 kv 集合的函数底层接口：</p><ul><li><code>put(key, value)</code>：插入新的键值对或更新已有键值对</li><li><code>merge(key, value)</code>：将新值与给定键的原值进行合并</li><li><code>delete(key)</code>：从集合中删除键值对</li></ul><p>获取指定 key 所关联的 value：</p><ul><li><code>get(key)</code></li></ul><p>通过迭代器可以进行范围扫描 —— 找到特定的 key，并按顺序访问该 key 后续的键值对：</p><ul><li><code>iterator.seek(key_prefix); iterator.value(); iterator.next()</code></li></ul><h2 id="1-2-高度分层架构"><a href="#1-2-高度分层架构" class="headerlink" title="1.2 高度分层架构"></a>1.2 高度分层架构</h2><img src="LSM-tree.png"  ><p>RocksDB 的核心数据结构被称为<strong>日志结构合并树</strong> （LSM-Tree）。它是一种树形的数据结构，由多个层级组成，每层的数据按 key 有序。LSM-Tree 主要设计用来应对写入密集型工作负载，并于 1996 年在同名论文 <span class="exturl" data-url="aHR0cDovL3BhcGVyaHViLnMzLmFtYXpvbmF3cy5jb20vMThlOTFlYjRkYjIxMTRhMDZlYTYxNGYwMzg0ZjI3ODQucGRm">The Log-Structured Merge-Tree (LSM-Tree)<i class="fa fa-external-link-alt"></i></span> 被大家所知，其核心思想是充分利用了磁盘批量的顺序IO要远比随机IO性能好。</p><p>LSM-Tree 的最高层保存在内存中，包含最近写入的数据。其他较低层级的数据存储在磁盘上，层数编号从 0 到 N 。第 0 层 L0 存储从内存移动到磁盘上的数据，第 1 层及以下层级则存储更老的数据。<strong>通常某层的下个层级在数据量上会比该层大一个数量级，当某层数据量变得过大时，会合并到下一层</strong>。</p><h3 id="1-2-1-MemTable"><a href="#1-2-1-MemTable" class="headerlink" title="1.2.1 MemTable"></a>1.2.1 MemTable</h3><p><code>MemTable</code>是一个内存数据结构，在键值对写入磁盘之前，<code>Memtable</code> 会缓存住这些键值对。所有插入和更新操作都会过 MemTable。当然也包括删除操作：不过，在 RocksDB 中，并不会直接原地修改键值对，而是通过插入墓碑记录（tombstone ）来进行标记删除。</p><p><code>MemTable</code> 具有可配置的字节数限制。当一个 <code>MemTable</code> 变满时，就会切到一个新的<code> MemTable</code>。同时原 <code>MemTable</code> 变为不可修改状态，由后台线程把内容flush到一个SST文件，然后将该<code>MemTable</code>销毁。</p><p>例如现在向数据库中插入key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.put(&quot;chipmunk&quot;, &quot;1&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;2&quot;)</span><br><span class="line">db.put(&quot;raccoon&quot;, &quot;3&quot;)</span><br><span class="line">db.put(&quot;dog&quot;, &quot;4&quot;)</span><br></pre></td></tr></table></figure><img src="img1.png"  ><p>如上图所示，<code>MemTable</code> 中的键值对是按 key 有序排列的。尽管 <code>chipmunk</code> 是最先插入的，但由于 MemTable 是按 key 有序的，因此 <code>chipmunk</code> 排在 <code>cat</code> 之后。这种排序对于范围扫描是必须的。</p><p>影响memtable的最重要的几个选项是：</p><ul><li>memtable_factory: memtable对象的工厂。通过声明一个工厂对象，用户可以改变底层memtable的实现，并提供事先声明的选项。</li><li>write_buffer_size：一个memtable的大小</li><li>db_write_buffer_size：多个列族的memtable的大小总和。这可以用来管理memtable使用的总内存数。</li><li>write_buffer_manager：除了声明memtable的总大小，用户还可以提供他们自己的写缓冲区管理器，用来控制总体的memtable使用量。这个选项会覆盖db_write_buffer_size</li><li>max_write_buffer_number：内存中可以拥有刷盘到SST文件前的最大memtable数。</li></ul><p>默认的<code>MemTable</code>实现是基于<code>skiplist</code>。用户也可以使用其他<code>MemTable</code>实现，例如<code>HashLinkList</code>，<code>HashSkipList</code>或者<code>Vector</code>，以满足不同场景需求。</p><table><thead><tr><th>MEMTABLE类型</th><th>SKIPLIST</th><th>HASHSKIPLIST</th><th>HASHLINKLIST</th><th>VECTOR</th></tr></thead><tbody><tr><td>最佳使用场景</td><td>通用</td><td>带特殊key前缀的范围查询</td><td>带特殊key前缀，并且每个前缀都只有很小数量的行</td><td>大量随机写压力</td></tr><tr><td>索引类型</td><td>二分搜索</td><td>哈希+二分搜索</td><td>哈希+线性搜索</td><td>线性搜索</td></tr><tr><td>是否支持全量db有序扫描</td><td>天然支持</td><td>非常耗费资源（拷贝以及排序一生成一个临时视图</td><td>同HashSkipList</td><td>同HashSkipList</td></tr><tr><td>额外内存</td><td>平均（每个节点有多个指针</td><td>高（哈希桶+非空桶的skiplist元数据+每个节点多个指针</td><td>稍低（哈希桶+每个节点的指针</td><td>低（vector尾部预分配的内存）</td></tr><tr><td>Memtable落盘</td><td>快速，以及固定数量的额外内存</td><td>慢，并且大量临时内存使用</td><td>同HashSkipList</td><td>同HashSkipList</td></tr><tr><td>并发插入</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td></tr><tr><td>带Hint插入</td><td>支持（在没有并发插入的时候</td><td>不支持</td><td>不支持</td><td>不支持</td></tr></tbody></table><h3 id="1-2-2-WAL"><a href="#1-2-2-WAL" class="headerlink" title="1.2.2 WAL"></a>1.2.2 WAL</h3><p>当进程崩溃或机器异常时，其内存数据都会丢失。为了防止数据丢失，保证数据的持久化，RocksDB 会将所有更新写入到磁盘上的预写日志（WAL，write-ahead log）中。当发生异常时，RocksDB可以回放日志，恢复数据。</p><p>WAL 是一个只允许追加的文件，包含一组更改记录序列。每个记录包含键值对、记录类型（Put &#x2F; Merge &#x2F; Delete）和校验和（checksum，可选）。与 MemTable 不同，在 WAL 中，记录不按 key 有序，而是按照请求到来的顺序被追加到 WAL 中。</p><img src="img2.png"  ><h3 id="1-2-3-SSTable"><a href="#1-2-3-SSTable" class="headerlink" title="1.2.3 SSTable"></a>1.2.3 SSTable</h3><p>SSTable (Sorted String Table) 是一种持久化，有序且不可变的的键值存储结构。为了管理，RocksDB会将一个SST文件切分为若干个固定大小的block，每个block都有一个校验和用于检测数据是否损坏。每次从磁盘读取数据时，RocksDB 都会使用这些校验和进行校验。为了节省磁盘空间，RocksDB 提供了多种压缩算法，以平衡性能和压缩率。例如：Zlib、BZ2、Snappy（默认）、LZ4 或 ZSTD 算法。</p><p>尽管 SST 中的 kv 对是有序的，我们也并非总能进行二分查找，尤其是数据块在压缩过后，会使得查找很低效。RocksDB 使用索引来优化查询，索引存储在紧邻数据块之后。索引块会存储每个 block 中最后一个 key与该key在SST文件中偏移量的映射关系，并且索引块中 key 也是有序的，因此我们可以通过二分搜索快速找到某个 key。</p><img src="img3.png"  ><p>例如，我们在查找 <code>lynx</code>，索引会告诉我们这个键值对可能在 block 2，因为按照字典序，<code>lynx</code> 在 <code>chipmunk</code> 之后，但在 <code>raccoon</code> 之前。但其实 SST 文件中并没有 <code>lynx</code>，但我们仍然需要从磁盘加载 block 以进行搜索。RocksDB 支持启用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmxvb21fZmlsdGVy">布隆过滤器<i class="fa fa-external-link-alt"></i></span>，一种具有高效空间利用率的概率性数据结构，可以用来检测某个元素是否在集合中。布隆过滤器保存在 SST 文件中过滤器部分，以便能够快速确定某个 key 不在 SST 中，减少无效磁盘访问，极大提升了查询速度。</p><p><strong>Flush</strong></p><p>RocksDB 使用一个专门的后台线程定期地把不可变的<code>MemTable</code>从内存持久化到磁盘。一旦刷盘（flush）完成，不可变的<code>MemTable</code> 和相应的 <code>WAL</code> 就会被丢弃。RocksDB 开始写入新的<code> WAL</code>、<code>MemTable</code>。每次刷盘都会在 L0 层上产生一个新的 <code>SST 文件</code>。该文件一旦写入磁盘后，就不再会修改。</p><p>RocksDB 的 MemTable 的默认基于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2tpcF9saXN0">跳表<i class="fa fa-external-link-alt"></i></span>实现。该数据结构是一个具有额外采样层的链表，从而允许快速、有序地查询和插入数据。有序性使得 <code>MemTable</code> 刷盘时更高效，因为可以直接按顺序迭代键值对顺序写入磁盘。<strong>将随机写变为顺序写是 LSM-Tree 的核心设计之一</strong>。</p><img src="img4.png"  ><p><strong>Compaction</strong></p><p>当低level的SST文件数量或者大小达到阈值时，会进行Compaction。之所以进行Compaction是因为如果所有SST文件位于L0层会有空间放大（space amplifications）和读放大（read amplifications）的问题。</p><p>空间放大是存储数据所用实际空间与逻辑上数据大小的比值。假设一个数据库需要 2 MB 磁盘空间来存储逻辑上的 1 MB 大小的键值对是，那么它的空间放大率是 2。类似地，读放大用来衡量用户执行一次逻辑上的读操作，系统内所需进行的实际 IO 次数。</p><p>现在，让我们向数据库添加更多 key 并删除当中的一些 key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.delete(&quot;chipmunk&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;5&quot;)</span><br><span class="line">db.put(&quot;raccoon&quot;, &quot;6&quot;)</span><br><span class="line">db.put(&quot;zebra&quot;, &quot;7&quot;)</span><br><span class="line">// Flush triggers</span><br><span class="line">db.delete(&quot;raccoon&quot;)</span><br><span class="line">db.put(&quot;cat&quot;, &quot;8&quot;)</span><br><span class="line">db.put(&quot;zebra&quot;, &quot;9&quot;)</span><br><span class="line">db.put(&quot;duck&quot;, &quot;10&quot;)</span><br></pre></td></tr></table></figure><img src="img5.png"  ><p>随着我们的不断写入，<code>MemTable </code>不断被刷到磁盘，L0 上的<code> SST 文件</code>数量也在增长：</p><ul><li>删除或更新 key 所占用的空间永远不会被回收。例如，<code>cat</code> 这个 key 的三次更新记录分别在 SST1，SST2 和 SST3 中，而 <code>chipmunk</code> 在 SST1 中有一次更新记录，在 SST2 中有一次删除记录，这些无用的记录仍然占用额外磁盘空间。</li><li>随着 L0 上 SST 文件数量的增加，读取变得越来越慢。每次查找都要逐个检查所有 SST 文件。</li></ul><p>RocksDB 引入了Compaction 机制，可以降低空间放大和读放大，但代价是更高的写放大。Compaction 会将某层的 SST 文件同下一层的 SST 文件合并，并在这个过程中丢弃已删除和被覆盖的无效 key。Compaction 会在后台专用的线程池中运行，从而保证了 RocksDB 可以在做 Compaction 时能够正常处理用户的读写请求。</p><img src="img6.png"  ><p><code>Level Style Compaction</code>是 RocksDB 中的默认 Compaction 策略。使用<code> Level Style Compaction</code>，L0 层中的不同<code>SST 文件</code>键范围会重叠。L1 层及以下层会被组织为包含多个 <code>SST 文件</code>的序列，并保证同层级内的所有 SST 在键范围上没有交叠，且 <code>SST 文件</code>之间有序。Compaction 时，会选择性地将某层的<code> SST 文件</code>与下一层的 key 范围有重叠 <code>SST 文件</code>进行合并。</p><p>举例来说，如下图所示，在 L0 到 L1 层进行 Compaction 时，如果 L0 上的输入文件覆盖整个键范围，此时就需要对所有 L0 和 L1 层的文件进行 Compaction。</p><img src="img7.png"  ><p>而像是下面的这种 L1 和 L2 层的 Compaction，L1 层的输入文件只与 L2 层的两个 SST 文件重叠，因此，只需要对部分文件进行 Compaction 即可。</p><img src="img8.png"  ><p>当 L0 层上的 SST 文件数量达到一定阈值（默认为 4）时，将触发 Compaction。对于 L1 层及以下层级，当整个层级的 SST 文件总大小超过配置的目标大小时，会触发 Compaction 。当这种情况发生时，可能会触发 L1 到 L2 层的 Compaction。从而，从 L0 到 L1 层的 Compaction 可能会引发一直到最底层级联 Compaction。在 Compaction 完成之后，RocksDB 会更新元数据并从磁盘中删除已经被 Compcated 过的文件。</p><p><em>注：RocksDB 提供了不同 Compaction 策略来在空间、读放大和写放大之间进行权衡</em>。</p><h3 id="1-2-4-写路径"><a href="#1-2-4-写路径" class="headerlink" title="1.2.4 写路径"></a>1.2.4 写路径</h3><p>1，(可选) 当收到一个写请求时，会先把该条数据append方式写到WAL文件，用作故障恢复。</p><p>2，当写完WAL后，会把该条数据写入内存的MemTable，随即返回写成功。</p><p>3，当Memtable超过一定的大小后，会在内存里面冻结，变成不可变的MemTable，同时为了不阻塞写操作生成一个新MemTable。</p><p>4，有后台线程把内存里不可变的Memtable给flush到磁盘，生成L0 SST文件。</p><p>5，从 L0 到 L1 层的 Compaction 可能会引发一直到最底层级联 Compaction。在 Compaction 完成之后，RocksDB 会更新元数据并从磁盘中删除已经被 Compcated 过的SST文件。</p><h3 id="1-2-5-读路径"><a href="#1-2-5-读路径" class="headerlink" title="1.2.5 读路径"></a>1.2.5 读路径</h3><ol><li>检索 MemTable。</li><li>检索所有不可变 MemTable。</li><li>搜索最近 flush 过的 L0 层中的所有 SST 文件。</li><li>对于 L1 层及以下层级，首先找到可能包含该 key 的单个 SST 文件，然后在文件内进行搜索。</li></ol><p>搜索 SST 文件涉及：</p><ol><li>（可选）探测布隆过滤器。</li><li>查找 index 来找到可能包含这个 key 的 block 所在位置。</li><li>读取 block 文件并尝试在其中找到 key。</li></ol><h2 id="1-3-概述"><a href="#1-3-概述" class="headerlink" title="1.3 概述"></a>1.3 概述</h2><h3 id="列族-Column-Families"><a href="#列族-Column-Families" class="headerlink" title="列族(Column Families)"></a>列族(Column Families)</h3><p>RocksDB支持将一个数据库实例按照许多列族进行分片。所有数据库创建的时候都会有一个用”default”命名的列族，如果某个操作不指定列族，他将操作这个default列族。<strong>不同的列族共享WAL，独享SST和MemTable，所以Column Family起到了一定的逻辑和资源隔离的作用</strong>。</p><p>RocksDB在开启WAL的时候保证即使crash，列族的数据也能保持一致性。它还通过 API 支持跨列族的原子操作<code>WriteBatch</code>。</p><h3 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h3><p>API<code>Put</code>将单个键值插入数据库。如果数据库中已存在该键，则将覆盖先前的值。API<code>Write</code>允许在数据库中原子地插入、更新或删除多个键值。数据库保证一次<code>Write</code>调用中的所有键值都将插入数据库，或者一个键值也不会插入数据库。如果数据库中已存在任何这些键，则将覆盖先前的值。API<a href="https://github.com/facebook/rocksdb/wiki/DeleteRange"><code>DeleteRange</code></a>可用于删除某个范围内的所有键。</p><h3 id="Gets-Iterators-and-Snapshots"><a href="#Gets-Iterators-and-Snapshots" class="headerlink" title="Gets,Iterators and Snapshots"></a>Gets,Iterators and Snapshots</h3><p>键和值被视为纯字节流。键或值的大小没有限制。<code>Get</code>API 允许应用程序从数据库中提取单个键值。<code>MultiGet</code>API 允许应用程序从数据库检索一组键。使用<code>MultiGet</code>获取的多个键值对将保证在同一时间点的一致性。</p><p>数据库中的所有数据都按逻辑顺序排列。应用程序可以定义一种键比较方法，用来指定键的排序规则。<code>Iterator</code> API允许对数据库做range scan 。<code>Iterator</code>可以查找指定的键，然后可以从该点开始一次扫描一个键。。Iterator API还可以用于对数据库中的键进行反向迭代。<strong>在创建<code>Iterator</code>时会创建数据库的一致时间点视图，因此，通过Iterator返回的所有键都来自数据库的一致视图。</strong></p><p><a href="https://github.com/facebook/rocksdb/wiki/Snapshot"><code>Snapshot</code></a>API允许应用程序创建数据库的时间点视图。<code>Get</code>和<code>Iterator</code>API 可用于从指定的snapshot读取数据。<code>Snapshot</code>和 <code>Iterator</code>都提供了数据库的时间点视图，但它们的实现不同。<strong>短期&#x2F;前台扫描最好通过迭代器完成，而长时间&#x2F;后台扫描最好通过快照完成</strong>。 <code>Iterator</code>会对整个指定时间点的数据库相关文件保留一个引用计数，这些文件在iterator释放前，都不会被删除。另一方面，snapshot不会阻止文件删除；相反，compaction过程知道snapshot存在，并承诺永远不会删除在任何现有快照中可见的key。</p><p><code>Snapshot</code>在数据库重启后不会保留：reload RocksDB库会释放所有之前创建好的snapshot。</p><h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><p>RocksDB支持多操作事务。它支持乐观模式和悲观模式。参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvaG56ZW5nL3JvY2tzZGItZG9jLWNuL2Jsb2IvbWFzdGVyL2RvYw==">事务<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="前缀迭代器-Prefix-Iterators"><a href="#前缀迭代器-Prefix-Iterators" class="headerlink" title="前缀迭代器(Prefix Iterators)"></a>前缀迭代器(Prefix Iterators)</h3><p>大多数 LSM-tree 引擎无法支持高效的range scan  API，因为它需要查看多个数据文件。但是，大多数应用程序不会对数据库中的键进行纯随机范围扫描；相反，应用程序通常只扫描指定前缀的键。RocksDB 利用了这一点。应用程序可以配置<code>Options.prefix_extractor</code>以启用基于键前缀的过滤。启用后，会将前缀的hash添加到布隆过滤器（Bloom Filter）中。指定了键前缀的<code>Iterator</code>(在ReadOptions中)将使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Sb2Nrc0RCLUJsb29tLUZpbHRlcg==">布隆过滤器<i class="fa fa-external-link-alt"></i></span>来避免查找不包含指定键前缀的数据文件。参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9QcmVmaXgtU2Vlaw==">前缀查找<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="持久性-Persistence"><a href="#持久性-Persistence" class="headerlink" title="持久性(Persistence)"></a>持久性(Persistence)</h3><p>RocksDB 有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Xcml0ZS1BaGVhZC1Mb2ctKFdBTCk=">预写日志 (WAL)<i class="fa fa-external-link-alt"></i></span>。所有写入操作（<code>Put</code>、<code>Delete</code>和<code>Merge</code>）都存储在名为 memtable 的内存缓冲区中，也可以选择性地写入 WAL。重新启动时，它会重新处理日志中记录的所有事务。</p><p>WAL 可以配置为存储在与 <strong>SST 文件</strong> 不同的目录中。这对于您可能希望将所有数据文件存储在非持久性快速存储中的情况是必要的。同时，您可以通过将所有事务日志放在较慢但持久的存储上来确保不会丢失数据。</p><p>每次<code>Put</code>都有一个标志位，通过WriteOptions来设置，允许指定这个Put操作是不是需要写事务日志。WriteOptions同时允许指定在<code>Put</code>返回成功前，是不是需要调用<code>fsync</code>。</p><p>在内部，RocksDB 使用批量提交机制将事务批量放入日志中，以便它可以使用单个<code>fsync</code>调用提交多个事务。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>RocksDB 使用校验和来检测存储中的损坏。每个 <strong>SST 文件块</strong>（通常大小在 <strong>4KB 到 128KB</strong> 之间）都会有一个单独的校验和。块一旦写入存储，就不再做修改。RocksDB 还维护完整的文件校验和（请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9GdWxsLUZpbGUtQ2hlY2tzdW0tYW5kLUNoZWNrc3VtLUhhbmRvZmY=">完整文件校验和和校验和切换<i class="fa fa-external-link-alt"></i></span>）以及可选的<span class="exturl" data-url="aHR0cDovL3JvY2tzZGIub3JnL2Jsb2cvMjAyMi8wNy8xOC9wZXIta2V5LXZhbHVlLWNoZWNrc3VtLmh0bWw=">每个键值校验和<i class="fa fa-external-link-alt"></i></span>。</p><p>RocksDB 动态检测并利用 CPU 校验和卸载支持。</p><h3 id="Multi-Threaded-Compactions"><a href="#Multi-Threaded-Compactions" class="headerlink" title="Multi-Threaded Compactions"></a>Multi-Threaded Compactions</h3><p>在存在持续写入的情况下，需要进行compactions以提高空间效率、读取（查询）效率和及时删除数据。Compaction会删除已删除或覆盖的键值，并重新组织数据以提高查询效率。如果配置的话，Compactions 可能会在多个线程中同时进行。</p><p>整个数据库存储在一组<strong>SST文件</strong>中。当<strong>memtable</strong>写满时，其内容将写入 LSM-tree的 Level-0 (L0) 文件中。RocksDB 在将<strong>memtable</strong> 刷新到 L0 文件中时，会删除重复和覆盖的键。在compaction中，一些文件会定期读入并合并以形成更大的文件，通常会进入下一个 LSM 级别（例如 L1，直到 Lmax）。</p><p>LSM 数据库的整体写入吞吐量直接取决于compaction发生的速度，尤其是当数据存储在 SSD 或 RAM 等快速存储中时。RocksDB 可以配置为从多个线程发出并发compaction请求。据观察，当数据库位于 SSD 上时，与单线程compaction相比，多线程compaction可以将持续写入速率提高10倍。</p><h3 id="Compaction-Styles"><a href="#Compaction-Styles" class="headerlink" title="Compaction Styles"></a><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wYWN0aW9u">Compaction Styles<i class="fa fa-external-link-alt"></i></span></h3><p><code>Level Style Compaction</code>和<code>Universal Style Compaction</code>都将数据存储在数据库中固定数量的逻辑级别中。较新的数据存储在级别 0 (L0) 中，较旧的数据存储在编号较高的级别中，最高可达 Lmax。<strong>L0中的文件可能会有重叠的键，但其他级别的文件通常会在每个级别上单独排序</strong>。</p><p><code>Level Style Compaction</code>（默认）通常通过最小化每个Compaction步骤中涉及的文件来优化磁盘占用空间与逻辑数据库大小（空间放大）：将 Ln 中的一个文件与 Ln+1 中的所有重叠文件合并，并用 Ln+1 中的新文件替换它们。</p><p><code>Universal Style Compaction</code>通常通过一次合并多个文件和级别来优化写入磁盘的总字节数与逻辑数据库大小（写入放大），从而需要更多临时空间。与<code>Level Style Compaction</code>相比，<code>Universal Style Compaction</code>通常会导致写放大更低，但空间和读放大更高。</p><p><code>FIFO Style Compaction</code>会删除过时的旧文件，并可用于类似缓存的数据。在FIFO compaction中，所有文件都在L0级。当数据的总大小超过配置的大小（CompactionOptionsFIFO::max_table_files_size）时，我们删除最旧的<code>SST文件</code>。</p><p>我们还允许开发人员开发和测试自定义compaction策略。为此，RocksDB有适当的钩子来关闭内建的compaction算法，然后使用其他API来允许应用使用他们自己的compaction算法。<code>Options.disable_auto_compaction</code>如果设置，则关闭内建的compaction算法。<code>GetLiveFilesMetaData</code> API允许外部组件查看数据库中的每个数据文件，并决定要merge和compaction哪些数据文件。调用<code>CompactFiles</code>以compaction您想要的文件。该<code>DeleteFile</code>API 允许应用程序删除被视为过时的数据文件。</p><h3 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h3><p>清单日志文件用于记录数据库所有状态变化。<code>compaction</code>过程中会在数据库中添加新文件和删除原有文件，并通过将这些操作记录在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9NQU5JRkVTVA==">MANIFEST<i class="fa fa-external-link-alt"></i></span>中来使这些操作持久化。</p><h3 id="Avoiding-Stalls"><a href="#Avoiding-Stalls" class="headerlink" title="Avoiding Stalls"></a>Avoiding Stalls</h3><p>后台<code>compaction</code>线程还用于将<code>memable</code>的内容flush到存储上的文件中。如果所有后台<code>compaction</code>线程都长时间忙于compaction，突发性的写操作可能很快填满<code>memable</code>，从而阻塞新的写入。可以通过配置 RocksDB 来保留一小组线程，专门用于将<code>memable</code> flush到存储，从而避免这种情况。</p><h3 id="Compaction-Filter"><a href="#Compaction-Filter" class="headerlink" title="Compaction Filter"></a>Compaction Filter</h3><p>某些应用程序可能希望在<code>compaction</code>时处理键，例如根据 TTL 删除过期的键、在后台删除一定范围的键、更新现有键的值。这可以通过应用程序定义的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wYWN0aW9uLUZpbHRlcg==">Compaction Filter<i class="fa fa-external-link-alt"></i></span>来完成。</p><h3 id="只读模式"><a href="#只读模式" class="headerlink" title="只读模式"></a>只读模式</h3><p>数据库可以以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9SZWFkLW9ubHktYW5kLVNlY29uZGFyeS1pbnN0YW5jZXM=">只读模式<i class="fa fa-external-link-alt"></i></span>打开，在该模式下，数据库保证应用程序无法修改任何数据。这大大提高了读取性能，因为避免了一些锁机制。</p><h3 id="数据库调试日志"><a href="#数据库调试日志" class="headerlink" title="数据库调试日志"></a>数据库调试日志</h3><p>默认情况下，RocksDB将详细日志写入名为<code>LOG*</code>的文件。这些日志主要用于调试和分析正在运行的系统。用户可以选择不同的日志级别（参见 <code>DBOptions.info_log_level</code>）。日志文件可以配置为按照指定的周期进行滚动。日志接口是可插拔的，用户可以选择使用不同的记录器，参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Mb2dnZXI=">记录器<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="Data-Compression"><a href="#Data-Compression" class="headerlink" title="Data Compression"></a>Data Compression</h3><p>RocksDB 支持 lz4、zstd、snappy、zlib 和 lz4_hc压缩，以及 Windows 下的 xpress。RocksDB可以为不同level的<code>SST文件</code>配置不同的压缩算法。请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Db21wcmVzc2lvbg==">压缩<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="全量备份与复制"><a href="#全量备份与复制" class="headerlink" title="全量备份与复制"></a>全量备份与复制</h3><p>RocksDB 提供了<code>BackupEngine</code> API进行备份，可参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9Ib3ctdG8tYmFja3VwLVJvY2tzREI=">How to backup RocksDB<i class="fa fa-external-link-alt"></i></span>。</p><p>RocksDB 本身不是复制的，但它提供了一些辅助函数，使用户能够在 RocksDB 之上实现自己的复制系统，可参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9SZXBsaWNhdGlvbi1IZWxwZXJz">Replication Helpers<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="支持同一个进程打开多个数据库"><a href="#支持同一个进程打开多个数据库" class="headerlink" title="支持同一个进程打开多个数据库"></a>支持同一个进程打开多个数据库</h3><p>RocksDB 的一个常见用法是应用程序将数据集划分为逻辑分区或分片。此技术有利于应用程序负载均衡以及快速故障恢复。这意味着单个进程应能同时操作多个RocksDB数据库。这是通过一个名为<code>Env</code>的对象完成的。除此之外，线程池与<code>Env</code>相关联，如果想在多个数据库实例之间共享一个公共线程池（用于后台compaction），那么它应该使用同一个<code>Env</code>对象来打开这些数据库。</p><p>类似地，多个数据库实例可以共享相同的块缓存或速率限制器。</p><h3 id="Block-Cache"><a href="#Block-Cache" class="headerlink" title="Block Cache"></a>Block Cache</h3><p>RocksDB对block使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9CbG9jay1DYWNoZQ==">LRU<i class="fa fa-external-link-alt"></i></span>做读缓存。 block cache分为两个单独的cache：第一个缓存未压缩的block，第二个缓存在内存中压缩的block。如果配置了压缩block缓存，用户可能希望启用direct I&#x2F;O ，以防止在操作系统的页缓存中缓存相同的数据。</p><h3 id="Table-Cache"><a href="#Table-Cache" class="headerlink" title="Table Cache"></a>Table Cache</h3><p>Table Cache是缓存打开的文件描述符的结构。这些文件描述符用于<strong>sstfiles</strong>。应用程序可以指定Table Cache的最大大小，或将 RocksDB 配置为始终保持所有文件打开状态，以提高性能。</p><h3 id="I-O-Control"><a href="#I-O-Control" class="headerlink" title="I&#x2F;O Control"></a>I&#x2F;O Control</h3><p>RocksDB允许用户以不同的方式配置从<code>SST文件</code>或到<code>SST文件</code>的I&#x2F;O。用户可以启用direct I&#x2F;O，以便RocksDB完全控制I&#x2F;O和缓存。另一种方法是利用一些选项允许用户提示应该如何执行I&#x2F;O。他们可以建议RocksDB在读取文件时调用 <code>fadvise</code>，在正在追加数据的文件中定期调用 range sync。有关更多详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9JTw==">IO<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvaG56ZW5nL3JvY2tzZGItZG9jLWNuL2Jsb2IvbWFzdGVyL2RvYw==">https://github.com/johnzeng/rocksdb-doc-cn/blob/master/doc<i class="fa fa-external-link-alt"></i></span>)</p><h3 id="StackableDB"><a href="#StackableDB" class="headerlink" title="StackableDB"></a>StackableDB</h3><p>RocksDB 具有内置的包装器机制，可以在数据库核心代码之上添加额外的功能，这些功能通过<code>StackableDB</code>API封装。例如，TTL功能是由<code>StackableDB</code>接口实现的，并不是RocksDB核心API的一部分，这种方法使代码保持模块化和干净。</p><h3 id="Merge-Operator"><a href="#Merge-Operator" class="headerlink" title="Merge Operator"></a>Merge Operator</h3><p>RocksDB 原生支持三种类型的记录，即<code>Put</code>、<code>Delete</code>、<code>Merge</code>记录。当compaction过程遇到<code>Merge</code>时，它会调用应用程序指定的方法，称为合并运算符。合并可以将多个 Put 和 Merge 记录合并为一条记录。这个强大的功能允许通常执行读取-修改-写入的应用程序完全避免读取。它允许应用程序将操作意图记录为<code>Merge</code>记录，而 RocksDB compaction过程会将该意图延迟应用于原始值。此功能在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9NZXJnZS1PcGVyYXRvcg==">合并运算符中有详细描述<i class="fa fa-external-link-alt"></i></span></p><h3 id="DB-ID"><a href="#DB-ID" class="headerlink" title="DB ID"></a>DB ID</h3><p>数据库创建时创建的全局唯一ID，默认存储在 DB 文件夹中的 <code>IDENTITY</code>文件中。可选地，它只存储在<code>MANIFEST</code>文件中。建议存储在 <code>MANIFEST </code>文件中。</p><h2 id="1-4-工具"><a href="#1-4-工具" class="headerlink" title="1.4 工具"></a>1.4 工具</h2><p>有许多有趣的工具用于支持生产环境中的数据库。<code>sst_dump</code>程序转储<code>sst文件</code>中的所有键值，以及其他信息。<code>ldb</code>工具可以put, get，s can数据库的内容。<code>ldb</code>还可以转储<code>MANIFEST</code>的内容，它还可以用来修改数据库配置的层级数。有关详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraS9BZG1pbmlzdHJhdGlvbi1hbmQtRGF0YS1BY2Nlc3MtVG9vbA==">管理和数据访问工具<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="1-5-LevelDB-所没有的特性"><a href="#1-5-LevelDB-所没有的特性" class="headerlink" title="1.5 LevelDB 所没有的特性"></a>1.5 LevelDB 所没有的特性</h2><p><strong>Performance</strong>：</p><ul><li>Multithread compaction</li><li>Multithread memtable inserts</li><li>Reduced DB mutex holding</li><li>Optimized level-based compaction style and universal compaction style</li><li>Prefix bloom filter</li><li>Memtable bloom filter</li><li>Single bloom filter covering the whole SST file</li><li>Write lock optimization</li><li>Improved Iter::Prev() performance</li><li>Fewer comparator calls during SkipList searches</li><li>Allocate memtable memory using huge page.</li></ul><p><strong>Features</strong>：</p><ul><li>Column Families</li><li>Transactions and WriteBatchWithIndex</li><li>Backup and Checkpoints</li><li>Merge Operators</li><li>Compaction Filters</li><li>RocksDB Java</li><li>Manual Compactions Run in Parallel with Automatic Compactions</li><li>Persistent Cache</li><li>Bulk loading</li><li>Forward Iterators&#x2F; Tailing iterator</li><li>Single delete</li><li>Delete files in range</li><li>Pin iterator key&#x2F;value</li></ul><p><strong>Alternative Data Structures And Formats</strong>：</p><ul><li>Plain Table format for memory-only use cases</li><li>Vector-based and hash-based memtable format</li><li>Clock-based cache (coming soon)</li><li>Pluggable information log</li><li>Annotate transaction log write with blob (for replication)</li></ul><p><strong>Tunability</strong>：</p><ul><li>Rate limiting</li><li>Tunable Slowdown and Stop threshold</li><li>Option to keep all files open</li><li>Option to keep all index and bloom filter blocks in block cache</li><li>Multiple WAL recovery modes</li><li>Fadvise hints for readahead and to avoid caching in OS page cache</li><li>Option to pin indexes and bloom filters of L0 files in memory</li><li>More Compression Types: zlib, lz4, zstd</li><li>Compression Dictionary</li><li>Checksum Type: xxhash</li><li>Different level size multiplier and compression type for each level.</li></ul><p><strong>Manageability</strong>：</p><ul><li>Statistics</li><li>Thread-local profiling</li><li>More commands in command-line tools</li><li>User-defined table properties</li><li>Event listeners</li><li>More DB Properties</li><li>Dynamic option changes</li><li>Get options from a string or map</li><li>Persistent options to option files</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JvY2tzZGIvd2lraQ==">RocksDB Wiki<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucXRtdW5pYW8uY29tLzIwMjMvMDYvMDUvaG93LXJvY2tzZGItd29ya3M=">RocksDB运行原理<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDQxODM1">深入理解什么是LSM-Tree<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 简介&quot;&gt;&lt;/a&gt;1.1 简介&lt;/h2&gt;&lt;p&gt;RocksDB 是一个持久、内嵌型 K&amp;#x2F;V存储引擎，键和值是任意大小的字节流（没有类型）。它支持&lt;code&gt;point lookup&lt;/code&gt;和&lt;code&gt;range scan&lt;/code&gt;，并提供不同类型的 ACID 保证。它是一个 C++ 库。RocksDB 借鉴了开源&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9sZXZlbGRiLw==&quot;&gt;leveldb&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;项目的重要代码以及&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2hiYXNlLmFwYWNoZS5vcmcv&quot;&gt;Apache HBase&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;的设计理念。初始代码是从开源 leveldb 1.5 fork而来的。它还以 Meta 在 RocksDB 之前开发的代码和理念为基础。&lt;/p&gt;
&lt;p&gt;RocksDB 具有高度灵活的设置，可以根据不同的生产环境进行调优，包括 SSD、硬盘、ramfs 或远程存储。它支持多种压缩算法，并提供了良好的生产支持和调试工具。另一方面，RocksDB 也努力限制可调参数的数量，提供足够好的开箱即用性能，并在适用的地方使用一些自适应算法。&lt;/p&gt;</summary>
    
    
    
    <category term="RocksDB" scheme="https://blog.kjlcloud.com/categories/RocksDB/"/>
    
    
    <category term="RocksDB" scheme="https://blog.kjlcloud.com/tags/RocksDB/"/>
    
    <category term="LSM-Tree" scheme="https://blog.kjlcloud.com/tags/LSM-Tree/"/>
    
  </entry>
  
  <entry>
    <title>C++11 =default与=delete</title>
    <link href="https://blog.kjlcloud.com/2025/01/05/C-default%E4%B8%8E-delete/"/>
    <id>https://blog.kjlcloud.com/2025/01/05/C-default%E4%B8%8E-delete/</id>
    <published>2025-01-05T04:04:43.000Z</published>
    <updated>2025-03-04T08:58:08.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-缺乏控制的特殊成员函数"><a href="#1-缺乏控制的特殊成员函数" class="headerlink" title="1. 缺乏控制的特殊成员函数"></a>1. 缺乏控制的特殊成员函数</h1><p>&emsp;C++中，如果没有显式定义某些特殊成员函数时，编译器会自动为类生成这些成员函数。例如：默认构造函数、析构函数、拷贝构造函数、赋值运算符重载函数等，这个特性让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point p1; <span class="comment">// 调用编译器自动生成的构造函数</span></span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用编译器自动生成的拷贝构造函数</span></span><br><span class="line">p2 = p1; <span class="comment">//  调用编译器自动生成的赋值运算符重载函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; <span class="comment">// 调用编译器自动生成的析构函数</span></span><br></pre></td></tr></table></figure><p>当显式定义这些成员函数时，编译器不会自动生成，但这会在某些场景下带来问题。例如：我们想在定义Point对象时对_x、_y初始化，于是我们自己写一个构造函数，但代码中如有使用之前编译器生成默认构造函数则会编译失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point p1; <span class="comment">// 错误，显式定义了形参数量为2的构造函数，编译器不会生成默认构造函数</span></span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果想编写一个禁止复制操作的类，在C++11之前只能将拷贝构造函数与赋值运算符重载函数声明为<br><code>private</code>并且不实现该函数。但是这种方式并不完美。如果某个类或函数是这个类的友元，那么可以访问该类私有的拷贝构造（赋值）函数，但是我们并没有实现这个函数，程序最后会在链接阶段报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p);</span><br><span class="line"></span><br><span class="line">Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在C++11之前程序员不能显式控制这些特殊成员函数的生成，而编译器对是否生成这些特殊成员函数有一套比较复杂的规则，所以造成了很大的不便</strong>。</p><h1 id="2-显式默认和显式删除"><a href="#2-显式默认和显式删除" class="headerlink" title="2. 显式默认和显式删除"></a>2. 显式默认和显式删除</h1><p>&emsp;<strong>C++11</strong>标准提供了一种方法告诉编译器是否生成或删除对应的默认成员函数。，我们将这种方法叫作显式默认和显式删除。显式默认和显式删除的语法非常简单，只需要在声明函数的尾部添加<code>=default</code>和<code>=delete</code>。</p><p>说明： <code>=default</code>只能适用于类的特殊成员函数，<code>=delete</code>可以适用于任何函数。因为类的特殊成员函数是明确做某事的，所以编译器能够帮你实现。但是对于普通函数来说，编译器不知道你这个函数要干嘛，所以不能够帮你实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>() = <span class="keyword">default</span>; <span class="comment">// 生成默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) = <span class="keyword">delete</span>; <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;p) = <span class="keyword">delete</span>; <span class="comment">// 删除赋值运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point p1; <span class="comment">// 正确，调用编译器生成的默认构造函数</span></span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 正确，调用Point(int x, int y)构造函数</span></span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，拷贝构造函数已被删除</span></span><br><span class="line">p1 = p2; <span class="comment">// 错误，赋值运算符重载函数已被删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-特殊类设计"><a href="#3-特殊类设计" class="headerlink" title="3. 特殊类设计"></a>3. 特殊类设计</h1><h2 id="3-1-禁止类对象在堆上分配"><a href="#3-1-禁止类对象在堆上分配" class="headerlink" title="3.1 禁止类对象在堆上分配"></a>3.1 禁止类对象在堆上分配</h2><p>如果想一个类的使用者只能通过局部变量、静态变量或者全局变量的方式创建对象，而不允许使用<code>new</code>运算符或<code>new [ ]</code>运算符在堆上开辟空间，可以将下列成员函数显式删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-限制类对象在堆上分配"><a href="#3-2-限制类对象在堆上分配" class="headerlink" title="3.2 限制类对象在堆上分配"></a>3.2 限制类对象在堆上分配</h2><p>如果想一个类的使用者只能通过<code>new</code>运算符或<code>new [ ]</code>运算符在堆上开辟空间，可以将类的析构函数显式删除，但通过<code>new</code>运算符或<code>new [ ]</code>运算符创建的对象也不能调用<code>delete</code>或<code> delete[]</code>销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Point</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-缺乏控制的特殊成员函数&quot;&gt;&lt;a href=&quot;#1-缺乏控制的特殊成员函数&quot; class=&quot;headerlink&quot; title=&quot;1. 缺乏控制的特殊成员函数&quot;&gt;&lt;/a&gt;1. 缺乏控制的特殊成员函数&lt;/h1&gt;&lt;p&gt;&amp;emsp;C++中，如果没有显式定义某些特殊成员函数时，编译器会自动为类生成这些成员函数。例如：默认构造函数、析构函数、拷贝构造函数、赋值运算符重载函数等，这个特性让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 对sizeof返回值类型不了解带来的陷阱</title>
    <link href="https://blog.kjlcloud.com/2024/12/26/C-C-%E5%AF%B9sizeof%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%BA%86%E8%A7%A3%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>https://blog.kjlcloud.com/2024/12/26/C-C-%E5%AF%B9sizeof%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%BA%86%E8%A7%A3%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%B7%E9%98%B1/</id>
    <published>2024-12-26T09:25:19.000Z</published>
    <updated>2025-03-04T03:51:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;对C&#x2F;C++程序员来说，<code>sizeof</code>可以说再熟悉不过，<code>sizeof</code>是一个 C&#x2F;C++中的<strong>运算符</strong>，在<strong>编译阶段</strong>计算并返回一个对象或数据类型所占用的内存大小（单位: 字节）。<code>sizeof</code>看起来简单，但是对它不了解很容易在代码中留下陷阱。比如：当传入一个表达式给<code>sizeof</code>时，它只会返回表达式计算结果的类型大小，但它不会对表达式求值。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2024</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(i++)=&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(i++) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// i的值仍然是2024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sizeof</code>带来的陷阱还有许多，在此不做探讨，本文只举例最让人忽视的一种情况，下面这个程序的作者希望输出数组中的所有元素，运行后他却没有得到他想要的结果，程序没有输出任何内容，这是为什么呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">17</span>,<span class="number">204</span>,<span class="number">99</span>,<span class="number">16</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">-1</span>;d &lt;= (TOTAL_ELEMENTS<span class="number">-2</span>);d++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">array</span>[d+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是<code>sizeof</code>的返回值类型是<code>size_t</code>，是一个<strong>无符号的整数</strong>。d为int类型，使用d与无符号整数比较时，d会被隐式类型转换为无符号整数。 这样就导致-1被转换成一个非常大的值，以至于for循环不满足条件。<span class="exturl" data-url="aHR0cDovL3d3dy5nb3dyaWt1bWFyLmNvbS9jL2luZGV4Lmh0bWw=">点击此处<i class="fa fa-external-link-alt"></i></span>可以访问该程序作者的博客，他还有许多这种类似的陷阱程序。</p><p>结论：一定要切记<code>sizeof</code>返回的是无符号整数类型，当与有符号整数或其他类型进行比较，且这个有符号数的值可能为负数时，会带来不可预料的后果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;对C&amp;#x2F;C++程序员来说，&lt;code&gt;sizeof&lt;/code&gt;可以说再熟悉不过，&lt;code&gt;sizeof&lt;/code&gt;是一个 C&amp;#x2F;C++中的&lt;strong&gt;运算符&lt;/strong&gt;，在&lt;strong&gt;编译阶段&lt;/strong&gt;计算并返回一个对象或数据类型所占用的内存大小（单位: 字节）。&lt;code&gt;sizeof&lt;/code&gt;看起来简单，但是对它不了解很容易在代码中留下陷阱。比如：当传入一个表达式给&lt;code&gt;sizeof&lt;/code&gt;时，它只会返回表达式计算结果的类型大小，但它不会对表达式求值。&lt;/p&gt;</summary>
    
    
    
    <category term="编程陷阱" scheme="https://blog.kjlcloud.com/categories/%E7%BC%96%E7%A8%8B%E9%99%B7%E9%98%B1/"/>
    
    
    <category term="sizeof" scheme="https://blog.kjlcloud.com/tags/sizeof/"/>
    
  </entry>
  
  <entry>
    <title>可能是最好的RPC中文文档</title>
    <link href="https://blog.kjlcloud.com/2024/11/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84RPC%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    <id>https://blog.kjlcloud.com/2024/11/29/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84RPC%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</id>
    <published>2024-11-29T09:28:14.000Z</published>
    <updated>2025-03-06T06:53:23.143Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>阅读本文需要对TCP&#x2F;IP协议簇和linux系统有一定了解。</strong></p><h1 id="一、RPC介绍"><a href="#一、RPC介绍" class="headerlink" title="一、RPC介绍"></a>一、RPC介绍</h1><h2 id="1-1-RPC是什么"><a href="#1-1-RPC是什么" class="headerlink" title="1.1 RPC是什么"></a>1.1 RPC是什么</h2><p><strong>RPC (Remote Procedure Call)</strong>：一个计算机通信协议，基于扩展常规或本地过程调用的概念。因此被调用过程不必与调用过程存在于同一地址空间中。这两个进程可能位于同一系统上，也可能位于不同的系统上，并通过网络连接它们。程序员就像调用本地程序一样，无需额外地为这个交互编程（无需关注细节）。<br><img src="https://i-blog.csdnimg.cn/direct/4ee4133b8b3849c99e238b9d86986592.jpeg#pic_center" alt="在这里插入图片描述"><br> 上图表示两个联网系统之间 RPC 调用流程。客户端进行过程调用，向服务器发送请求并阻塞等待，直到收到答复或请求超时。当请求到达时，服务器执行对应的请求过程，并将执行结果发送给客户端。客户端收到应答消息后被唤醒继续运行。</p><span id="more"></span><h2 id="1-2-TI-RPC-相关说明"><a href="#1-2-TI-RPC-相关说明" class="headerlink" title="1.2 TI-RPC 相关说明"></a>1.2 TI-RPC 相关说明</h2><p>TI-RPC : Transport-independent RPC. </p><h3 id="1-2-1-参数传递"><a href="#1-2-1-参数传递" class="headerlink" title="1.2.1 参数传递"></a>1.2.1 参数传递</h3><p>TI-RPC允许一个参数从客户端传递到服务器。如果需要多个参数，则可以将这些参数组合成一个结构体，作为一个元素。从服务器传递给客户端的信息作为函数的返回值。</p><h3 id="1-2-2-传输协议"><a href="#1-2-2-传输协议" class="headerlink" title="1.2.2 传输协议"></a>1.2.2 传输协议</h3><p>传输协议指定了客户端和服务器之间如何传输call message 和 reply message。TS-RPC 使用 TCP 和 UDP 作为传输协议，但当前版本的 TI-RPC 是独立于传输的，因此它可以与任何传输协议一起使用。</p><p>您可以编写程序在特定传输类型上运行，或者在由系统选择或用户选择的传输上运行。两种网络选择机制是 <code>/etc/netconfig</code>数据库文件和环境变量 NETPATH。这些机制可以精细控制使用哪种网络传输类型 - 用户可以指定首选传输，应用程序将在可以的情况下使用该传输。如果指定的传输不合适，应用程序会自动尝试具有正确特征的其他传输。</p><p><code>/etc/netconfig</code>列出了主机可用的传输方式并按类型标识它们。如果未设置 NETPATH，则系统默认使用<code>/etc/netconfig</code>中指定的所有可见传输方式，按照它们在该文件中出现的顺序。</p><h3 id="1-2-3-调用语义"><a href="#1-2-3-调用语义" class="headerlink" title="1.2.3 调用语义"></a>1.2.3 调用语义</h3><p>调用语义定义了客户端可以对远程过程的执行做出何种假设；特别是，该过程执行了多少次。这些语义在处理错误情况时非常重要。三种选择分是<strong>恰好一次</strong>、 <strong>最多一次</strong>和<strong>至少一次</strong>。ONC+ 提供 <strong>至少一次</strong>语义。远程调用的过程是 <strong>幂等的</strong>。它们每次被调用时都应该返回相同的结果，即使经过多次迭代也是如此。</p><h3 id="1-2-4-数据表示"><a href="#1-2-4-数据表示" class="headerlink" title="1.2.4 数据表示"></a>1.2.4 数据表示</h3><p>数据表示描述了在进程之间传递参数和结果时所使用的格式。为了在各种系统架构上运行，RPC 需要标准的数据表示。TI-RPC 使用外部数据表示 (XDR)。XDR 是一种独立于系统的数据描述和编码协议。使用 XDR，RPC 可以处理任意数据结构，不必在意不同主机的字节顺序或结构布局约定如何。</p><h2 id="1-3-远程调用标识"><a href="#1-3-远程调用标识" class="headerlink" title="1.3 远程调用标识"></a>1.3 远程调用标识</h2><p>一个远程调用由以下三元组唯一标识：</p><ul><li>Program number ：标识一个远程程序</li><li>Procedure number：标识一个调用过程，即调用哪个函数</li><li>Version number：一个调用过程可以有多个版本</li></ul><p>说明：程序名到Program numbe的映射关系可参考 <code>/etc/rpc</code>文件</p><h2 id="1-4-动态端口"><a href="#1-4-动态端口" class="headerlink" title="1.4 动态端口"></a>1.4 动态端口</h2><p>RPC服务监听的端口并不固定，客户端如果想要访问这些服务要先向<code>rpcbind</code>守护进程查询对应服务监听的端口。<code>rpcbind</code>监听TCP&#x2F;UDP 111端口。<code>rpcbind</code>是唯一具有已知端口的RPC 服务。</p><p>RPC服务（程序）启动后会向<code>rpcbind</code>注册其自身信息，包括Program number、Version、Protocol type、Port。当客户端来查询时将这些信息回复给客户端。</p><p><img src="https://i-blog.csdnimg.cn/direct/0e00b09c08554dd78fcaf19eaffdac2b.jpeg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> PMAP_PORT = <span class="number">111</span>;       <span class="comment">/* portmapper port number */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * A mapping of (program, version, protocol) to port number</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pmap</span> &#123;</span></span><br><span class="line"> <span class="type">rpcprog_t</span> prog;</span><br><span class="line"> <span class="type">rpcvers_t</span> vers;</span><br><span class="line"> <span class="type">rpcprot_t</span> prot;</span><br><span class="line"> <span class="type">rpcport_t</span> port;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Supported values for the &quot;prot&quot; field</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">const</span> IPPROTO_TCP = <span class="number">6</span>; <span class="comment">/* protocol number for TCP/IP */</span></span><br><span class="line"> <span class="type">const</span> IPPROTO_UDP = <span class="number">17</span>; <span class="comment">/* protocol number for UDP/IP */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * A list of mappings</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pmaplist</span> &#123;</span></span><br><span class="line"> pmap <span class="built_in">map</span>;</span><br><span class="line"> pmaplist *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Arguments to callit</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">call_args</span> &#123;</span></span><br><span class="line"> <span class="type">rpcprog_t</span> prog;</span><br><span class="line">  <span class="type">rpcvers_t</span> vers;</span><br><span class="line">  <span class="type">rpcproc_t</span> proc;</span><br><span class="line"> opaque args&lt;&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Results of callit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">call_result</span> &#123;</span></span><br><span class="line"> <span class="type">rpcport_t</span> port;</span><br><span class="line"> opaque res&lt;&gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Port mapper procedures</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> program PMAP_PROG &#123;</span><br><span class="line"> version PMAP_VERS &#123;</span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> <span class="title function_">PMAPPROC_NULL</span><span class="params">(<span class="type">void</span>)</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="type">bool</span></span><br><span class="line"> <span class="title function_">PMAPPROC_SET</span><span class="params">(pmap)</span> = <span class="number">1</span>;</span><br><span class="line"> <span class="type">bool</span></span><br><span class="line"> <span class="title function_">PMAPPROC_UNSET</span><span class="params">(pmap)</span> = <span class="number">2</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"> <span class="title function_">PMAPPROC_GETPORT</span><span class="params">(pmap)</span> = <span class="number">3</span>;</span><br><span class="line"> pmaplist</span><br><span class="line"> <span class="title function_">PMAPPROC_DUMP</span><span class="params">(<span class="type">void</span>)</span> = <span class="number">4</span>;</span><br><span class="line"> call_result</span><br><span class="line"> <span class="title function_">PMAPPROC_CALLIT</span><span class="params">(call_args)</span> = <span class="number">5</span>;</span><br><span class="line"> &#125; = <span class="number">2</span>;</span><br><span class="line"> &#125; = <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><h1 id="二、RPC协议"><a href="#二、RPC协议" class="headerlink" title="二、RPC协议"></a>二、RPC协议</h1><h2 id="2-1-协议概述"><a href="#2-1-协议概述" class="headerlink" title="2.1 协议概述"></a>2.1 协议概述</h2><p>RPC 协议提供以下内容：</p><ul><li>被调用过程的唯一规范。</li><li>将响应消息与请求消息进行匹配的规定。</li><li>提供对服务的调用者进行身份验证以及反向验证的规定，此外，RPC还提供以下功能的检测<ul><li>RPC协议不匹配</li><li>远程程序协议版本不匹配</li><li>协议错误，例如对过程参数指定不正确</li><li>远程认证失败的原因</li></ul></li></ul><p>考虑由两个程序组成的网络文件服务。一个程序可能处理高级应用程序，例如文件系统访问控制和锁定。另一个程序可能处理低级文件 I&#x2F;O，并具有读取和写入等过程。网络文件服务的客户端系统将代表客户端系统上的某个用户调用与该服务的两个程序相关联的过程。在客户端-服务器模型中，使用远程过程调用来调用服务。</p><h3 id="2-1-1-RPC-模型"><a href="#2-1-1-RPC-模型" class="headerlink" title="2.1.1 RPC 模型"></a>2.1.1 RPC 模型</h3><p>RPC 模型类似于本地过程调用模型。在本地情况下，调用者将过程的参数放置在某个明确指定的位置。然后，调用者将控制权移交给过程，并最终重新获得控制权。此时，从明确指定的位置提取过程的结果，然后调用者继续运行。</p><p>RPC 模型与之类似，一个控制线程在逻辑上会经过两个进程。一个是调用者的进程，另一个是服务器的进程。从概念上讲，调用者进程向服务器进程发送调用消息并等待回复消息。调用消息包含过程的参数以及其他信息。回复消息包含过程的结果以及其他信息。收到回复消息后，将提取过程的结果并恢复调用者的执行。</p><p>在服务器端，进程处于休眠状态，等待调用消息的到来。当调用消息到达时，服务器进程提取过程的参数、计算结果、发送回复消息，然后等待下一个调用消息。</p><p>请注意，在此描述中，两个进程中只有一个在任何给定时间处于活动状态。但是，RPC 协议对实现并发模型没有任何限制。例如，实现可能选择让 RPC 调用异步，以便客户端可以在等待服务器回复时执行有用的工作。另一种可能性是让服务器创建一个任务来处理传入的请求，以便服务器可以自由接收其他请求。</p><h3 id="2-1-2-传输和语义"><a href="#2-1-2-传输和语义" class="headerlink" title="2.1.2 传输和语义"></a>2.1.2 传输和语义</h3><p>RPC 协议独立于传输协议。也就是说，RPC 不考虑消息如何通过网络从一个进程传递到另一个进程。该协议仅对消息处理进行规范和解释。</p><p>RPC 不会尝试确保传输可靠性。因此，您必须向应用程序提供有关 RPC 下使用的传输协议类型的信息。如果您告诉 RPC 服务它在可靠的传输（如 TCP）上运行，则该服务的大部分工作已经完成。另一方面，如果 RPC 在不可靠的传输（如 UDP）上运行，则该服务必须设计自己的重新传输和超时策略。RPC 不提供此服务。</p><p>由于传输独立性，RPC 协议不会将特定语义附加到远程过程或其执行。语义可以从底层传输协议推断出来，但应由底层传输协议明确指定。例如，假设 RPC 在不可靠的传输上运行。如果应用程序在短时间超时后未收到回复而重新传输 RPC 消息，则它只能推断该过程已执行零次或多次。如果应用程序收到了回复，它可以推断该过程至少执行了一次。</p><p>服务器可以选择记住以前授予的来自客户端的请求，并且不再重新授予它们，以确保某种程度的“最多执行一次”语义。服务器可以使用与每个 RPC 请求一起打包的事务 ID 来实现这一点。此事务 ID 的主要用途是供 RPC 客户端匹配对请求的回复。但是，客户端应用程序可以选择在重新传输请求时重用其以前的事务 ID。服务器应用程序检查这一事实后，可以选择在授予请求后记住此 ID，并且不再重新授予具有相同 ID 的请求。服务器不允许以任何其他方式检查此 ID，除非将其作为相等性测试。</p><p>另一方面，如果使用可靠的传输（如 TCP），应用程序可以从回复消息中推断该过程只执行了一次。如果应用程序没有收到回复消息，它就不能假设远程过程没有执行。请注意，即使使用面向连接的协议（如 TCP），应用程序仍然需要超时和重新连接来处理服务器崩溃。</p><h2 id="2-2-RPC消息字段说明"><a href="#2-2-RPC消息字段说明" class="headerlink" title="2.2 RPC消息字段说明"></a>2.2 RPC消息字段说明</h2><h3 id="2-2-1-Program-and-Procedure-Numbers"><a href="#2-2-1-Program-and-Procedure-Numbers" class="headerlink" title="2.2.1 Program and Procedure Numbers"></a>2.2.1 Program and Procedure Numbers</h3><p>RPC call message具有三个无符号字段，用于唯一标识要调用的过程：</p><ul><li>Remote program number</li><li>Remote program version number</li><li>Remote procedure number</li></ul><p><strong>Program numbers</strong>以<code>0x20000000</code>为一组分布，如下表所示。</p><table><thead><tr><th align="left">Program Numbers</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">00000000 - 1fffffff</td><td align="left">Defined by host</td></tr><tr><td align="left">20000000 - 3fffffff</td><td align="left">Defined by user</td></tr><tr><td align="left">40000000 - 5fffffff</td><td align="left">Transient (reserved for customer-written applications)</td></tr><tr><td align="left">60000000 - 7fffffff</td><td align="left">Reserved</td></tr><tr><td align="left">80000000 - 9fffffff</td><td align="left">Reserved</td></tr><tr><td align="left">a0000000 - bfffffff</td><td align="left">Reserved</td></tr><tr><td align="left">c0000000 - dfffffff</td><td align="left">Reserved</td></tr><tr><td align="left">e0000000 - ffffffff</td><td align="left">Reserved</td></tr></tbody></table><p>说明：</p><ol><li><p>Oracle 负责管理第一组编号，这些编号对于所有客户来说都应该是相同的。如果客户开发的应用程序可能引起普遍的兴趣，那么应该为该应用程序分配第一个范围内的编号。</p></li><li><p>第二组数字是为特定客户应用程序保留的。此范围主要用于调试新程序。</p></li><li><p>第三组保留给动态生成程序编号的应用程序。</p></li><li><p>最后的组保留供将来使用，不应使用。</p></li><li><p>RPC Program Number由互联网编号分配机构 (IANA) 分配。获取程序编号分配的政策和程序在<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM1NTMx">RFC 5531<i class="fa fa-external-link-alt"></i></span>的第 13 节中进行了描述。已分配的 RPC 程序编号列表可在 <span class="exturl" data-url="aHR0cDovL3d3dy5pYW5hLm9yZy8=">IANA 网站<i class="fa fa-external-link-alt"></i></span> 上找到。</p></li></ol><p><strong>Version number</strong>  : 程序的首次实现很可能具有版本号 1。大多数新协议都会发展成为更好、更稳定、更成熟的协议。因此，call message的版本字段会标识调用者正在使用的协议的版本。版本号使得同一服务器进程使用新旧协议成为可能。</p><p><strong>Procedure numbe</strong> : 标识要调用的过程。这些编号记录在各个程序的协议规范中。</p><h3 id="2-2-2-RPC-version-number"><a href="#2-2-2-RPC-version-number" class="headerlink" title="2.2.2 RPC version number"></a>2.2.2 RPC version number</h3><p>正如Procedure有多个版本一样，RPC 协议本身也有多个版本。因此，call message中也包含 RPC 版本号，对于此处描述的 RPC 版本，<strong>该版本号始终等于 2</strong>。</p><p>对请求消息的回复消息具有足够的信息来区分以下错误情况：</p><ul><li>RPC 的远程实现不使用协议版本 2。返回支持的最低和最高 RPC 版本号。</li><li>remote program在远程系统上不可用。</li><li>remote program不支持请求的version number。返回支持的最低和最高remote program version number。</li><li>请求的procedure number不存在。此结果通常是调用方协议或编程错误。</li><li>服务器将remote procedure的参数解释为垃圾。同样，这种结果通常是由于客户端和服务之间的协议不一致造成的。</li></ul><h3 id="2-2-3-Authentication"><a href="#2-2-3-Authentication" class="headerlink" title="2.2.3 Authentication"></a>2.2.3 Authentication</h3><p>作为 RPC 协议的一部分，提供对服务的调用者进行身份验证以及反向验证。call message 有两个身份验证字段，即credentials和verifier。reply message有一个身份验证字段，即verifier。RPC 协议规范将这三个字段定义为以下不透明类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">auth_flavor</span> &#123;</span></span><br><span class="line">  AUTH_NONE = <span class="number">0</span>,</span><br><span class="line">  AUTH_SYS = <span class="number">1</span>,</span><br><span class="line">  AUTH_SHORT = <span class="number">2</span>,</span><br><span class="line">  AUTH_DES = <span class="number">3</span>,</span><br><span class="line"><span class="comment">/* and more to be defined */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opaque_auth</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span>         <span class="title">auth_flavor</span>;</span>        <span class="comment">/* style of credentials */</span></span><br><span class="line">  u_int        oa_length;        <span class="comment">/* not to exceed MAX_AUTH_BYTES */</span></span><br><span class="line">  <span class="type">caddr_t</span>      oa_base;          <span class="comment">/* address of more auth stuff */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>opaque_auth结构是一个auth_flavor枚举，后面是RPC协议实现不透明的字节。</p></li><li><p>认证字段中包含的数据的解释和语义由独立的认证协议规范指定。有关各种身份验证协议的定义，后文有介绍。</p></li><li><p>如果认证参数被拒绝，则响应消息中应说明被拒绝的原因。</p></li></ul><h2 id="2-3-RPC消息格式"><a href="#2-3-RPC消息格式" class="headerlink" title="2.3 RPC消息格式"></a>2.3 RPC消息格式</h2><p>下面以 XDR 数据描述语言定义 RPC消息格式。该消息以<strong>自上而下</strong>的方式定义，如以下代码示例所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">msg_type</span> &#123;</span></span><br><span class="line"> CALL = <span class="number">0</span>,</span><br><span class="line"> REPLY = <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对call message的回复可以采用两种形式：该消息被accepted or rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reply_stat</span> &#123;</span></span><br><span class="line"> MSG_ACCEPTED = <span class="number">0</span>,</span><br><span class="line"> MSG_DENIED = <span class="number">1</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假如call message已被accepted，则以下是</span></span><br><span class="line"><span class="comment"> * 尝试调用remote procedure的状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">accept_stat</span> &#123;</span></span><br><span class="line"> SUCCESS = <span class="number">0</span>,       <span class="comment">/* RPC executed successfully */</span></span><br><span class="line"> PROG_UNAVAIL = <span class="number">1</span>,  <span class="comment">/* remote service hasn&#x27;t exported program */</span></span><br><span class="line"> PROG_MISMATCH = <span class="number">2</span>, <span class="comment">/* remote service can&#x27;t support version # */</span></span><br><span class="line"> PROC_UNAVAIL = <span class="number">3</span>,  <span class="comment">/* program can&#x27;t support procedure */</span></span><br><span class="line"> GARBAGE_ARGS = <span class="number">4</span>   <span class="comment">/* procedure can&#x27;t decode params */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * call message被rejected的原因：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reject_stat</span> &#123;</span></span><br><span class="line"> RPC_MISMATCH = <span class="number">0</span>,  <span class="comment">/* RPC version number != 2 */</span></span><br><span class="line"> AUTH_ERROR = <span class="number">1</span>     <span class="comment">/* remote can&#x27;t authenticate caller */</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * authentication失败的原因：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">auth_stat</span> &#123;</span></span><br><span class="line"> AUTH_BADCRED = <span class="number">1</span>,       <span class="comment">/* bad credentials */</span></span><br><span class="line"> AUTH_REJECTEDCRED = <span class="number">2</span>,  <span class="comment">/* clnt must do new session */</span></span><br><span class="line"> AUTH_BADVERF = <span class="number">3</span>,       <span class="comment">/* bad verifier */</span></span><br><span class="line"> AUTH_REJECTEDVERF = <span class="number">4</span>,  <span class="comment">/* verify expired or replayed */</span></span><br><span class="line"> AUTH_TOOWEAK = <span class="number">5</span>        <span class="comment">/* rejected for security */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RPC消息：</span></span><br><span class="line"><span class="comment"> * 1. 所有消息都以事务标识符 xid 开头，后面跟着一个联合体，联合体的判断标准是msg_type，</span></span><br><span class="line"><span class="comment"> * 根据它的值切换到两种消息类型之一。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. reply message的 xid 总是与call message的xid匹配。注意：xid 字段仅用于客户端将</span></span><br><span class="line"><span class="comment"> * reply message与call message进行匹配或者用于服务器检测重传；服务端不能将此ID视为任何类型的序列号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rpc_msg</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> xid;</span><br><span class="line"> <span class="keyword">union</span> <span class="title function_">switch</span> <span class="params">(msg_type mtype)</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> CALL:</span><br><span class="line"> call_body cbody;</span><br><span class="line"> <span class="keyword">case</span> REPLY:</span><br><span class="line"> reply_body rbody;</span><br><span class="line"> &#125; body;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Body of an RPC request call：</span></span><br><span class="line"><span class="comment"> * 1. 在RPC协议V2版中，rpcvers必须等于 2。字段 prog、vers 和 proc 指定远程程序，其版本号和程序内部的过程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 紧接着是两个认证参数：cred（认证凭证 和 verf（身份验证验证器）。两个身份验证参数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 最后面参数由具体的程序协议指定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call_body</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> rpcvers; <span class="comment">/* must be equal to two (2) */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> prog;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> vers;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> proc;</span><br><span class="line"> opaque_auth cred;</span><br><span class="line"> opaque_auth verf;</span><br><span class="line"> <span class="comment">/* procedure specific parameters start here */</span></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Body of a reply to an RPC request:</span></span><br><span class="line"><span class="comment"> * call messag已被accepted or rejected。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> reply_body <span class="title function_">switch</span> <span class="params">(reply_stat stat)</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> MSG_ACCEPTED:</span><br><span class="line"> accepted_reply areply;</span><br><span class="line"> <span class="keyword">case</span> MSG_DENIED:</span><br><span class="line"> rejected_reply rreply;</span><br><span class="line">&#125; reply;</span><br><span class="line"></span><br><span class="line">所有消息都以事务标识符 xid 开头，后面跟着一个联合体，联合体的判断标准是msg_type，</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回复被服务器accepted的RPC请求,说明：即使请求被接受，也可能是错误。</span></span><br><span class="line"><span class="comment"> * 1. 第一个字段是服务器生成的身份验证验证器，用于向调用者验证自身</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 后面跟着一个联合体，其判断标准是accept_stat。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accepted_reply</span> &#123;</span></span><br><span class="line"> opaque_auth verf;</span><br><span class="line"> <span class="keyword">union</span> <span class="title function_">switch</span> <span class="params">(accept_stat stat)</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> SUCCESS:</span><br><span class="line"> opaque results[<span class="number">0</span>];</span><br><span class="line"> <span class="comment">/* procedure-specific results start here */</span></span><br><span class="line"> <span class="keyword">case</span> PROG_MISMATCH:</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> low;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> high;</span><br><span class="line"> &#125; mismatch_info;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Void. Cases include PROG_UNAVAIL, PROC_UNAVAIL, and</span></span><br><span class="line"><span class="comment">    * GARBAGE_ARGS.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">void</span>;</span><br><span class="line"> &#125; reply_data;</span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回复被服务器rejected的RPC请求：</span></span><br><span class="line"><span class="comment"> * 请求可能因两个原因被拒绝：</span></span><br><span class="line"><span class="comment"> * 1.服务器没有运行兼容版本的RPC协议(RPC_MISMATCH)，返回服务器支持的最低和最高RPC版本号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.服务器身份验证被拒绝(AUTH_ERROR),返回拒绝状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> rejected_reply <span class="title function_">switch</span> <span class="params">(reject_stat stat)</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> RPC_MISMATCH:</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> low;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> high;</span><br><span class="line"> &#125; mismatch_info;</span><br><span class="line"> <span class="keyword">case</span> AUTH_ERROR:</span><br><span class="line"> auth_stat stat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-粘包问题"><a href="#2-4-粘包问题" class="headerlink" title="2.4 粘包问题"></a>2.4 粘包问题</h2><p>当 RPC 消息基于字节流传输（如 TCP）传递时，要将一个RPC消息与另一个RPC消息分隔开。RPC使用record marking (RM)解决这个问题。一个record即一个RPC消息，由一个或多个record fragments组成。record fragments有一个4字节大小的fragment header，后面跟着<code>0</code>到&#96;(2*31) - 1 字节的fragment数据。这些字节编码一个无符号二进制数，类似于XDR整数，<strong>字节顺序是网络字节顺序</strong>。</p><p>fragment header：</p><ul><li>布尔值，指定该fragment是否为record的最后一个fragment。位值 1 表示该fragment是最后一个fragment。</li><li>31 位无符号二进制值，表示fragment数据的长度（以字节为单位）。布尔值是header的最高位bit。长度是 31 个低位bit。此record规范不是 XDR 标准格式。</li></ul><h2 id="2-5-Authentication-Protocols"><a href="#2-5-Authentication-Protocols" class="headerlink" title="2.5 Authentication Protocols"></a>2.5 Authentication Protocols</h2><h3 id="2-5-1-AUTH-NONE-Authentication"><a href="#2-5-1-AUTH-NONE-Authentication" class="headerlink" title="2.5.1 AUTH_NONE Authentication"></a>2.5.1 AUTH_NONE Authentication</h3><p>调用者不进行身份验证，服务器也不理会调用者是谁。在这种情况下，RPC消息的credentials、verifier和response verifier的flavor值是AUTH_NONE。即opaque_auth中auth_flavor值。在使用AUTH_NONE身份验证类型时，opaque_auth中oa_length为0。</p><h3 id="2-5-2-AUTH-SYS-Authentication"><a href="#2-5-2-AUTH-SYS-Authentication" class="headerlink" title="2.5.2 AUTH_SYS Authentication"></a>2.5.2 AUTH_SYS Authentication</h3><p>AUTH_SYS与以前称为 AUTH_UNIX 的身份验证风格相同。远程过程的调用者可能希望使用传统的UNIX进程权限身份验证来标识自己。这种RPC call message的opaque_auth中auth_flavor值是AUTH_SYS。oa_base的字节编码为以下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UNIX style credentials.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">auth_sysparms</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stamp;  <span class="comment">// credentials creation time</span></span><br><span class="line">  <span class="built_in">string</span> machine_name&lt;<span class="number">255</span>&gt;; <span class="comment">// caller system的名字，最多不超过255字节</span></span><br><span class="line">  <span class="type">uid_t</span> uid; <span class="comment">// caller的有效用户ID</span></span><br><span class="line">  <span class="type">gid_t</span> gid; <span class="comment">// caller的有效组ID</span></span><br><span class="line">  <span class="type">gids_t</span> gids; <span class="comment">// caller所属于所有组</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> machine_name&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> name_len; <span class="comment">// 主机名长度</span></span><br><span class="line">    <span class="type">char</span>* name; <span class="comment">// 主机名</span></span><br><span class="line">    <span class="type">char</span>* padding; <span class="comment">// machine_name大小基于4字节对齐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gids_t</span>&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> gid_num; <span class="comment">// 所属组个数，最多不能超过16个</span></span><br><span class="line">  <span class="type">gid_t</span> gid&lt;<span class="number">16</span>&gt;; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2-5-3-AUTH-SHORT-Verifier"><a href="#2-5-3-AUTH-SHORT-Verifier" class="headerlink" title="2.5.3 AUTH_SHORT Verifier"></a>2.5.3 AUTH_SHORT Verifier</h3><p>当使用 AUTH_SYS 身份验证时， 来自服务器的reply message中response verifier类型可能是AUTH_NONE 或 AUTH_SHORT。如果是 AUTH_SHORT，response verifier字符串字节编码为short_hand_verf结构。这个不透明的结构现在可以传递给服务器，而不是原始的AUTH_SYS credentials。</p><p>说明：</p><ul><li>服务器会保留一个缓存，将简短不透明结构映射到调用者的original credentials。这些结构通过 AUTH_SHORT类型的response verifier返回。调用者可以使用new credentials节省网络带宽和服务器 CPU 周期。</li><li>服务器可以随时刷新简短不透明结构。如果发生刷新，则远程过程call message 会因身份验证错误而被拒绝。失败的原因是 <code>AUTH_REJECTEDCRED</code>。此时，调用者可能会尝试原始的 AUTH_SYS 类型的credentials。</li></ul><p><img src="https://i-blog.csdnimg.cn/direct/03a13933da1541d9bcf3fb889439c859.jpeg#pic_center" alt="在这里插入图片描述"></p><h3 id="2-5-4-AUTH-DES-Authentication"><a href="#2-5-4-AUTH-DES-Authentication" class="headerlink" title="2.5.4 AUTH_DES Authentication"></a>2.5.4 AUTH_DES Authentication</h3><p>使用 AUTH_SYS 身份验证的情况：1. 如果同一网络上有不同操作系统的系统，则无法保证呼叫者识别的唯一性。2. 由于不存在verifier，因此credentials很容易被伪造。AUTH_DES身份验证就是为了解决这两个问题，AUTH_DES比较复杂，有兴趣可以自行了解。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="RPC请求消息与响应消息数据包"><a href="#RPC请求消息与响应消息数据包" class="headerlink" title="RPC请求消息与响应消息数据包"></a>RPC请求消息与响应消息数据包</h2><p>下面捕捉的是客户端向远程服务器的<code>rpcbind</code>查询mount程序的端口所产生的RPC数据包</p><p>RPC 请求消息</p><p><img src="https://i-blog.csdnimg.cn/direct/bf24151d50a5462896cc33647d091e1c.png#pic_center" alt="在这里插入图片描述"></p><p>RPC 响应消息</p><p><img src="https://i-blog.csdnimg.cn/direct/1862267183f14d59845f7bce60c74d28.png#pic_center" alt="在这里插入图片描述"></p><h2 id="一个简单portmapper程序源码"><a href="#一个简单portmapper程序源码" class="headerlink" title="一个简单portmapper程序源码"></a>一个简单portmapper程序源码</h2><p>可参考<span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvaW5mby9yZmM1NTMx">libnfs<i class="fa fa-external-link-alt"></i></span>项目下<code>examples/portmap-server.c</code>文件</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考Oracle的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTM3ODM4XzAxL2h0bWwvRTYxMDU4L2luZGV4Lmh0bWw=">RPC文档<i class="fa fa-external-link-alt"></i></span>并对内容进行删改，版权所有为Oracle。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;strong&gt;阅读本文需要对TCP&amp;#x2F;IP协议簇和linux系统有一定了解。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、RPC介绍&quot;&gt;&lt;a href=&quot;#一、RPC介绍&quot; class=&quot;headerlink&quot; title=&quot;一、RPC介绍&quot;&gt;&lt;/a&gt;一、RPC介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1-RPC是什么&quot;&gt;&lt;a href=&quot;#1-1-RPC是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 RPC是什么&quot;&gt;&lt;/a&gt;1.1 RPC是什么&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RPC (Remote Procedure Call)&lt;/strong&gt;：一个计算机通信协议，基于扩展常规或本地过程调用的概念。因此被调用过程不必与调用过程存在于同一地址空间中。这两个进程可能位于同一系统上，也可能位于不同的系统上，并通过网络连接它们。程序员就像调用本地程序一样，无需额外地为这个交互编程（无需关注细节）。&lt;br&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/4ee4133b8b3849c99e238b9d86986592.jpeg#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt; 上图表示两个联网系统之间 RPC 调用流程。客户端进行过程调用，向服务器发送请求并阻塞等待，直到收到答复或请求超时。当请求到达时，服务器执行对应的请求过程，并将执行结果发送给客户端。客户端收到应答消息后被唤醒继续运行。&lt;/p&gt;</summary>
    
    
    
    <category term="通信框架" scheme="https://blog.kjlcloud.com/categories/%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="RPC" scheme="https://blog.kjlcloud.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>qcow2文件格式</title>
    <link href="https://blog.kjlcloud.com/2024/11/01/qcow2%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://blog.kjlcloud.com/2024/11/01/qcow2%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-11-01T09:07:37.000Z</published>
    <updated>2024-11-01T09:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-1-qcow2是什么"><a href="#1-1-qcow2是什么" class="headerlink" title="1.1 qcow2是什么"></a>1.1 qcow2是什么</h2><p><code>qcow2</code> 是一种虚拟磁盘镜像格式，全称是 “QEMU Copy-On-Write version 2”。它可以用一个文件的形式来表示一块固定大小的块设备磁盘。</p><ul><li><p><strong>动态分配</strong>：qcow2 支持按需分配空间，不会立即占用所有磁盘容量，而是随着数据写入逐渐扩展大小，节省存储空间。</p></li><li><p><strong>支持快照</strong>：qcow2 格式允许创建快照。</p></li><li><p><strong>压缩和加密</strong>：qcow2 格式支持对数据进行压缩以减少磁盘空间，并可以启用AES加密来保护镜像数据的安全。</p></li><li><p><strong>写时复制（Copy-On-Write, COW）</strong>：这意味着只有在镜像文件上有新的写操作时，才会实际改变文件内容，这样可以更高效地使用磁盘空间。</p></li></ul><span id="more"></span><h2 id="1-2-名词解释"><a href="#1-2-名词解释" class="headerlink" title="1.2 名词解释"></a>1.2 名词解释</h2><table><thead><tr><th align="left">术语</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">offset</td><td align="left">相对于qcow2文件(img)起始处的偏移量</td></tr><tr><td align="left">cluster</td><td align="left">qcow2文件由固定大小的单元组成，该单元称为cluster，默认大小为65536bytes&#x2F;64K</td></tr><tr><td align="left">sector</td><td align="left">数据块读写的最小单元，大小为512字节</td></tr><tr><td align="left">host cluster</td><td align="left">Host上qcow2文件的cluster</td></tr><tr><td align="left">guest cluster</td><td align="left">Guest上virtual disk的cluster</td></tr><tr><td align="left">qcow2 header</td><td align="left">qcow2文件的头信息，占用第一个cluster</td></tr><tr><td align="left">refcount</td><td align="left">qcow2内部用于管理cluster的分配而维护的引用计数</td></tr><tr><td align="left">refcount table</td><td align="left">用于查找refcount的第一级表</td></tr><tr><td align="left">refcount block</td><td align="left">用于查找refcount的第二级表</td></tr><tr><td align="left">L1 table</td><td align="left">用于查找guest cluster到host cluster映射的第一级表</td></tr><tr><td align="left">L2 table</td><td align="left">用于查找guest cluster到host cluster映射的第二级表</td></tr><tr><td align="left">IBA</td><td align="left">image block address</td></tr><tr><td align="left">VBA</td><td align="left">virtual block address</td></tr></tbody></table><h2 id="1-3-qcow2文件格式"><a href="#1-3-qcow2文件格式" class="headerlink" title="1.3 qcow2文件格式"></a>1.3 qcow2文件格式</h2><p><span style="color: red;">qcow2中所有数字按大端字节序存储</span></p><h2 id="1-3-1-文件头"><a href="#1-3-1-文件头" class="headerlink" title="1.3.1 文件头"></a>1.3.1 文件头</h2><p>qcow2文件的第一个cluster包含文件头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QCowHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic; <span class="comment">// &quot;QFI\xfb&quot; 4个字节固定的标识符</span></span><br><span class="line">    <span class="type">uint32_t</span> version; <span class="comment">// 版本, 2 或 3</span></span><br><span class="line">    <span class="type">uint64_t</span> backing_file_offset; <span class="comment">// 存放后备文件路径的offset，这个字符串不是以0结束的。该值为0时，不是无后备文件</span></span><br><span class="line">    <span class="type">uint32_t</span> backing_file_size; <span class="comment">//  后备文件路径字符串长度，单位是字节数。必须小于1023字节。没有后备文件时，该值无意义</span></span><br><span class="line">    <span class="type">uint32_t</span> cluster_bits; <span class="comment">// cluster_size =  1 &lt;&lt; cluster_bits，该值不能小于9，即cluster大小不能小于512字节</span></span><br><span class="line">    <span class="type">uint64_t</span> size; <span class="comment">// 虚拟磁盘的大小，不是该qcow2文件实际占用空间大小</span></span><br><span class="line">    <span class="type">uint32_t</span> crypt_method; <span class="comment">// 0：未加密；1： AES加密</span></span><br><span class="line">    <span class="type">uint32_t</span> l1_size; <span class="comment">// L1表的entry数目</span></span><br><span class="line">    <span class="type">uint64_t</span> l1_table_offset; <span class="comment">// L1表在img中的偏移量，必须与cluster对齐</span></span><br><span class="line">    <span class="type">uint64_t</span> refcount_table_offset;  <span class="comment">// refcount table在img中的偏移量，必须与cluster对齐</span></span><br><span class="line">    <span class="type">uint32_t</span> refcount_table_clusters;<span class="comment">// refcount table占用了多少个cluster</span></span><br><span class="line">    <span class="type">uint32_t</span> nb_snapshots;           <span class="comment">//snapshot的个数</span></span><br><span class="line">    <span class="type">uint64_t</span> snapshots_offset;       <span class="comment">//snapshot在img的offset，必须与cluster对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields are only valid for version &gt;= 3 */</span></span><br><span class="line">    <span class="type">uint64_t</span> incompatible_features;</span><br><span class="line">    <span class="type">uint64_t</span> compatible_features;</span><br><span class="line">    <span class="type">uint64_t</span> autoclear_features;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> refcount_order; <span class="comment">// refcount_block表中entry大小= 1 &lt;&lt; refcount_orde。单位为bits。 版本为2时总是假设值为4，也就是说一个entry大小为2字节</span></span><br><span class="line">    <span class="type">uint32_t</span> header_length; <span class="comment">// 文件头结构体的大小，版本2时总是假设值为72 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-3-2-文件头扩展"><a href="#1-3-2-文件头扩展" class="headerlink" title="1.3.2 文件头扩展"></a>1.3.2 文件头扩展</h2><p>在文件头之后，可以存储称为文件头扩展的可选部分，每个扩展都有如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qcow2UnknownHeaderExtension</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    QLIST_ENTRY(Qcow2UnknownHeaderExtension) next;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125; Qcow2UnknownHeaderExtension;</span><br></pre></td></tr></table></figure><p>Qcow2UnknownHeaderExtension结构说明:</p><pre><code>Byte  0 -  3:   Header extension type:          0x00000000 - End of the header extension area          0xE2792ACA - Backing file format name          0x6803f857 - Feature name table          other      - Unknown header extension, can be safely ignored                4 -  7:   Header extension数据长度            8 -  n:   Header extension数据部分            n -  m:   为对齐到8字节的填充部分 </code></pre><p>other - Unknown header extension, can be safely</p><p>ignored</p><p>4 - 7: header extension 的数据长度0000 0005 5byte</p><p>8 - n: Header extension数据部分 7163 6f77 32</p><p>n - m: 为对齐到 8字节的填充部分 00 0000</p><p><span style="color: red;">注意:  除非特别说明，否则每个Header extension type只能在image中出现一次</span></p><h3 id="1-3-3-backing-file-name"><a href="#1-3-3-backing-file-name" class="headerlink" title="1.3.3 backing file name"></a>1.3.3 backing file name</h3><p>头扩展区域的末尾和第一个cluster的末尾之间的剩余空间可用于存放后备文件路径名。</p><h2 id="1-4-qcow2文件格式"><a href="#1-4-qcow2文件格式" class="headerlink" title="1.4 qcow2文件格式"></a>1.4 qcow2文件格式</h2><p>refcount table&#x2F;refcount block&#x2F;l1&#x2F;l2的顺序关系不限</p><img src="qcow2文件格式.png"><h1 id="二、Host-cluster-management"><a href="#二、Host-cluster-management" class="headerlink" title="二、Host cluster management"></a>二、Host cluster management</h1><p>qcow2通过维护引用计数来管理Host cluster的分配。refcount为0表示cluster 空闲，1表示cluster已被使用，&gt;&#x3D;2表示cluster已被使用并且任何写访问都必须执行COW操作。引用计数通过二级表进行管理。</p><p><strong>refcount table</strong></p><ul><li>其大小是可变的，以cluster为单位分配</li><li>若分配多个cluster，则占用空间必须是连续的</li><li>每个entry大小为8字节，存放的是refcount block表的offset</li></ul><p><strong>refcount block</strong></p><ul><li>大小为1 cluster</li><li>每个entry大小为2字节，存放refcount</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定qcow2文件的offset，其cluster的refcount可以通过下列公式计算得出</span></span><br><span class="line"></span><br><span class="line">refcount_block_entries = (cluster_size / <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))</span><br><span class="line"></span><br><span class="line">refcount_block_index = (offset / cluster_size) % refcount_block_entries</span><br><span class="line">refcount_table_index = (offset / cluster_size) / refcount_block_entries</span><br><span class="line"></span><br><span class="line">refcount_block = load_cluster(refcount_table[refcount_table_index]);</span><br><span class="line"><span class="keyword">return</span> refcount_block[refcount_block_index];</span><br></pre></td></tr></table></figure><p><strong>refcount table entry</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bit  0 -  8:    Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">     9 - 63:    refcount block表在img中的offset，必须与cluster对齐。如果该值为0则表示还没分配</span><br><span class="line">       相应的refcount block，这个refcount block管理的所有refcount值为0</span><br></pre></td></tr></table></figure><p>**refcount block entry ** :</p><pre><code>x = refcount_bits - 1，refcount_bit值与qcow2 header中refcount_order变量有关Bit  0 -  x:  cluster的refcount</code></pre><h1 id="三、Cluster-mapping"><a href="#三、Cluster-mapping" class="headerlink" title="三、Cluster mapping"></a>三、Cluster mapping</h1><h2 id="3-1-为什么需要Cluster-mapping"><a href="#3-1-为什么需要Cluster-mapping" class="headerlink" title="3.1 为什么需要Cluster mapping"></a>3.1 为什么需要Cluster mapping</h2><p>以向一个空的qcow2文件写入数据为例，假设cluster大小为65536字节。</p><img src="虚拟机写数据1.png"><p>从前两次写操作来看，似乎虚拟机写入的数据与写入qcow2文件的数据成某种线性关系。起始为0，大小65536的数据写入第一个cluster中。起始为65536，大小65535的数据写入第二个cluster。如果第三次写起始为655360，大小65536数据？qcow2并不会把它放在第11个cluster中，而是放在第三个cluster中。<strong>这样qcow2就不会向raw一样产生空洞，qcow2文件随着不停的写入数据而慢慢变大。然而这样也同时打破了虚拟的地址偏移与qcow2的地址偏移的线形关系</strong>。</p><p>正是因为虚拟机写入的数据与写入到qcow2文件中的数据不成线性关系，因此qcow2 需要通过映射表查询cluster真实的存储位置。为此qcow2文件中通过L2 table来记录虚拟地址偏移与qcow2文件地址偏移的关系。L2 table中的每一项都是一个64位地址，存某个cluster在qcow2文件中的offset。</p><p><strong>guest cluster对应host cluster真实位置保存在L2 table的第N个元素中，其中N与guest cluster成线性关系。</strong></p><img src="虚拟机写数据2.png" ><p>一个qcow2文件以cluster为单位进行切分, L2 table记录guest cluster到host cluster的映射关系。一个L2 table大小等于一个cluster的大小。cluster默认大小是64K，即一个L2 table有8192个元素，可以管理512M大小空间。当超过512M大小的时候qcow2会新建一个L2 table，由于新建的L2 table与之前的L2 table地址不相邻（其实每一个L2 table只是qcow2文件中的一个cluster，每次新建一个L2 table也就是分配一个cluster）。所以qcow2没办法简单的记录它，因此产生 L1 table。 L1 table中每一个元素都指向一个L2 table的地址。L1 ta ble的地址保存在qcow2 header中。</p><img src="Cluster_mapping.png"  style="zoom:50%;" ><h2 id="3-2-L1-table与-L2-table"><a href="#3-2-L1-table与-L2-table" class="headerlink" title="3.2 L1 table与 L2 table"></a>3.2 L1 table与 L2 table</h2><p>与refcounts一样，qcow2使用二级表将guest cluster映射到host cluster。它们被称为L1 table和L2 table。</p><p><strong>L1 table</strong></p><ul><li>其大小是可变的，以cluster为单位分配</li><li>若分配多个cluster，则占用空间必须是连续的</li><li>entry个数等于qcow2 header中l1_size变量的值</li><li>每个entry大小为8字节，存放的是L2 table的offset</li></ul><p><strong>L2 table</strong></p><ul><li>大小为1 cluster</li><li>每个entry大小为8字节，存某个cluster在qcow2文件中的offset。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定虚拟磁盘的offset，其对应到qcow2文件的offset可以通过下列公式计算得出</span></span><br><span class="line"></span><br><span class="line"> l2_entries = (cluster_size / <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line"></span><br><span class="line"> l2_index = (offset / cluster_size) % l2_entries</span><br><span class="line"> l1_index = (offset / cluster_size) / l2_entries</span><br><span class="line"></span><br><span class="line"> l2_table = load_cluster(l1_table[l1_index]);</span><br><span class="line"> cluster_offset = l2_table[l2_index];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> cluster_offset + (offset % cluster_size)</span><br></pre></td></tr></table></figure><p><strong>L1 table entry</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bit   0 -  8:   Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">      9 - 55:   L2 table在img中的offset，必须与cluster对齐。如果该值为0则L2 table和</span><br><span class="line">     该L2 table所描述的所有cluster都没分配</span><br><span class="line"></span><br><span class="line">     56 - 62:   Reserved (set to 0)</span><br><span class="line"></span><br><span class="line">     63:   0表示L2表没有被使用或者需要COW， 1表示它refcount正好是1。此信息仅在活跃的L1表中是准确的</span><br></pre></td></tr></table></figure><p><strong>L2 table entry</strong></p><pre><code>Bit  0 -  61:   Cluster descriptor          62:   0 for standard clusters                1 for compressed clusters          63:   0表示未使用或需要COW的cluster，1表示它refcount正好是1。此信息仅在活动的L1表访问L2表中是准确的。</code></pre><p>​    Standard Cluster Descriptor:<br>​<br>​        Bit       0:   如果为1，则从cluster读取时返回全0数据。这通常描述预分配，但它不会用于从cluster读取数据，如果集群末分 配，也不会从后备文件读取致据。<br>​         With version 2, this is always 0.<br>​    </p><pre><code>         1 -  8:    Reserved (set to 0)         9 - 55:    host cluster在img中的offset，必须与cluster对齐。如果该值为0则表示该cluster未分配。        56 - 61:    Reserved (set to 0)        如果cluster未分配，读请求会从后备文件中获取数据(除非设置了Standard Cluster Descriptor中的第0位)。如果没有后备文件或后备文件小于image，则对后备文件未覆盖的所有部分一律读零</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-qcow2是什么&quot;&gt;&lt;a href=&quot;#1-1-qcow2是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 qcow2是什么&quot;&gt;&lt;/a&gt;1.1 qcow2是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;qcow2&lt;/code&gt; 是一种虚拟磁盘镜像格式，全称是 “QEMU Copy-On-Write version 2”。它可以用一个文件的形式来表示一块固定大小的块设备磁盘。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态分配&lt;/strong&gt;：qcow2 支持按需分配空间，不会立即占用所有磁盘容量，而是随着数据写入逐渐扩展大小，节省存储空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;支持快照&lt;/strong&gt;：qcow2 格式允许创建快照。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;压缩和加密&lt;/strong&gt;：qcow2 格式支持对数据进行压缩以减少磁盘空间，并可以启用AES加密来保护镜像数据的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;写时复制（Copy-On-Write, COW）&lt;/strong&gt;：这意味着只有在镜像文件上有新的写操作时，才会实际改变文件内容，这样可以更高效地使用磁盘空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://blog.kjlcloud.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="qcow2" scheme="https://blog.kjlcloud.com/tags/qcow2/"/>
    
  </entry>
  
  <entry>
    <title>FUSE是什么</title>
    <link href="https://blog.kjlcloud.com/2024/10/30/FUSE%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://blog.kjlcloud.com/2024/10/30/FUSE%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2024-10-30T07:52:05.000Z</published>
    <updated>2024-10-30T07:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、FUSE基本概念"><a href="#一、FUSE基本概念" class="headerlink" title="一、FUSE基本概念"></a>一、FUSE基本概念</h1><h2 id="1-1-FUSE-是什么"><a href="#1-1-FUSE-是什么" class="headerlink" title="1.1 FUSE 是什么"></a>1.1 FUSE 是什么</h2><p>FUSE 是 Filesystem in Userspace 的缩写，也就是常说的<strong>用户态文件系统</strong>。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvZnVzZS5odG1s">Linux内核官方文档<i class="fa fa-external-link-alt"></i></span>对 FUSE 的解释如下：</p><blockquote><p>What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).</p></blockquote><span id="more"></span><p><strong>即FUSE 是一个用户空间文件系统的框架</strong>，这套框架包含3个组件：</p><ol><li><strong>内核模块 fuse.ko</strong> ：用来接收VFS传递下来的IO请求，并且把这个IO封装之后通过管道发送到用户态；</li><li><strong>用户态 lib 库 libfuse</strong> ：解析内核态转发出来的协议包，拆解成常规的 IO 请求；</li><li><strong>mount 工具 fusermount</strong> ；</li></ol><p>这 3 个组件一起完成一件事：可以在用户态实现文件系统，并且让IO在内核态和用户态文件系统之间自由穿梭。</p><img src="FUSE架构图.png" width="50%"><h2 id="1-2-为什么需要FUSE"><a href="#1-2-为什么需要FUSE" class="headerlink" title="1.2 为什么需要FUSE"></a>1.2 为什么需要FUSE</h2><p>FUSE被称为用户空间文件系统，为什么要强调用户空间呢？接触过Linux内核的同学大概会知道，早期的文件系统开发只能在内核中。文件系统一般是实现在内核里面的，比如，Ext4、Fat32、NTFS(Kernel原生版)等常见的文件系统，其代码都在内核中，内核开发的难点在于调试和排查故障，而FUSE特殊之处就是，其文件系统的<strong>核心逻辑</strong>是在<strong>用户空间</strong>实现的。</p><p>有了FUSE之后，我们就可以在用户态空间实现文件系统。<br><strong>优点</strong>：开发便捷，易于调试。安全性高，崩溃不会影响整个系统。</p><p><strong>缺点</strong>：性能较低，会在用户态和内核态之间频繁切换，带来了性能开销。</p><h3 id="1-2-1-内核态文件系统IO流程"><a href="#1-2-1-内核态文件系统IO流程" class="headerlink" title="1.2.1 内核态文件系统IO流程"></a>1.2.1 内核态文件系统IO流程</h3><p>早期的文件系统是位于内核之中， 处于VFS之下，块设备之上的一个位置。对上呈现文件存储实现，对下管理裸块设备。也就是说早期文件系统是内核的一个模块。那就可以理解了，内核模块的开发之所以艰难就是难在<strong>调试和排障</strong>，用户态的程序你可以随意 debug，出问题最多也就是 panic，coredump，内核态的程序出了问题就是宕机，所有现场都丢失，你只能通过日志，kdump 等手段来排查。</p><p>下图是没有FUSE的时候，IO经过内核文件系统的一个大概流程</p><img src="内核态文件系统IO流程图1.gif"  ><p>比较详细的流程图<br><img src="内核态文件系统IO流程图2.png"  ></p><h3 id="1-2-2-用户态文件系统IO流程"><a href="#1-2-2-用户态文件系统IO流程" class="headerlink" title="1.2.2 用户态文件系统IO流程"></a>1.2.2 用户态文件系统IO流程</h3><p>注意：图中简化了用户态之上的逻辑处理。</p><img src="用户态文件系统IO流程图1.gif"  ><h1 id="二、FUSE进阶"><a href="#二、FUSE进阶" class="headerlink" title="二、FUSE进阶"></a>二、FUSE进阶</h1><h2 id="2-1-FUSE原理"><a href="#2-1-FUSE原理" class="headerlink" title="2.1 FUSE原理"></a>2.1 FUSE原理</h2><p>首先看一眼 wiki 上有对 FUSE 的 ls -l &#x2F;tmp&#x2F;fuse 命令的演示图：<br><img src="FUSE原理图.png"  ></p><p>背景：一个用户态文件系统，挂载点为 &#x2F;tmp&#x2F;fuse ，用户二进制程序文件为 .&#x2F;hello（该二进制程序可以理解为用户自己根据自身需求实现的文件系统）;</p><p>这个图的意思是：</p><ol><li>当执行 ls -l &#x2F;tmp&#x2F;fuse 命令的时候，流程如下：<br> (1) IO 请求先进内核，经VFS传递给内核 FUSE 文件系统模块；<br> (2) 内核 FUSE 模块把请求发给到用户态，由 .&#x2F;hello 程序接收并且处理。处理完成之后，响应原路返回；</li></ol><p>简化的 IO 动画示意图：</p><img src="FUSE简洁IO流程图.gif"  ><p>通过这两张图，对 FUSE IO 的流程应该就清晰了，内核 FUSE 模块在内核态中间做协议封装和协议解析的工作，它接收从VFS下来的请求并按照 FUSE 协议转发到用户态，然后接收用户态的响应，并随后回复给用户。<strong>FUSE在这条IO路径是做了一个透明中转站的作用</strong>，用户完全不感知这套框架。我们把中间的 FUSE 当作一个黑盒遮住，就更容易理解了。</p><p>fuse.ko和libfuse库的作用：</p><p>这两个模块一个位于内核，一个位于用户态，是配套使用的，最核心的功能是<strong>协议封装和解析</strong>。</p><p>举个例子，内核 fuse.ko用于接收VFS下来的IO请求，然后封装成 FUSE 数据包，转发给用户态。这个时候，用户态文件系统收到这个 FUSE 数据包，它如果想要看懂这个数据包，就必须实现一套FUSE协议的代码，这套代码是公开透明的，属于FUSE框架的公共的代码，这种代码不需要让所有的用户文件系统都重复实现一遍，于是libfuse库就诞生了。</p><h2 id="2-2-FUSE-协议格式"><a href="#2-2-FUSE-协议格式" class="headerlink" title="2.2 FUSE 协议格式"></a>2.2 FUSE 协议格式</h2><p>接下来我们看下FUSE数据传输的数据格式（FUSE协议的格式），请求包和响应包是什么样子的？</p><h3 id="2-2-1-FUSE-请求"><a href="#2-2-1-FUSE-请求" class="headerlink" title="2.2.1 FUSE 请求"></a>2.2.1 FUSE 请求</h3><p>FUSE 请求包分为两部分：</p><ol><li>Header ： 这个是所有请求共用的，比如 open 请求，read 请求，write 请求，getxattr 请求，头部都至少有这个结构体，Header 结构体能描述整个 FUSE 请求，其中字段能区分请求类型；</li><li>Payload ：这个东西是每个 IO 类型会是不同的，比如 read 请求就没这个，write 请求就有这个，因为 write 请求是携带数据的；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_in_header</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;       <span class="comment">/* Total length of the data, including this header */</span></span><br><span class="line">    <span class="type">uint32_t</span> opcode;    <span class="comment">/* The kind of operation (see below) */</span></span><br><span class="line">    <span class="type">uint64_t</span> unique;    <span class="comment">/* A unique identifier for this request */</span></span><br><span class="line">    <span class="type">uint64_t</span> nodeid;    <span class="comment">/* ID of the filesystem object being operated on */</span></span><br><span class="line">    <span class="type">uint32_t</span> uid;       <span class="comment">/* UID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> gid;       <span class="comment">/* GID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> pid;       <span class="comment">/* PID of the requesting process */</span></span><br><span class="line">    <span class="type">uint32_t</span> padding;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Len: 是整个请求的字节数长度（Header + Payload）</li><li>Opcode: 请求的类型，比如区分 open、read、write 等等；</li><li>Unique: 请求唯一标识（和响应中要对应）</li><li>Nodeid: 请求针对的文件 nodeid，目标文件或者文件夹的 nodeid；</li><li>Uid: 文件&#x2F;文件夹操作的进程的用户 ID</li><li>Gid: 文件&#x2F;文件夹操作的进程的用户组 ID</li><li>Pid: 文件&#x2F;文件夹操作的进程的进程 ID</li></ul><h3 id="2-2-2-FUSE响应"><a href="#2-2-2-FUSE响应" class="headerlink" title="2.2.2 FUSE响应"></a>2.2.2 FUSE响应</h3><p>FUSE 响应包分为两部分：</p><ol><li><p>Header ：这个结构体也是在数据头部的，所有 IO 类型的响应都至少有这个结构体。该结构体用于描述整个响应请求；</p></li><li><p>Payload ：每个请求的类型可能不同，比如 read 请求就会有这个，因为要携带 read 出来的用户数据，write 请求就不会有；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_out_header</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;       <span class="comment">/* Total length of data written to the file descriptor */</span></span><br><span class="line">    <span class="type">int32_t</span>  error;     <span class="comment">/* Any error that occurred (0 if none) */</span></span><br><span class="line">    <span class="type">uint64_t</span> unique;    <span class="comment">/* The value from the corresponding request */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>Len: 整个响应的字节数长度（ Header + Payload ）；</li><li>Error: 响应错误码，成功返回 0，其他对应着系统的错误代码，负数；</li><li>Unique: 对应者请求的唯一标识，和请求对应；</li></ul><h2 id="2-3-dev-fuse"><a href="#2-3-dev-fuse" class="headerlink" title="2.3 &#x2F;dev&#x2F;fuse"></a>2.3 &#x2F;dev&#x2F;fuse</h2><p>现在对数据协议的格式，转发和转运的模块我们也知道了。现在还差一个关键的点：数据包的通道，换句话说，内核模块的“包裹”发到哪里？用户程序又从哪里读取拿到这个“包裹”。</p><p><strong>答案是：&#x2F;dev&#x2F;fuse ，这个虚设备文件就是内核模块和用户程序的桥梁</strong>。</p><p>这样一切都顺理成章了，整个过程中，用户的IO通过正常的系统调用进来，走到内核文件系统FUSE，FUSE文件系统把这个IO请求按照FUSE协议封装起来，打包成特定的格式，通过 &#x2F;dev&#x2F;fuse 这个管道传递到用户态。在此之前有守护进程监听这个管道，看到有消息出来之后，立马读出来，然后利用libfuse库解析协议，之后就是用户文件系统的代码逻辑了。</p><p>该过程示意图如下（省略了拆解包的步骤）：<br><img src="数据通道.gif"  ></p><h1 id="三、-FUSE-的使用"><a href="#三、-FUSE-的使用" class="headerlink" title="三、 FUSE 的使用"></a>三、 FUSE 的使用</h1><ol><li>检查内核是否支持，即是否有fuse.ko 内核模块。可运行下列命令检查，如果不报错则表示内核支持并且已经加载。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# modprobe fuse</span><br></pre></td></tr></table></figure><ol start="2"><li>挂载FUSE内核文件系统，便于管理</li></ol><p>FUSE这个内核文件系统其实是可以挂载，也可以不挂载，挂载了主要是方便管理多个用户系统而已，FUSE内核文件系统的 Type 名称为 fusectl，挂载命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# mount -t fusectl none /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure><p>可以用 df -aT 命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">df</span> -aT|grep -i fuse</span><br><span class="line">none           fusectl             0       0         0    - /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure><p>通过挂载内核 fuse 文件系统，可以看到所有实现的用户文件系统，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">ls</span> -l /sys/fs/fuse/connections</span><br><span class="line">total 0</span><br><span class="line">dr-x------. 2 user1 user1 0 Oct 30 14:42 36</span><br><span class="line">dr-x------. 2 user1 user1 0 Oct 30 14:42 38</span><br></pre></td></tr></table></figure><p>在 &#x2F;sys&#x2F;fs&#x2F;fuse&#x2F;connections 对应两个目录，目录名为 Unique ID，能够唯一标识一个用户文件系统。这里表示内核 fuse 模块通过 &#x2F;dev&#x2F;fuse 设备文件，建立了两个通信管道，分别对应了两个用户文件系统，可以在用 df -aT 对照确认：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">df</span> -aT|grep -i fuse</span><br><span class="line">none                fusectl                          0       0         0    - /sys/fs/fuse/connections</span><br><span class="line">fuse_demo sourcedir fuse.fuse_demo sourcedir         0       0         0    - /tmp/d1</span><br><span class="line">fuse_demo sourcedir fuse.fuse_demo sourcedir         0       0         0    - /tmp/d2</span><br></pre></td></tr></table></figure><p>每个 Uniqe ID 名录下，有若干个文件，通过这些文件，我们可以获取到当前用户文件系统的状态，或跟 fuse 文件系统交互，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@develop ~]# <span class="built_in">ls</span> -l /sys/fs/fuse/connections/36</span><br><span class="line">total 0</span><br><span class="line">--w-------. 1 user1 user1 0 Oct 30 14:42 abort</span><br><span class="line">-rw-------. 1 user1 user1 0 Oct 30 14:42 congestion_threshold</span><br><span class="line">-rw-------. 1 user1 user1 0 Oct 30 14:42 max_background</span><br><span class="line">-r--------. 1 user1 user1 0 Oct 30 14:42 waiting</span><br></pre></td></tr></table></figure><ul><li>waiting 文件：cat 一下就能获取到当前正在处理的 IO 请求数；</li><li>abort 文件：该文件写入任何字符串，都会终止这个用户文件系统和上面所有的请求；</li></ul><ol start="3"><li>挂载用户文件系统</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户态文件系统程序名 mountpoint [options] </span><br></pre></td></tr></table></figure><ol start="4"><li>卸载用户文件系统</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusermount -u mountpoint</span><br></pre></td></tr></table></figure><p>FUSE 的作用在于使用户能够绕开内核代码来编写文件系统，但是请注意，文件系统要实现对具体的设备的操作的话必须要使用设备驱动提供的接口，而设备驱动位于内核空间，这时可以直接读写块设备文件，就相当于只把文件系统摘到用户态，用户直接管理块设备空间。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvZnVzZS5odG1s">Linux内核官方FUSE介绍<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vYXJ0aWNsZS82NTVjMDg5M2VkMTUwZmY2NWYyYjdhMTZm">FUSE 文件系统<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMmI3N2QwYmJjNDM=">FUSE(Filesystem in Userspace)<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、FUSE基本概念&quot;&gt;&lt;a href=&quot;#一、FUSE基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、FUSE基本概念&quot;&gt;&lt;/a&gt;一、FUSE基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-FUSE-是什么&quot;&gt;&lt;a href=&quot;#1-1-FUSE-是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 FUSE 是什么&quot;&gt;&lt;/a&gt;1.1 FUSE 是什么&lt;/h2&gt;&lt;p&gt;FUSE 是 Filesystem in Userspace 的缩写，也就是常说的&lt;strong&gt;用户态文件系统&lt;/strong&gt;。&lt;br&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvZmlsZXN5c3RlbXMvZnVzZS5odG1s&quot;&gt;Linux内核官方文档&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;对 FUSE 的解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="FUSE" scheme="https://blog.kjlcloud.com/categories/FUSE/"/>
    
    
    <category term="FUSE" scheme="https://blog.kjlcloud.com/tags/FUSE/"/>
    
  </entry>
  
  <entry>
    <title>C++ 智能指针</title>
    <link href="https://blog.kjlcloud.com/2024/09/10/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://blog.kjlcloud.com/2024/09/10/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2024-09-10T02:10:31.000Z</published>
    <updated>2025-03-04T09:04:11.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、智能指针简介"><a href="#一、智能指针简介" class="headerlink" title="一、智能指针简介"></a>一、智能指针简介</h1><h2 id="1-1-为什么需要智能指针"><a href="#1-1-为什么需要智能指针" class="headerlink" title="1.1 为什么需要智能指针"></a>1.1 为什么需要智能指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态申请资源后忘记释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UseRawPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发生异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> str;<span class="comment">// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用传统指针时，需要手动分配和释放内存，这可能会导致内存泄漏（未释放已分配的内存）或释放后的野指针（指向已释放的内存）。智能指针通过自动内存管理来帮助解决这些问题，确保在不再需要内存时自动释放它。</p><span id="more"></span><h2 id="1-2-智能指针思想"><a href="#1-2-智能指针思想" class="headerlink" title="1.2 智能指针思想"></a>1.2 智能指针思想</h2><p>智能指针是在<code>&lt;memory&gt;</code>头文件中的 <code>std</code> 命名空间中定义的。 将智能指针抽象成一个对象，由该对象管理动态申请的内存资源，当该对象出作用域析构时，如果引用计数减到0，则连着将动态申请的内存free。</p><p><strong>实现智能指针关键点</strong></p><ul><li>RAII</li><li>支持像指针一样使用</li></ul><p>RAII 是 “资源获取即初始化”（Resource Acquisition Is Initialization）的缩写，旨在通过对象生命周期的管理来确保资源（如内存、文件句柄、数据库连接等）的正确获取和释放。RAII 的核心思想是，资源的获取操作应该与对象的初始化操作绑定在一起，资源的释放应该与对象的销毁操作绑定在一起。这意味着在对象的构造函数中获取资源，在对象的析构函数中释放资源，从而确保资源的正确管理。</p><p>RAII 有以下关键特点：</p><ol><li><strong>资源管理封装：</strong> RAII 鼓励将资源的管理和使用封装在对象中，以确保资源在对象的生命周期内正确获取和释放。这允许开发人员不必手动记住释放资源的细节。</li><li><strong>自动化资源释放：</strong> 当对象超出其作用域范围时，其析构函数自动被调用，从而自动释放与资源相关的资源，无论是通过正常的代码路径还是异常路径。</li><li><strong>异常安全性：</strong> 使用 RAII 可以确保即使在发生异常时，资源也会被正确释放，从而避免资源泄漏。</li><li><strong>代码可读性：</strong> RAII 使代码更加清晰和易于理解，因为资源管理逻辑被封装在对象的构造和析构中，而不是分散在代码中。</li></ol><h1 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h1><h2 id="2-1-面临问题"><a href="#2-1-面临问题" class="headerlink" title="2.1 面临问题"></a>2.1 面临问题</h2><p><code>auto_ptr</code> 是c++ 98定义的智能指针模板,C++11 后auto_ptr 已经被“抛弃”，已使用unique_ptr替代。</p><p><strong>auto_ptr 被C++11抛弃的主要原因</strong></p><ol><li><p>拷贝构造或者赋值采用资源管理器转移思想，存在被拷贝对象悬空问题</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Date&gt; <span class="title">d1</span><span class="params">(<span class="keyword">new</span> Date(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;Date&gt; <span class="title">d2</span><span class="params">(<span class="keyword">new</span> Date(<span class="number">2023</span>,<span class="number">11</span>,<span class="number">11</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">d1 = d2;</span><br><span class="line">cout &lt;&lt; d<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// 打印空指针，此时继续使用d2访问数据会存在问题</span></span><br></pre></td></tr></table></figure></li><li><p>在STL中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;auto_ptr&lt;string&gt;&gt; v;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m s1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">s2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m s2&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s1));</span><br><span class="line">v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s2));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[0]：&quot;</span> &lt;&lt;  *v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[1]：&quot;</span> &lt;&lt;  *v[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">1</span>];<span class="comment">// 风险，如果进行赋值，存在悬空问题。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[0]：&quot;</span> &lt;&lt;  *v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v[1]：&quot;</span> &lt;&lt;  *v[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 程序崩溃，非法访问内存</span></span><br></pre></td></tr></table></figure></li><li><p>不支持对象数组的内存管理</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>; <span class="comment">// No matching constructor for initialization of &#x27;auto_ptr&lt;int[]&gt;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-模拟实现"><a href="#2-2-模拟实现" class="headerlink" title="2.2 模拟实现"></a>2.2 模拟实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      T* _ptr;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(T *p = <span class="number">0</span>)</span> : _ptr(p) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">auto_ptr</span>(auto_ptr &amp;a) : _ptr(a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">      auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr &amp;__p) &#123;</span><br><span class="line">          <span class="built_in">reset</span>(__p.<span class="built_in">release</span>());</span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将auto_ptr内部指针设置为空指针，而不破坏当前由auto_ptr所指向的对象。函数返回调用之前所指向的对象。</span></span><br><span class="line">      <span class="function">T *<span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          T *tmp = _ptr;</span><br><span class="line">          _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">return</span> tmp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (_ptr != p)</span><br><span class="line">              <span class="keyword">delete</span> _ptr;</span><br><span class="line">          _ptr = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> *_ptr;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> _ptr;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h1 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h1><ul><li><p>唯一拥有：<code>unique_ptr</code> 是<strong>独占所有权</strong>的智能指针，意味着在任何时刻只能有一个 <code>unique_ptr</code> 拥有某个对象的所有权。这也确保了对象不会被多个指针共享，避免了重复释放内存的风险。</p></li><li><p>自动释放：当 <code>unique_ptr</code> 超出其作用域时，会自动调用 <code>delete</code> 释放所管理的对象。这减少了内存泄漏的风险。</p></li><li><p>不支持拷贝：<code>unique_ptr</code> 不允许拷贝，防止两个指针指向同一个对象。</p></li><li><p>支持移动语义：可以通过 <code>std::move</code> 将 <code>unique_ptr</code> 转移到另一个指针，这样原来的指针就失去了对对象的所有权。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      T *_ptr;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> : _ptr(p) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">      unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;o) : _ptr(o.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">          <span class="built_in">reset</span>();</span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr &amp;&amp;o) &#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;o)&#123;</span><br><span class="line">          <span class="built_in">reset</span>(o.<span class="built_in">release</span>());  </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          T *tmp = _ptr;</span><br><span class="line">          _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">return</span> tmp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (_ptr != p)</span><br><span class="line">              <span class="keyword">delete</span> _ptr;</span><br><span class="line">          _ptr = p;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      ~<span class="built_in">unique_ptr</span>() &#123; <span class="keyword">delete</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;x)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">          std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_ptr, x._ptr);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">          __glibcxx_assert(<span class="built_in">get</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">return</span> *<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">          __glibcxx_assert(<span class="built_in">get</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span> == <span class="built_in">get</span>() ? <span class="literal">false</span> : <span class="literal">true</span>; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h1 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h1><ul><li><p><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可共享对一个对象的所有权，并共同负责管理该对象的生命周期。当最后一个 <code>shared_ptr</code> 被销毁时，对象的生命周期才会结束。</p></li><li><p><strong>引用计数</strong>：每当创建一个新的 <code>shared_ptr</code> 指向同一对象时，引用计数会增加；每当 <code>shared_ptr</code> 被销毁或重置时，引用计数会减少。当引用计数降为零时，所指向的对象会被销毁。</p></li><li><p><strong>线程安全</strong>：<strong>对 <code>shared_ptr</code> 本身的操作是线程安全的</strong>，引用计数的增加和减少是线程安全的。<strong>对所指对象的操作不一定是线程安全的</strong>，如果多个线程需要同时读取或修改由 <code>shared_ptr</code> 所管理的对象，需要自己管理该对象的线程安全，例如使用互斥锁。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : _ptr(ptr), _pcount(new int(<span class="number">1</span>)), _pmtx(new mutex) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放资源</span></span><br><span class="line"><span class="comment">    Release() 方法减少引用计数，并根据引用计数的值来判断是否需要删除指向的堆内存对象和引用计数对象。</span></span><br><span class="line"><span class="comment">    在操作之前，我们使用互斥量 _pmtx 进行加锁，以保证线程安全。*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">                <span class="comment">// 删除器进行删除</span></span><br><span class="line">                _del(_ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> _pcount;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (deleteFlag) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pmtx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pmtx-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*_pcount);</span><br><span class="line">        _pmtx-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">            : _ptr(sp._ptr), _pcount(sp._pcount), _pmtx(sp._pmtx) &#123;</span><br><span class="line">        <span class="built_in">AddCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载</span></span><br><span class="line">    shared_ptr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr != sp._ptr) &#123;</span><br><span class="line">            <span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">            _ptr = sp._ptr;</span><br><span class="line">            _pcount = sp._pcount;</span><br><span class="line">            _pmtx = sp._pmtx;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">AddCount</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator*() 重载</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator-&gt;() 重载</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get() 方法</span></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use_count() 方法</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_pcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap() 方法，交换 2 个 shared_ptr 智能指针的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&lt;T&gt; &amp;sp)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(_ptr, sp._ptr);</span><br><span class="line">        std::<span class="built_in">swap</span>(_pcount, sp._pcount);</span><br><span class="line">        std::<span class="built_in">swap</span>(_pmtx, sp._pmtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset() 方法，重置 shared_ptr 智能指针对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放原有资源</span></span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值</span></span><br><span class="line">        _ptr = ptr;</span><br><span class="line">        _pcount = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">        _pmtx = <span class="keyword">new</span> mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;           <span class="comment">// 指向堆内存对象的指针</span></span><br><span class="line">    <span class="type">int</span> *_pcount;      <span class="comment">// 引用计数的指针</span></span><br><span class="line">    mutex *_pmtx;      <span class="comment">// 保护引用计数的互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装器</span></span><br><span class="line">    function&lt;<span class="type">void</span>(T *)&gt; _del = [](T *ptr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lambda delete:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-1-函数模版make-shared"><a href="#4-1-函数模版make-shared" class="headerlink" title="4.1 函数模版make_shared"></a>4.1 函数模版make_shared</h2><p><code>shared_ptr </code>需要维护引用计数的信息：</p><ul><li><p>强引用, 用来记录当前有多少个存活的 shared_ptrs 正共享该对象，共享的对象会在最后一个强引用离开的时候销毁( 也可能释放)</p></li><li><p>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs.，当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)。</p></li></ul><p><strong>优点1 提高内存分配效率</strong></p><p>通过使用原始的 <code>new</code>运算符分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块，总共需要分配2次内存空间。</p><img src="内存图1.png" alt="内存图1" style="zoom:50%;" /><p><code>make_shared</code> 只需要<strong>单次内存分配</strong>，提高了性能，并减少了内存碎片。</p><img src="内存图2.png" alt="内存图2" style="zoom:50%;" /><p><strong>优点2 异常安全</strong></p><p>使用 <code>new</code> 直接创建对象时，如果在 <code>std::shared_ptr</code> 构造之前抛出异常，可能会导致内存泄漏。而使用 <code>make_shared</code> 可以避免这种情况，因为对象的分配和智能指针的构造是原子操作，不会中途出现内存泄漏的问题。</p><p><strong>缺点1 对象构造函数是保护或私有时,无法使用 <code>make_shared</code></strong></p><p><strong>缺点2 对象的内存可能无法及时回收</strong></p><p><code>make_shared</code> 只分配一次内存，减少了内存分配的开销，使得控制块和托管对象在同一内存块上分配。而控制块是由 shared_ptr 和 weak_ptr 共享的，因此两者共同管理着这个内存块（托管对象 + 控制块）。当强引用计数为 0 时，托管对象被析构（即析构函数被调用），但内存块并未被回收，只有等到最后一个 weak_ptr 离开作用域时，弱引用也减为 0 才会释放这块内存块。原本强引用减为 0 时就可以释放的内存, 现在变为了强引用和弱引用都减为 0 时才能释放, 意外的延迟了内存释放的时间。这对于内存要求高的场景来说，是一个需要注意的问题。</p><h2 id="4-2-类模版enable-shared-from-this"><a href="#4-2-类模版enable-shared-from-this" class="headerlink" title="4.2 类模版enable_shared_from_this"></a>4.2 类模版enable_shared_from_this</h2><p><code>enable_shared_from_this</code>是一个模板类，定义于头文件<code>&lt;memory&gt;</code>。 <code>enable_shared_from_this</code> 能让一个对象（假设其名为 t ，且已被一个 <code>shared_ptr</code> 对象 pt 管理）<strong>安全地创建指向自身的 shared_ptr 智能指针</strong>（假设名为 pt1, pt2, … ） ，它们与 pt <strong>共享对象 t 的所有权</strong>。</p><p>​    若一个类 T 继承<code>enable_shared_from_this&lt;T&gt; </code>，则会为该类 T 提供成员函数 <code>shared_from_this </code>。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Bad &#123;</span><br><span class="line">public:</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad());</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;bp1.use_count() = &quot; &lt;&lt; bp1.use_count() &lt;&lt; std::endl; // 输出1</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; std::endl; // 输出1</span><br><span class="line">    </span><br><span class="line">    // 进程崩溃，对象析构了2次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncWorker</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;AsyncWorker&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动一个异步任务，在线程中执行</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        std::<span class="built_in">thread</span>([self] &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            self-&gt;<span class="built_in">onTaskComplete</span>();</span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onTaskComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task complete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 这里可以访问对象的成员或调用其他方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AsyncWorker</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;AsyncWorker destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 AsyncWorker 对象并通过 shared_ptr 管理</span></span><br><span class="line">        std::shared_ptr&lt;AsyncWorker&gt; worker = std::<span class="built_in">make_shared</span>&lt;AsyncWorker&gt;();</span><br><span class="line">        worker-&gt;<span class="built_in">startAsyncTask</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待异步任务完成</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 主线程等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 程序结束，确保对象正确销毁</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">// 让 detachment 线程输出 &quot;destroyed&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li><p><strong>安全的引用管理</strong>： 如果类中的某些方法需要返回一个 <code>shared_ptr</code> 指向该类的实例，而调用方已经拥有一个 <code>shared_ptr</code>，直接返回 <code>this</code> 会产生问题，因为 <code>this</code> 不是智能指针。如果多个地方都创建 <code>shared_ptr</code>，对象可能会在引用计数不一致的情况下被提前释放。通过 <code>enable_shared_from_this</code>，可以确保同一个对象的所有 <code>shared_ptr</code> 共享相同的引用计数。</p></li><li><p><strong>异步操作或回调</strong>： 在异步操作（如网络请求、I&#x2F;O 操作、线程回调）中，如果想确保对象在操作完成之前不会被销毁，可以使用 <code>shared_from_this()</code> 在回调中安全持有对象的 <code>shared_ptr</code>，从而延长对象的生命周期，防止它在异步操作完成前被销毁。</p></li></ul><p><strong>注意事项</strong></p><ul><li><code>shared_from_this()</code> 只能在对象已经通过 <code>shared_ptr</code> 管理时调用。如果在一个尚未通过 <code>shared_ptr</code> 管理的对象上调用 <code>shared_from_this()</code>，则会导致运行时错误（<code>std::bad_weak_ptr</code> 异常）。</li><li>当你希望某个对象能够通过多个地方持有它的 <code>shared_ptr</code> 时，继承 <code>enable_shared_from_this</code> 可以避免出现多个 <code>shared_ptr</code> 独立管理同一对象的情况。</li></ul><h1 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h1><ul><li><p><strong>不管理生命周期</strong>：指向一个由<code>shared_ptr</code>管理的对象，但<strong>不会改变shared_ptr的引用计数</strong>。</p></li><li><p><strong>访问管理对象</strong>：<code>weak_ptr</code> 不能直接访问所管理的对象，但可以通过 <code>lock()</code> 方法获取一个有效的 <code>shared_ptr</code>，然后访问对象。</p></li></ul><h2 id="5-1-循环引用"><a href="#5-1-循环引用" class="headerlink" title="5.1 循环引用"></a>5.1 循环引用</h2><p>循环引用：指两个或多个对象通过 <code>shared_ptr</code> 相互引用，导致它们的引用计数永远不会降为零，从而引发内存泄漏。</p><img src="循环引用1.png" alt="循环引用1" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; ptrB;  <span class="comment">// 指向 B 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; ptrA;  <span class="comment">// 指向 A 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 和 B 互相引用</span></span><br><span class="line">    a-&gt;ptrB = b;</span><br><span class="line">    b-&gt;ptrA = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 这里不会调用析构函数，因为循环引用导致引用计数无法降为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>weak_ptr</code>解决循环引用问题</p><img src="循环引用2.png" alt="循环引用2" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; ptrB;  <span class="comment">// 指向 B 的 shared_ptr</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;A&gt; ptrA;  <span class="comment">// 使用 weak_ptr 代替 shared_ptr</span></span><br><span class="line">    <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;ptrB = b;</span><br><span class="line">    b-&gt;ptrA = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 正常调用析构函数，解决了循环引用问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-相关成员函数"><a href="#5-2-相关成员函数" class="headerlink" title="5.2 相关成员函数"></a>5.2 相关成员函数</h2><p><code>bool expired() const noexcept;</code></p><p>作用：检查 <code>weak_ptr</code> 是否已失效。如果对象已无效（对应的 <code>shared_ptr</code> 引用计数为 0），返回 true，否则返回 false。</p><p><code>shared_ptr&lt;element_type&gt; lock() const noexcept;</code></p><p>作用：尝试获取指向对象的 <code>shared_ptr</code>。如果对象还有效，则返回一个指向该对象的 <code>shared_ptr</code>；如果对象已无效或<code>weak_ptr</code>指向空，则返回空的 <code>shared_ptr</code>。</p><p><code>void reset() noexcept;</code></p><p>作用：将 <code>weak_ptr</code> 置为空。</p><p><code>long int use_count() const noexcept;</code></p><p>作用：返回与 <code>weak_ptr</code> 关联的 <code>shared_ptr</code> 的引用计数（即还有多少个 <code>shared_ptr</code> 引用该对象）。如果对象已失效或<code>weak_ptr</code>指向空，则返回 0。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、智能指针简介&quot;&gt;&lt;a href=&quot;#一、智能指针简介&quot; class=&quot;headerlink&quot; title=&quot;一、智能指针简介&quot;&gt;&lt;/a&gt;一、智能指针简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么需要智能指针&quot;&gt;&lt;a href=&quot;#1-1-为什么需要智能指针&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么需要智能指针&quot;&gt;&lt;/a&gt;1.1 为什么需要智能指针&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 动态申请资源后忘记释放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UseRawPointer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	string *str = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UseRawPointer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	string *str = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 发生异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; str;	&lt;span class=&quot;comment&quot;&gt;// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在使用传统指针时，需要手动分配和释放内存，这可能会导致内存泄漏（未释放已分配的内存）或释放后的野指针（指向已释放的内存）。智能指针通过自动内存管理来帮助解决这些问题，确保在不再需要内存时自动释放它。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
    <category term="智能指针" scheme="https://blog.kjlcloud.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ 多态</title>
    <link href="https://blog.kjlcloud.com/2024/08/13/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://blog.kjlcloud.com/2024/08/13/C-%E5%A4%9A%E6%80%81/</id>
    <published>2024-08-13T15:07:42.000Z</published>
    <updated>2025-03-04T08:57:49.719Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、多态基础"><a href="#一、多态基础" class="headerlink" title="一、多态基础"></a>一、多态基础</h1><h2 id="1-1-静态编联与动态编联"><a href="#1-1-静态编联与动态编联" class="headerlink" title="1.1 静态编联与动态编联"></a>1.1 静态编联与动态编联</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area: &quot;</span> &lt;&lt; <span class="built_in">get_area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h)</span><br><span class="line">            : _width(w), _height(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _width * _height; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _width;</span><br><span class="line">    <span class="type">float</span> _height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r) : _radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _radius * _radius * <span class="number">3.14</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape &amp;sp1 = rect;</span><br><span class="line">    Shape &amp;sp2 = cir;</span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">show</span>(); <span class="comment">// 输出0</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">show</span>(); <span class="comment">// 输出0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面代码发现，矩形和圆求出的面积都为0，与我们预期不符合，这是为什么呢，原因在于使用静态编联。</p><span id="more"></span><p><strong>静态编联(早绑定，静态绑定) ：编译期间就决定了具体调用哪个函数体，即使没有主程序，也知道程序中各个函数体之间的调用关系。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码采用的是静态编联，使用sp1调用show函数，show函数体内调用了get_area成员函数，</span></span><br><span class="line"><span class="comment">调用非静态成员函数时编译器会传入隐藏this指针，因为this是指向Shape，</span></span><br><span class="line"><span class="comment">所以调用Shape::get_area函数而不是Rectangle::get_area函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Shape &amp;sp1 = rect;</span><br><span class="line">sp<span class="number">1.</span><span class="built_in">show</span>();】</span><br></pre></td></tr></table></figure><p><strong>动态编联（晚绑定，动态绑定）：在运行期间决定具体调用哪个函数体。动态编联有多种实现方式，大多数编译器使用(虚函数和虚函数表）。</strong></p><h2 id="1-2-多态"><a href="#1-2-多态" class="headerlink" title="1.2 多态"></a>1.2 多态</h2><p>使用基类的指针或引用调用同一方法时，产生不同的行为，这是一种动态多态，大多数C++编译器通过虚函数实现。<font color=red >下文中提到的多态如没有单独说明，则都是指通过虚函数实现的动态多态。</font></p><p><strong>多态构成必须满足下面两个条件</strong>：</p><ol><li>必须通过基类的指针或者引用调用虚函数</li><li>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写(override)</li></ol><h2 id="1-3-虚函数"><a href="#1-3-虚函数" class="headerlink" title="1.3 虚函数"></a>1.3 虚函数</h2><p>被<code>virtual</code>修饰的类非静态成员函数就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//这是一个虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虚函数说明:<br>• 静态成员函数、构造函数、拷贝构造函数不能是虚函数<br>• 析构函数可以是虚函数<br>• 赋值函数通常不定义为虚函数<br>• 访问控制可以任意（public、protected、private ）</p><h2 id="1-4-虚函数重写-override"><a href="#1-4-虚函数重写-override" class="headerlink" title="1.4 虚函数重写(override)"></a>1.4 虚函数重写(override)</h2><p>虚函数重写(override)：派生类中有一个跟基类完全相同的虚函数(函数名、返回值类、参数列表相同)。</p><p>说明：派生类中<code>virtual</code>关键字可以不写，但不推荐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area: &quot;</span> &lt;&lt; <span class="built_in">get_area</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h)</span><br><span class="line">            : _width(w), _height(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _width * _height; &#125; <span class="comment">// 没写virtual</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _width;</span><br><span class="line">    <span class="type">float</span> _height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> r) : _radius(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">get_area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _radius * _radius * <span class="number">3.14</span>; &#125; <span class="comment">// 没写virtual</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> _radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">cir</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Shape &amp;sp1 = rect;</span><br><span class="line">    Shape &amp;sp2 = cir;</span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">show</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">show</span>(); <span class="comment">// 输出 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发过程中，基类与派生类可能不是同一个人写的，如果基类是虚函数，而派生类忘记写<code>virtual</code>关键字没构成多态可能带来一些不可预料问题。因此，基类是虚函数的情况下,派生类不强制需要写<code>virtual</code>关键字，具有一定安全作用。</p><h3 id="1-4-1-虚函数重写两个例外"><a href="#1-4-1-虚函数重写两个例外" class="headerlink" title="1.4.1 虚函数重写两个例外"></a>1.4.1 虚函数重写两个例外</h3><p><strong>虚函数重写有两个例外，一个是协变，一个是析构函数的重写，这两种也构成虚函数重写。</strong></p><p>协变：派生类中重写（override）基类方法时，返回类型可以是基类方法返回类型(类型必须为指针或引用)的派生类。协变可以使代码更加灵活。</p><p>实现协变需满足以下条件：</p><ul><li>基类中的函数必须是虚函数</li><li>派生类中重写的函数必须具有相同的函数签名（函数名、参数列表和常量性）。</li><li>派生类中重写的函数的返回类型必须是基类函数返回类型的派生类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base &amp;<span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived &amp;<span class="title">test</span><span class="params">()</span> <span class="comment">// 协变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived b;</span><br><span class="line">    Base &amp;ref = b;</span><br><span class="line">    ref.<span class="built_in">test</span>(); <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文中提到析构函数是可以为虚函数的，尤其是存在继承关系的时候，建议将基类析构函数定义为虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Base()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Derived()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Base</span>()</span><br></pre></td></tr></table></figure><p>调用<code>delete p</code>时，我们本意根据指针(引用)指向的对象类型来选择对应的析构函数，但结果是根据指针(引用)的类型的来选择对应的析构函数，导致对象没有正确的析构，存在资源泄漏。有人立马想到可以将基类析构函数定义为虚函数解决这个问题，但是重写条件之一是函数名要相同。基类析构函数与派生类析构函数名明显不相同，编译器为了支持析构函数能为虚函数，对析构函数名做了特殊处理，编译后析构函数的名统一处理成destructor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Derived()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Derived</span>()</span><br><span class="line">~<span class="built_in">Base</span>()</span><br></pre></td></tr></table></figure><p>通过将基类析构函数定义为虚函数，解决继承体系中析构问题。</p><h2 id="1-5-override和final关键字"><a href="#1-5-override和final关键字" class="headerlink" title="1.5 override和final关键字"></a>1.5 override和final关键字</h2><h3 id="1-5-1-override"><a href="#1-5-1-override" class="headerlink" title="1.5.1 override"></a>1.5.1 override</h3><p><code>override</code>关键字用于显式地声明一个派生类中的虚函数重写了基类中的虚函数。它的主要作用是提高代码的可读性和安全性，确保派生类的函数确实覆盖了基类中的虚函数。</p><p>使用<code>override</code>的好处：</p><ul><li><p>避免拼写错误：如果你在派生类中希望重写基类的一个虚函数，但不小心拼写错误或者参数列表不匹配，编译器会报错，提示你并没有成功重写基类的函数。</p></li><li><p>明确意图：通过在派生类的函数后面加上 <code>override</code>，明确表示你的意图是要重写基类中的虚函数，这有助于代码的可读性。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span> <span class="comment">// 使用override关键字</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>();  <span class="comment">// 调用的是 Derived 类中的 display() 方法</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时报错：non-virtual member function marked ‘override’ hides virtual member function</p><h3 id="1-5-2-final"><a href="#1-5-2-final" class="headerlink" title="1.5.2 final"></a>1.5.2 final</h3><p><code>final</code>关键字用于两个主要场景：<strong>1. 防止类被继承</strong>，如果在类声明中使用 <code>final</code>，则表示该类不能被进一步继承。<strong>2. 防止虚函数被重写</strong>，如果在类的虚函数声明后使用 <code>final</code>，则表示该虚函数不能在派生类中被重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;; <span class="comment">// 编译报错，Base类不能被继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 下面这段代码将会导致编译错误，因为 display() 函数是 final</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived display&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、多态原理"><a href="#二、多态原理" class="headerlink" title="二、多态原理"></a>二、多态原理</h1><h2 id="2-1-虚函数表指针与虚函数表"><a href="#2-1-虚函数表指针与虚函数表" class="headerlink" title="2.1 虚函数表指针与虚函数表"></a>2.1 虚函数表指针与虚函数表</h2><p><strong>虚函数表指针(虚表指针，vfptr)</strong>：如果一个类有虚函数，这个类创建的对象中会增加一个指针，指向该对象所属类的虚函数表。在调用虚函数时，程序通过该虚函数表指针（vfptr）找到对应的虚函数表（vtable），再根据虚函数表中的条目找到并调用具体的虚函数实现。</p><p>说明：</p><ul><li>C++的编译器为了性能会将虚表指针存在于对象最前面的位置，通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的虚函数，在多层继承或是多重继承的情况下， 具有极高性能。</li><li>单一继承下对象只有一个虚表指针，多重继承&#x2F;虚拟继承情况下对象会有多个虚表指针。</li></ul><p><strong>虚函数表(虚表，vtable)</strong>：一个指针数组，存放对应虚函数地址。当一个类定义了虚函数时，编译器为该类生成一个虚表，其中每个条目对应一个虚函数地址。</p><p>说明：</p><ul><li>虚表在编译期间生成，编译期间虚函数的地址已经存在。</li><li>对象中虚表指针是在构造函数的初始化列表中完成赋值的。</li><li>同一类所有对象共享一个虚表。</li><li>继承中派生类会拷贝一份基类的虚表，如果派生类重写了某个虚函数，则用派生类虚函数地址覆盖虚表中基类函数地址。</li><li>派生类新增的虚函数按声明顺序尾插在虚表中。</li><li>派生类对象赋值给基类对象时不会拷贝虚表指针，赋值后基类对象虚表指针还是指向基类。 </li><li>MSVC编译器会存放<code>nullptr</code>作为虚表中最后一个元素，方便虚表遍历，其它编译器不一定存放。 </li><li>单一继承下一个类只有一个虚表，多重继承&#x2F;虚拟继承情况下一个类会有多个虚表。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">K</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/ec227b59e23d48ef97e96eacb33faf94.png" alt="在这里插入图片描述"></p><h2 id="2-2-函数调用的编译"><a href="#2-2-函数调用的编译" class="headerlink" title="2.2 函数调用的编译"></a>2.2 函数调用的编译</h2><p><strong>一个对象（变量）的静态类型就是其声明类型，在编译期间就可以确定。一个对象（变量）动态类型就是指程序执行过程中对象（指针或引用）实际所指对象的类型，只有在运行时才能确定。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">Derived derived; <span class="comment">// derived的静态与动态类型都为Derived</span></span><br><span class="line">Base * p = &amp;derived；<span class="comment">// p的静态类型为Base*，动态类型Derived*</span></span><br><span class="line">Base &amp; ref = derived；<span class="comment">// p的静态类型为Base&amp;，动态类型Derived&amp;</span></span><br></pre></td></tr></table></figure><p>以编译<code>p-&gt;f()</code>为例子</p><ol><li>确定p的静态类型<code>Base*</code></li><li>在Base类中，寻找名字为f，且参数可以匹配的函数</li><li>若找不到，编译错误</li><li>若找到，判断函数是否为virtual函数<br>a) 不是虚函数，编译为<code>Base::f(p)</code><br>b) 是虚函数，编译为<code>(*p-&gt;vfptr)[index]((void*)p, ...)</code></li></ol><p>从上面步骤可以看到，若希望<code>p-&gt;f()或 ref.f()</code>合法，<code>p/ref</code>的静态类型中必须有匹配的函数f，即使匹配的f永远不被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base与Derived类定义参考2.1章节</span></span><br><span class="line"></span><br><span class="line">Base* p1 = <span class="keyword">new</span> Base;</span><br><span class="line">p1-&gt;<span class="built_in">F</span>(); <span class="comment">// 编译为 Base::F(p1)</span></span><br><span class="line">p1-&gt;<span class="built_in">G</span>(); <span class="comment">// 编译为 (*p1-&gt;vfptr)[1]((void*)p1)</span></span><br><span class="line">p1-&gt;<span class="built_in">K</span>(); <span class="comment">// 编译错误，K为protected，不能在类外调用</span></span><br><span class="line">p1-&gt;<span class="built_in">H</span>(); <span class="comment">// 编译错误，p1的静态类型为Base*，Base类中没有H函数</span></span><br><span class="line"></span><br><span class="line">Base* p2 = <span class="keyword">new</span> Derived;</span><br><span class="line">p2-&gt;<span class="built_in">G</span>();  <span class="comment">// 编译为 (*p2-&gt;vfptr)[1]((void*)p2)</span></span><br><span class="line">p2-&gt;<span class="built_in">K</span>(); <span class="comment">// 编译错误，K为protected，不能在类外调用</span></span><br><span class="line">p2-&gt;<span class="built_in">H</span>(); <span class="comment">// 编译错误，p1的静态类型为Base*，Base类中没有H函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// 编译为 (*p2-&gt;vfptr)[0]((void*)p2)</span></span><br><span class="line"><span class="keyword">delete</span> p1; <span class="comment">// 编译为 (*p1-&gt;vfptr)[0]((void*)p1)</span></span><br></pre></td></tr></table></figure><h2 id="2-3-虚函数的访问"><a href="#2-3-虚函数的访问" class="headerlink" title="2.3 虚函数的访问"></a>2.3 虚函数的访问</h2><p>在某个函数中调用另外一个函数规则如下：</p><ul><li>虚函数中访问的非虚函数：静态编联，使用本地版本</li><li>非虚函数中访问的虚函数：动态编联</li><li>虚函数中访问的虚函数：动态编联</li><li>构造函数不能为虚函数，在构造中调用虚函数采用静态编联，使用本地版本</li><li>析构函数可以为虚函数，在析构中调用虚函数采用静态编联，使用本地版本</li></ul><p>构造函数不能为虚函数原因：虚函数是为了根据不同的对象来产生不同的状态，但是前提是得有这个对象，而对象的产生必须依靠构造函数；其次，对象中虚表指针的初始化是在构造函数的初始化列表阶段，二者矛盾了。</p><p>在构造中调用虚函数采用静态编联原因：对象的构造顺序是先基类，后派生类。假设在基类的构造中调用一个虚函数使用动态编联，派生类重写了该虚函数，这个虚函数使用了派生类的数据。此时派生类还没有构造，结果将是不可预料的。</p><p>在析构中调用虚函数采用静态编联原因：对象的析构顺序是先派生类，后基类。假设在基类的析构中调用一个虚函数使用动态编联，派生类重写了该虚函数，这个虚函数使用了派生类的数据。此时派生类资源已经析构，结果将是不可预料的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; <span class="built_in">vf</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; <span class="built_in">vf</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::vf()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::vg()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">        <span class="built_in">nvh</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nvh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::nvh()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; <span class="built_in">vf</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123; <span class="built_in">vf</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vf</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::vf()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nvh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::nvh()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">vf</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">nj</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::vn()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">    p-&gt;<span class="built_in">vf</span>();</span><br><span class="line">    p-&gt;<span class="built_in">vg</span>();</span><br><span class="line"><span class="comment">//  p-&gt;nj(); 取消注释会编译错误，p的静态类型为Base*,Base类中没有nj函数</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">vg</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">nvh</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Derived::<span class="built_in">vf</span>()</span><br><span class="line">Base::<span class="built_in">vf</span>()</span><br></pre></td></tr></table></figure><p><code>Base *p = new Derived;</code><br>调用派生类的构造函数，派生类构造函数初始化列表阶段会调用基类的构造函数。基类构造函数调用vf虚函数，在构造中调用虚函数采用静态编联，即调用的基类的vf虚函数，输出<code>Base::vf()</code>。基类构造完后继续派生类构造，派生类构造调用vf虚函数采用静态编联，即调用的派生类的vf虚函数，输出<code>Derived::vf()</code>。</p><p><code>p-&gt;vf();</code><br>p的静态类型为Base*，Base类中有vf函数，vf为虚函数采用动态编联，p的动态类型为Derived*。调用派生类的vf虚函数，输出<code>Derived::vf()</code>。</p><p><code>p-&gt;vg();</code><br>p的静态类型为Base*，Base类中有vg函数，vg为虚函数采用动态编联，但是派生类没有重写vg， 调用基类的vg函数，先输出<code>&quot;Base::vg()&quot;</code>。vg虚函数中继续调用vf虚函数采用动态编联，即调用派生类vf虚函数，输出<code>&quot;Derived::vf()&quot;</code>。vg虚函数中继续调用nvh函数，nvh不是虚函数采用静态编联，因为vg为基类函数，所以调用基类的nvh函数，先输出<code>Base::nvh()</code>，nvh函数调用vf虚函数采用动态编联，即调用派生类vf虚函数，输出<code>&quot;Derived::vf()&quot;</code>。</p><p><code>delete p;</code><br>p的静态类型为Base*，Base类中析构函数为虚函数采用动态编联，调用派生类的析构函数，派生类析构函数调用vf虚函数，在析构中调用虚函数采用静态编联，所以调用的派生类的vf虚函数，输出<code>Derived::vf()</code>。派生类析构函数运行结束前编译器自动会调用基类析构函数，基类析构函数调用vf虚函数，在析构中调用虚函数采用静态编联，所以调用的基类的vf虚函数，输出<code>Base::vf()</code>。</p><h2 id="2-4-对象内存布局"><a href="#2-4-对象内存布局" class="headerlink" title="2.4 对象内存布局"></a>2.4 对象内存布局</h2><p>在含有虚函数的继承中对象内存布局较为复杂，我水平有限不能将其讲解的很清楚。推荐<code>陈皓</code>大佬两篇文章，相信看完后会对多态有更深的理解，也是对<code>陈皓</code>大佬最好的缅怀。<br><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTIxNjUuaHRtbA==">C++ 虚函数表解析<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTIxNzYuaHRtbA==">C++ 对象的内存布局<i class="fa fa-external-link-alt"></i></span></p><h1 id="三、多态进阶"><a href="#三、多态进阶" class="headerlink" title="三、多态进阶"></a>三、多态进阶</h1><h2 id="3-1-静态多态和动态多态"><a href="#3-1-静态多态和动态多态" class="headerlink" title="3.1 静态多态和动态多态"></a>3.1 静态多态和动态多态</h2><p><font color=red >上文中提到的多态是指通过虚函数实现的动态多态，多态分为静态多态和动态多态。</font><br><strong>多态性：相同的函数调用，执行不同的代码体，从而有不同的行为后果。</strong> </p><h3 id="3-1-1-静态多态"><a href="#3-1-1-静态多态" class="headerlink" title="3.1.1 静态多态"></a>3.1.1 静态多态</h3><p>静态多态：在编译时根据目标对象的静态类型和参数列表中参数的静态类型确定目标代码体，通过<strong>模版</strong>与<strong>函数重载</strong>实现。</p><p>模板：允许函数或类根据不同的类型进行实例化，从而在编译时确定具体的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 编译时模板类A会根据模版参数T的类型生成不同的类</span></span><br><span class="line">    A&lt;<span class="type">int</span>&gt; obj1;</span><br><span class="line">    A&lt;<span class="type">float</span>&gt; obj2;</span><br><span class="line">    </span><br><span class="line">    obj<span class="number">1.f</span>(); <span class="comment">// 输出i</span></span><br><span class="line">    obj<span class="number">2.f</span>(); <span class="comment">// 输出f</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载：允许多个同名函数具有不同的参数列表，编译器在编译时根据函数调用的参数类型选择适当的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;char&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 输出 int</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 输出 char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-动态多态"><a href="#3-1-2-动态多态" class="headerlink" title="3.1.2 动态多态"></a>3.1.2 动态多态</h3><p>动态多态：在运行时决定函数调用的具体实现。<br>• 根据目标对象的动态类型和参数表中参数的静态类型确定目标代码体。<br>（虚函数和虚函数表）<br>• 根据目标对象的动态类型和参数表中参数的动态类型确定目标代码体。<br>（C++不支持）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(A *)</span> </span>&#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B *)</span> </span>&#123; cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(A *)</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(B *)</span> </span>&#123; cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A* pa = &amp;b;</span><br><span class="line">    b.<span class="built_in">f</span>(pa); <span class="comment">// b的静态类型为B，参数pa静态类型为A*，B类中有f(A*)虚函数，采用动态编联，调用派生类的f(A *)函数，输出 3</span></span><br><span class="line">    pa-&gt;<span class="built_in">f</span>(pa); <span class="comment">// pa的静态类型为A*，参数pa的静态类型为A*，A类中有f(A*)虚函数，采用动态编联，调用派生类的f(A *)函数，输出 3</span></span><br><span class="line">    pa-&gt;<span class="built_in">f</span>(&amp;b); <span class="comment">// pa的静态类型为A*，参数&amp;b的静态类型为B*，A类中有f(B*)虚函数，采用动态编联，调用派生类的f(B *)函数，输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-虚拟的“拷贝构造函数”"><a href="#3-2-虚拟的“拷贝构造函数”" class="headerlink" title="3.2 虚拟的“拷贝构造函数”"></a>3.2 虚拟的“拷贝构造函数”</h2><p><img src="https://i-blog.csdnimg.cn/direct/d3b8737f432f427e9c46dffb58487306.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A&#123;&#125;;</span><br></pre></td></tr></table></figure><p>问题：如果有个位于A类继承树下的对象（可能为A&#x2F;B&#x2F;C…），现在希望提供一个统一接口，能拷贝出一个跟它一摸一样的对象。</p><p>因为需要根据对象类型拷贝出一个相同的对象，我们立马想到了拷贝构造函数，但是有两个问题，第一，拷贝构造函数不能为虚函数。第二，拷贝构造即便能为虚函数，各类中拷贝构造函数名也不一样，所以这个思路不行。我们想到可以在最顶层基类A中给一个函数，这个函数接受一个A*的参数，并根据实际指向类型调用对应类型拷贝构造函数，于是写出如下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A* <span class="title">A::copy</span><span class="params">(<span class="type">const</span> A &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(A) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(a);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(B) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(<span class="built_in">static_cast</span>&lt;B &amp;&gt;(a));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(C) == <span class="built_in">typeid</span>(a)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">C</span>(<span class="built_in">static_cast</span>&lt;C &amp;&gt;(a));</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码逻辑上没有问题，但难以适应变化，假设后续有派生类D、E…，需要不断在copy函数中增加新的类型判断。且对象具体类型识别需要RTTI，会有性能消耗。可以采用<strong>原型模式</strong>，在顶层基类A中提供一个名为clone虚函数，派生类中重写该虚函数解决前面的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">B</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;b); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> C *<span class="title">clone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">C</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C &amp;c); <span class="comment">// 自定义实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-3-使用继承和虚函数的不足"><a href="#3-3-使用继承和虚函数的不足" class="headerlink" title="3.3 使用继承和虚函数的不足"></a>3.3 使用继承和虚函数的不足</h2><p><strong>只使用继承与虚函数，难以适应多个方向的变化。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设F()有两种不同的变化，G()有三种不同的变化，H()有四种不同的变化，那么需要<code>2*3*4=24</code>个派生类才能适应上面要求，如果后续某个函数有更多变化或新增虚函数，代码将难以维护。所以通常使用<code>水平（关联、依赖）+ 继承</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImpF</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpF</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImpG</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpG</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImpH</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ImpH</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>(ImpF *pf, ImpG *pg, ImpH *ph)</span><br><span class="line">            : _pf(pf), _pg(pg), _ph(ph) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123; _pf-&gt;<span class="built_in">F</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123; _pg-&gt;<span class="built_in">G</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123; _ph-&gt;<span class="built_in">H</span>(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ImpF *_pf;</span><br><span class="line">    ImpG *_pg;</span><br><span class="line">    ImpH *_ph;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们定义ImpF、ImpG、ImpH三个基类，对于F()函数的两种变化只需要定义两个类继承ImpF类并重写F()函数即可，G()和H()依此类推，所以只需要定义<code>2+3+4=9</code>个派生类即可。Parent类中存放ImpF、ImpG、ImpH三个基类的指针。</p><h1 id="四、扩展知识"><a href="#四、扩展知识" class="headerlink" title="四、扩展知识"></a>四、扩展知识</h1><h2 id="4-1-具体类和抽象类"><a href="#4-1-具体类和抽象类" class="headerlink" title="4.1 具体类和抽象类"></a>4.1 具体类和抽象类</h2><p><strong>具体类：可以实例化对象的类</strong><br><strong>抽象类：为派生类提供更高层次的抽象，本身不能被实例化</strong></p><p>抽象类说明：<br>• 含有一个或多个纯虚函数。<br>• 抽象类的派生类如果不重写纯虚函数,则还是抽象类<br>• 纯抽象类（接口类）：除静态、构造等函数均为纯虚函数，且没有任何非静态成员变量</p><p><strong>纯虚函数：虚函数后面写上&#x3D;0</strong><br>语法：<br><code>virtual ReturnType Func（...） ［const］ = 0；</code> </p><p>纯虚函数说明：</p><ul><li>必须为类的非静态成员函数。</li><li>纯虚函数通常是用来定义接口的，基类不会给出实现，而是要求派生类提供具体的实现。在提供一些默认行为或者进行一些公共操作时，<strong>纯虚函数是可以有定义的，但是必须在类外实现。</strong></li></ul><p><code>Shape.h</code>文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;面积：&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Rectangle</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> w * h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若Shape:area有纯虚定义，则下边可省略</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Shape.cpp</code>文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给出纯虚定义</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Shape::area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-运行时类型识别-RTTI"><a href="#4-2-运行时类型识别-RTTI" class="headerlink" title="4.2 运行时类型识别(RTTI)"></a>4.2 运行时类型识别(RTTI)</h2><p>运行时类型识别 (Runtime Type Identification，RTTI)： 是是C++中的一种机制，它允许在程序运行过程中确定对象的类型。</p><h3 id="4-2-1-type-info"><a href="#4-2-1-type-info" class="headerlink" title="4.2.1 type_info"></a>4.2.1 type_info</h3><p><strong>type_info类</strong>：一个与类型信息相关类，在标准头文件typeinfo定义，主要用于在运行时提供有关对象类型的信息。它通常与<code>typeid运算符</code>结合使用，<code>typeid运算符</code>结果是一个与之关联的 type_info 对象的引用，以便在程序运行时确定对象的类型。</p><p>不能直接实例化type_info 类的对象，因为该类只有一个private拷贝构造函数和一个protected构造函数，获取type_info 对象的唯一方式是使用 typeid 运算符。</p><p>type_info 类提供了一个查看类型名称的方法<code>type_info::name()</code>，以及与其他 type_info对象之间比较的函数（<code>operator==</code> 和 <code>operator!=</code>）。</p><p><strong>说明：如果一个类有虚函数，则编译器在运行时会为这个类创建一个<code>type_info</code>对象，并将这个对象的地址存到该类虚表所在内存空间的前一个位置。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">K</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">G</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">H</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/353a877aa1fa4361bc830258d6eb9051.png" alt="在这里插入图片描述"></p><h3 id="4-2-2-typeid"><a href="#4-2-2-typeid" class="headerlink" title="4.2.2 typeid"></a>4.2.2 typeid</h3><p>用法：<br><code>typeid(type_name)</code><br><code>typeid(expr)</code></p><p>typeid 运算符允许在运行时确定对象的类，typeid 的结果是<code>const type_info&amp;</code>。 该值是对type_name或expr 的类型的 type_info 对象的引用。</p><p>说明：</p><ul><li>type_name&#x2F;expr是指针，则返回对应的静态类型</li><li>type_name&#x2F;expr是对象或引用，且含有虚函数，则返回对应的动态类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">typeid</span>(p) == <span class="built_in">typeid</span>(Base *); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">typeid</span>(p) == <span class="built_in">typeid</span>(Derived *); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">typeid</span>(*p) == <span class="built_in">typeid</span>(Base); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">typeid</span>(*p) == <span class="built_in">typeid</span>(Derived); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-dynamic-cast"><a href="#4-2-3-dynamic-cast" class="headerlink" title="4.2.3 dynamic_cast"></a>4.2.3 dynamic_cast</h3><p><strong>dynamic_cast运算符一般用于包含继承关系且含有虚函数的向下类型转换。</strong></p><p>转换过程（假设p为指向基类的指针）：</p><ol><li>计算指针所指的对象的虚表地址，存放对象类型信息的<code>type_info *</code>指针在虚表前面,  然后解引用获取type_info信息，即 <code>*(type_info*)p-&gt;vfptr[-1]</code></li><li>静态推导向下转型的目标类型的type_info信息，即获取类XX的type_info信息</li><li>比较两个type_info信息，若2）中的类型信息与1）中的类型信息相等或是其基类类型，则返回相应的对象或子对象的地址，否则返回nullptr</li></ol><h3 id="4-2-4-RTTI缺点"><a href="#4-2-4-RTTI缺点" class="headerlink" title="4.2.4 RTTI缺点"></a>4.2.4 RTTI缺点</h3><ul><li>内存开销：RTTI 会为每个启用的类添加额外的元数据（如 type_info 对象），这会增加内存使用量。</li><li>运行时开销：使用 dynamic_cast 和 typeid 时，程序需要在运行时进行类型检查和比较，这会导致额外的运行时开销，特别是在类型层次复杂或转换频繁时，性能影响可能较大。</li><li>可移植性问题：尽管 RTTI 是 C++ 标准的一部分，但不同编译器对 RTTI 的实现可能有所不同。这意味着在跨平台开发时，可能会遇到与 RTTI 相关的可移植性问题。</li></ul>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、多态基础&quot;&gt;&lt;a href=&quot;#一、多态基础&quot; class=&quot;headerlink&quot; title=&quot;一、多态基础&quot;&gt;&lt;/a&gt;一、多态基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-静态编联与动态编联&quot;&gt;&lt;a href=&quot;#1-1-静态编联与动态编联&quot; class=&quot;headerlink&quot; title=&quot;1.1 静态编联与动态编联&quot;&gt;&lt;/a&gt;1.1 静态编联与动态编联&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Shape&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;area: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;get_area&lt;/span&gt;() &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_area&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Rectangle&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Rectangle&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; w, &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; h)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            : _width(w), _height(h) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_area&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _width * _height; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; _width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; _height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Circle&lt;/span&gt; : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Shape &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Circle&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; r) : _radius(r) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_area&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _radius * _radius * &lt;span class=&quot;number&quot;&gt;3.14&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;float&lt;/span&gt; _radius;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Rectangle &lt;span class=&quot;title&quot;&gt;rect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Circle &lt;span class=&quot;title&quot;&gt;cir&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Shape &amp;amp;sp1 = rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Shape &amp;amp;sp2 = cir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sp&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;built_in&quot;&gt;show&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// 输出0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sp&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;built_in&quot;&gt;show&lt;/span&gt;(); &lt;span class=&quot;comment&quot;&gt;// 输出0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行上面代码发现，矩形和圆求出的面积都为0，与我们预期不符合，这是为什么呢，原因在于使用静态编联。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="多态" scheme="https://blog.kjlcloud.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>C++ 继承</title>
    <link href="https://blog.kjlcloud.com/2024/08/12/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://blog.kjlcloud.com/2024/08/12/C-%E7%BB%A7%E6%89%BF/</id>
    <published>2024-08-11T16:12:02.000Z</published>
    <updated>2024-08-11T16:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、继承概念与语法"><a href="#一、继承概念与语法" class="headerlink" title="一、继承概念与语法"></a>一、继承概念与语法</h1><h2 id="1-1-继承是什么"><a href="#1-1-继承是什么" class="headerlink" title="1.1 继承是什么"></a>1.1 继承是什么</h2><p>&emsp;继承（Inheritance）是面向对象编程程序设计（OOP）的一个重要特征。<strong>它允许一个类（派生类）继承另一个类（基类）的属性和方法</strong>，并可以在此基础上修改已有的功能或增加新的功能。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程，继承是类设计层次的代码复用。</p><span id="more"></span><h2 id="1-2-继承语法"><a href="#1-2-继承语法" class="headerlink" title="1.2 继承语法"></a>1.2 继承语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;: [继承方式] &lt;基类名&gt;    <span class="comment">// 单继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// member list</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;: [继承方式] &lt;基类名<span class="number">1</span>&gt;, [继承方式] &lt;基类名<span class="number">2</span>&gt;,...   <span class="comment">// 多继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// member list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单继承：只有一个基类<br>多继承：有两个或两个以上基类</p><p>继承方式：<code>public</code>、<code>protected</code>、<code>private</code>三种，不指定时使用默认继承方式（不推荐）。<br>a. 对于class，默认继承方式是<code>private</code><br>b. 对于struct，默认继承方式是<code>public</code></p><h2 id="1-3-访问控制"><a href="#1-3-访问控制" class="headerlink" title="1.3 访问控制"></a>1.3 访问控制</h2><p><strong>继承方式与访问限定符共同决定了基类成员在派生类中的可见性</strong>。</p><table><thead><tr><th align="left">类成员\继承方式</th><th align="left">public继承</th><th align="left">protected继承</th><th align="left">private继承</th></tr></thead><tbody><tr><td align="left">基类的public成员</td><td align="left">派生类的public成员</td><td align="left">派生类的protected成员</td><td align="left">派生类的private成员</td></tr><tr><td align="left">基类的protected成员</td><td align="left">派生类的protected成员</td><td align="left">派生类的protected成员</td><td align="left">派生类的private成员</td></tr><tr><td align="left">基类的private成员</td><td align="left">在派生类中不可见</td><td align="left">在派生类中不可见</td><td align="left">在派生类中不可见</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;eating&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">students_eat</span><span class="params">()</span> </span>&#123; <span class="built_in">eat</span>(); &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s._name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 错误，public继承，但_name在基类为private成员，所以在派生类不可见</span></span><br><span class="line">    s._age = <span class="number">10</span>; <span class="comment">// 错误，同上</span></span><br><span class="line">    s.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 正确，public继承，set_name在基类为public成员，所以在派生类为public</span></span><br><span class="line">    s.<span class="built_in">set_age</span>(<span class="number">18</span>); <span class="comment">// 正确，同上</span></span><br><span class="line">    s.<span class="built_in">print</span>(); <span class="comment">// 正确，同上</span></span><br><span class="line">    s.<span class="built_in">eat</span>(); <span class="comment">// 错误，public继承，但eat在基类为protected成员，所以在派生类为protected,只能在类里面调用该函数</span></span><br><span class="line">    s.<span class="built_in">students_eat</span>(); <span class="comment">// 正确</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/5159b20c1b60490ab1066993967e8013.png" alt="在这里插入图片描述"></p><p>问题：不管使用什么继承方式，基类中private的成员在派生类中是不可见的，为什么派生类还要含有这些不可见的成员？</p><ol><li>虽然派生类不能直接访问基类的private成员，但基类可以提供public或protected的方法（方法里面访问private成员）。当派生类调用基类的这些方法时，它会间接访问或修改基类的private成员，所以派生类要含有这些不可见成员。</li><li>为保证对象模型的一致性。如果派生类不包含基类的private成员，那么派生类的对象在内存布局上就会与基类的对象不同，这会导致继承体系中的类型兼容性问题。在派生类中保留基类的私有成员，可以确保派生类对象在内存中包含基类对象的所有部分，这使得基类指针或引用可以安全地指向派生类对象，以及通过派生类对象构造出基类对象。</li></ol><h2 id="1-4-继承中的作用域"><a href="#1-4-继承中的作用域" class="headerlink" title="1.4 继承中的作用域"></a>1.4 继承中的作用域</h2><p>&emsp;在继承体系中,基类和派生类都有<strong>独立的作用域</strong>，如果派生类定义了与基类同名的成员（变量和函数），则基类的同名成员会被隐藏（shadowed），派生类默认访问的是自身的成员，如要访问基类的成员,需要显式指定基类作用域。</p><p>语法: <code>基类名::成员名</code></p><p><strong>注意：</strong></p><ul><li>对于变量来说，同名即构成隐藏。</li><li>对于函数来说，如果基类函数不是虚函数，派生类只要函数同名即构成隐藏。如果基类为虚函数，派生类同名函数的参数列表不相同构成隐藏，而不是重写。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f4()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f5(int i)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f5()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::f2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f4()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">f1</span>(); <span class="comment">// 隐藏</span></span><br><span class="line">    b.<span class="built_in">f2</span>(); <span class="comment">// 隐藏</span></span><br><span class="line">    b.<span class="built_in">f3</span>(); <span class="comment">// 隐藏 </span></span><br><span class="line">    b.<span class="built_in">f4</span>(); <span class="comment">// 隐藏，虽然基类f4为虚函数，但派生类f4与基类f4参数列表不相同，所以不构成覆盖(override)</span></span><br><span class="line">    b.<span class="built_in">f5</span>(); <span class="comment">// 基类有2个f5函数，处于同一作用域，构成函数重载</span></span><br><span class="line">    b.<span class="built_in">f5</span>(<span class="number">1</span>); <span class="comment">// 基类有2个f5函数，处于同一作用域，构成函数重载</span></span><br><span class="line"></span><br><span class="line">b.A::<span class="built_in">f1</span>(); <span class="comment">// 使用作用域解析运算符访问基类f1函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行后输出内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B::f1()</span><br><span class="line">B::f2()</span><br><span class="line">B::f3()</span><br><span class="line">B::f4()</span><br><span class="line">A::f5(int i)</span><br><span class="line">A::f5()</span><br><span class="line">A::f1()</span><br></pre></td></tr></table></figure><h2 id="1-5-继承下的类型转换"><a href="#1-5-继承下的类型转换" class="headerlink" title="1.5 继承下的类型转换"></a>1.5 继承下的类型转换</h2><h3 id="1-5-1-向下类型转换"><a href="#1-5-1-向下类型转换" class="headerlink" title="1.5.1 向下类型转换"></a>1.5.1 向下类型转换</h3><p>将基类的指针、引用、对象转换为派生类指针、引用、对象称为向下类型转换。<br>说明：</p><ol><li>将基类对象转换为派生类对象时，实际上参照基类对象创建了一个新的派生类对象，所以派生类要提供一个<code>Derived(const Base&amp;)</code>拷贝构造函数。</li><li>将基类指针、引用转换为派生类指针、引用时没有创建新的对象，编译器只是对这个起始内存空间从按基类类型解释变为按派生类类型解释，所以有内存越界风险。</li><li>对于使用<code>protected/private</code>继承方式，向下类型转换没有什么实际意义，因为基类很多成员对派生类是不可见的。</li></ol><p><img src="https://i-blog.csdnimg.cn/direct/ec6275a13d6643e9a7bddfb311941549.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Person &amp;obj) &#123;&#125; <span class="comment">// 对象的向下类型转换必须提供该拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; _id = id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="function">Student <span class="title">s</span><span class="params">(p)</span></span>; <span class="comment">// 调用Student(const Person &amp;obj)拷贝构造函数</span></span><br><span class="line">    Student *point = (Student *) &amp;p; <span class="comment">// 将p对象的内存空间按Student类型解释</span></span><br><span class="line">    Student &amp;ref = (Student &amp;) p; <span class="comment">// 将p对象的内存空间按Student类型解释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法访问内存，point指向的区域实际是Person类型，现在将它按Student类型解释，调用set_id函数会修改p对象后面的内存区域</span></span><br><span class="line">point-&gt;<span class="built_in">set_id</span>(<span class="number">10</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-向上类型转换"><a href="#1-5-2-向上类型转换" class="headerlink" title="1.5.2 向上类型转换"></a>1.5.2 向上类型转换</h3><p>将派生类的指针、引用、对象转换为基类指针、引用、对象称为向上类型转换。<br>说明：</p><ol><li>将派生类对象转换为基类对象时，实际上根据派生类对象裁剪出创建了一个新的基类对象。</li><li>将派生类指针、引用转换为基类指针、引用时没有创建新的对象，编译器只是对这个起始内存空间从按派生类类型解释变为按基类类型解释。</li><li>对于使用<code>protected/private</code>继承方式，向上类型转换没有什么实际意义，且需要通过强制类型转换实现。<br><img src="https://i-blog.csdnimg.cn/direct/0c064e0602a143cfb9e1e3de351868a4.png" alt="在这里插入图片描述"></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repair</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change_color</span><span class="params">(<span class="type">int</span> color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">private</span> Bike </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_race</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end_race</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cur_strength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _max_strength;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    Bike *p = (Bike *) &amp;player; <span class="comment">// 使用protected/private继承时，需要强制类型转换</span></span><br><span class="line">    Bike &amp;ref = (Bike &amp;) player; <span class="comment">// 使用protected/private继承时，需要强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(<span class="type">const</span> string &amp;name)</span> </span>&#123; _name = name; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123; _age = age; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; _id = id; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    Person *point = &amp;s; <span class="comment">// 将s对象的内存空间按Person类型解释</span></span><br><span class="line">    Person &amp;ref = s; <span class="comment">// 将s对象的内存空间按Person类型解释</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-继承下的友元"><a href="#1-6-继承下的友元" class="headerlink" title="1.6 继承下的友元"></a>1.6 继承下的友元</h2><p><strong>友元关系不能继承</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Base</span>;  <span class="comment">// 声明 Base 为 A 的友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> secret = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessSecret</span><span class="params">(A&amp; a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base can access secret: &quot;</span> &lt;&lt; a.secret &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessSecret</span><span class="params">(A&amp; a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试访问 A 的私有成员,编译错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived can access secret: &quot;</span> &lt;&lt; a.secret &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Base base;</span><br><span class="line">    Derived derived;</span><br><span class="line"></span><br><span class="line">    base.<span class="built_in">accessSecret</span>(a);      <span class="comment">// 正常工作，Base 可以访问 A 的私有成员</span></span><br><span class="line">    derived.<span class="built_in">accessSecret</span>(a);   <span class="comment">// 编译错误，Derived 无法访问 A 的私有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-继承下的static成员变量"><a href="#1-7-继承下的static成员变量" class="headerlink" title="1.7 继承下的static成员变量"></a>1.7 继承下的static成员变量</h2><p><strong>static成员变量在类中是共享的</strong>，这意味着类的所有实例共享同一个变量，无论派生出多少个类，都只有一个static成员变量 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印出的地址相同</span></span><br><span class="line">    cout &lt;&lt; &amp;a._a &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; &amp;b._a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;c._a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、派生类的成员函数"><a href="#二、派生类的成员函数" class="headerlink" title="二、派生类的成员函数"></a>二、派生类的成员函数</h1><h2 id="2-1-派生类构造与析构函数"><a href="#2-1-派生类构造与析构函数" class="headerlink" title="2.1 派生类构造与析构函数"></a>2.1 派生类构造与析构函数</h2><h3 id="2-1-1-派生类构造函数"><a href="#2-1-1-派生类构造函数" class="headerlink" title="2.1.1 派生类构造函数"></a>2.1.1 派生类构造函数</h3><p>在派生类中不显式定义构造函数，编译器自动生成构造函数。这个构造函数会先调用基类的默认构造函数，然后调用派生类中自定义类型成员变量的默认构造函数。</p><p>派生类显式定义构造函数说明：</p><ul><li>构造顺序：先基类，再派生类</li><li>若没在派生类的初始化列表中显式指定基类构造函数，编译器会隐式调用基类的无参构造函数</li><li>多重继承时，基类按先后顺序构造</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> b) : _b(b) &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">A</span>(a), <span class="built_in">B</span>(b), _c(c) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 依次输出 A() 、B() 、C()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-派生类析构函数"><a href="#2-1-2-派生类析构函数" class="headerlink" title="2.1.2 派生类析构函数"></a>2.1.2 派生类析构函数</h3><p>在派生类中不显式定义析构函数，编译器自动生成析构函数。这个析构函数会先调用派生类中自定义类型成员变量的析构函数，然后调用基类的析构函数。</p><p>派生类显式定义析构函数说明：</p><ul><li>析构顺序：先派生类，再基类</li><li>不要显式调用基类析构函数：为了保证析构顺序,编译器会在派生类的析构函数结束前自动调用基类析构函数。如果用户显式调用了,则会对基类析构两次。</li><li>多重继承时，基类析构顺序与基类构造顺序相反</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() <span class="comment">// 基类的析构函数建议为虚函数，通过基类指针或引用删除一个派生类对象，virtual确保能调用派生类的析构函数，后续多态章节会详细讲解</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        A::~<span class="built_in">A</span>(); <span class="comment">// 不应该显式调用基类的析构函数，这样基类会析构两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b; <span class="comment">// 依次输出 ~B() 、~A() 、~A()， 基类调用了两次析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-派生类拷贝构造与赋值函数"><a href="#2-2-派生类拷贝构造与赋值函数" class="headerlink" title="2.2 派生类拷贝构造与赋值函数"></a>2.2 派生类拷贝构造与赋值函数</h2><h3 id="2-2-1-派生类拷贝构造函数"><a href="#2-2-1-派生类拷贝构造函数" class="headerlink" title="2.2.1 派生类拷贝构造函数"></a>2.2.1 派生类拷贝构造函数</h3><p>在派生类中不显式定义拷贝构造函数，编译器自动生成拷贝构造函数。这个拷贝构造函数会先调用基类的拷贝构造函数，然后对派生类对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的拷贝构造函数。</p><p>派生类显式定义析构函数说明：</p><ul><li>拷贝构造顺序：先基类，再派生类</li><li>若没在派生类的初始化列表中显式指定基类拷贝构造函数，编译器会隐式调用基类的拷贝构造函数</li><li>多重继承时，基类按先后顺序拷贝构造</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) : _a(a) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;obj):_a(obj._A)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(const &amp;A)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;obj) : <span class="built_in">A</span>(obj) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B(const &amp;B)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>; <span class="comment">// 依次输出 A(const &amp;A)、B(const &amp;B)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-派生类赋值函数"><a href="#2-2-2-派生类赋值函数" class="headerlink" title="2.2.2 派生类赋值函数"></a>2.2.2 派生类赋值函数</h3><p>在派生类中不显式定义赋值函数，编译器自动生成赋值函数。这个赋值函数会先调用基类的赋值函数，然后对派生类对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的赋值函数。</p><p>派生类显式定义赋值函数说明：</p><ul><li>赋值顺序：先基类，再派生类</li><li>多重继承时，基类按先后顺序赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) : _a(a) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;A=()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    B &amp;<span class="keyword">operator</span>=(<span class="type">const</span> B &amp;obj) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) </span><br><span class="line">        &#123;</span><br><span class="line">            A::<span class="keyword">operator</span>=(obj); <span class="comment">// 调用基类的赋值函数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B=()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    B b2;</span><br><span class="line">    b2 = b1; <span class="comment">// 依次输出 A=()、B=()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、菱形继承"><a href="#三、菱形继承" class="headerlink" title="三、菱形继承"></a>三、菱形继承</h1><h2 id="3-1-什么是菱形继承"><a href="#3-1-什么是菱形继承" class="headerlink" title="3.1 什么是菱形继承"></a>3.1 什么是菱形继承</h2><p>多个子类继承同一个父类而又有子类同时继承这几个子类或其子孙类。<br><img src="https://i-blog.csdnimg.cn/direct/f2dec37c960149259e6d5ca09036d630.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _num; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _id; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _majorCourse; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-菱形继承带来的问题"><a href="#3-2-菱形继承带来的问题" class="headerlink" title="3.2 菱形继承带来的问题"></a>3.2 菱形继承带来的问题</h2><p>菱形继承带来了<strong>二义性</strong>和<strong>数据冗余</strong>的问题。</p><p>二义性：<code>Student</code>和<code>Teacher</code>类都继承<code>Person</code>类，所以它们继承了_name属性，<code>Assistant</code>类继承<code>Student</code>和<code>Teacher</code>类，所以在<code>Assistant</code>类中访问_name时会有歧义，编译器不知道是访问<code>Student</code>类的_name还是<code>Teacher</code>类的_name。</p><p>数据冗余：对于<code>Assistant</code>对象来说存放两份_name。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Assistant a;</span><br><span class="line">    a._name = <span class="string">&quot;张三&quot;</span>; <span class="comment">// 错误，二义性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定基类作用域解决二义性问题，但是无法解决数据冗余问题。</span></span><br><span class="line">    a.Student::_name = <span class="string">&quot;张三&quot;</span>; </span><br><span class="line">    a.Teacher::_name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定基类作用域解决二义性问题，但是用起来很奇怪，对<code>Assistant</code>类来说_name属性应该只有一个才对，不能我学生身份时有一个名字，教师身份时又有一个名字，而且没有解决数据冗余问题。</p><h2 id="3-3-菱形继承内存布局"><a href="#3-3-菱形继承内存布局" class="headerlink" title="3.3 菱形继承内存布局"></a>3.3 菱形继承内存布局</h2><p>为了便于观察菱形继承的内存布局，下面使用简化的类结构。<br>测试环境： MSVC编译器 32位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/7bf69cccfc3e46e284385799c85141ed.png" alt="在这里插入图片描述"></p><h2 id="3-4-虚继承解决方案"><a href="#3-4-虚继承解决方案" class="headerlink" title="3.4 虚继承解决方案"></a>3.4 虚继承解决方案</h2><h3 id="3-4-1-虚继承原理"><a href="#3-4-1-虚继承原理" class="headerlink" title="3.4.1 虚继承原理"></a>3.4.1 虚继承原理</h3><p>&emsp;虚继承（虚拟继承） 是面向对象编程中的一种技术，是指一个指定的基类，在继承体系结构中，将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。通过虚继承可以解决菱形继承带来的二义性与数据冗余问题。</p><p>语法：<br><code>class Derive: virtual public Base&#123;&#125;;</code></p><p><font color=red >注意：只有直接继承基类的派生类需要进行虚继承,间接继承的派生类不需要。</font><br>测试环境： MSVC编译器 32位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.B::_a = <span class="number">1</span>;</span><br><span class="line">    d.C::_a = <span class="number">2</span>;</span><br><span class="line">    d._b = <span class="number">3</span>;</span><br><span class="line">    d._c = <span class="number">4</span>;</span><br><span class="line">    d._d = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/c06e042aa55e46338e3c31442e7ea45a.png" alt="在这里插入图片描述"><br>观察d对象内存视图可以发现，使用虚继承后，将同属于B和C的A存放到对象最下面， 将 B空间位置原来存放基类A的地方现在存放了一个指针，C空间位置原来存放基类A的地方现在也变为存放了一个指针，这两个指针为虚基表指针，虚基表中存放了A的偏移量。查看B的虚基表（0x00bfbb40）可以看到有一个值0x14000000(补码)，转换为源码后对应的值为20，B空间首地址加上偏移量20刚好是A中成员_a的地址。查看C的虚基表（0x00bfbb48）可以看到有一个值0x0c000000(补码)，转换为源码后对应的值为12，C空间首地址加上偏移量12刚好是A中成员_a的地址。这就是虚继承解决二义性与数据冗余的原理。</p><p>说明：</p><ul><li>虚基表中起始全0的4个字节空间是为了实现多态的虚表指针预留的。</li><li>虚继承的基类只会调用一次构造.</li><li>菱形继承没有虚基表,菱形虚拟继承才有虚基表</li></ul><p><strong>同一派生类的所有对象共享一份虚基表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D d1, d2 ,d3;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/df3a23cb8b6144eb9a4340296d57e6bc.png" alt="在这里插入图片描述"></p><h3 id="3-4-2-虚继承缺点"><a href="#3-4-2-虚继承缺点" class="headerlink" title="3.4.2 虚继承缺点"></a>3.4.2 虚继承缺点</h3><ol><li>参照前文部分，虚继承对于B类与C类的开发者提出更高要求，能预言出未来会被多继承而引发的菱形继承问题。</li><li>在<code>public</code>继承下向上类型转换是安全的，但是虚继承改变了对象内存布局，类型转换时编译器要做很多额外操作，效率低下。</li></ol><h1 id="四、继承与组合的选择"><a href="#四、继承与组合的选择" class="headerlink" title="四、继承与组合的选择"></a>四、继承与组合的选择</h1><p><strong>组合：</strong></p><ul><li>具有”has-a”或”contain-a”的关系</li><li>子对象所属类的源代码可有可无</li><li>类间是水平关系，相比继承可减少类的层次</li><li>黑盒复用，功能复用</li></ul><p><strong>继承：继承方式不同，目的不同</strong></p><ul><li>基类源代码必须有</li><li>白盒复用，代码复用</li><li>public继承表示“is-a”关系</li><li>private继承表示“has-a”，”contain-a”，”implement of”关系，完全可以换成组合</li><li>protected继承同private，同时便于在多层继承中保持这种关系</li></ul><p>总结：除了”is-a”关系使用public继承以外其它都使用组合。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、继承概念与语法&quot;&gt;&lt;a href=&quot;#一、继承概念与语法&quot; class=&quot;headerlink&quot; title=&quot;一、继承概念与语法&quot;&gt;&lt;/a&gt;一、继承概念与语法&lt;/h1&gt;&lt;h2 id=&quot;1-1-继承是什么&quot;&gt;&lt;a href=&quot;#1-1-继承是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 继承是什么&quot;&gt;&lt;/a&gt;1.1 继承是什么&lt;/h2&gt;&lt;p&gt;&amp;emsp;继承（Inheritance）是面向对象编程程序设计（OOP）的一个重要特征。&lt;strong&gt;它允许一个类（派生类）继承另一个类（基类）的属性和方法&lt;/strong&gt;，并可以在此基础上修改已有的功能或增加新的功能。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程，继承是类设计层次的代码复用。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ auto与decltype及函数返回类型后置</title>
    <link href="https://blog.kjlcloud.com/2024/04/24/C-auto%E4%B8%8Edecltype%E5%8F%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/"/>
    <id>https://blog.kjlcloud.com/2024/04/24/C-auto%E4%B8%8Edecltype%E5%8F%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE/</id>
    <published>2024-04-24T13:38:41.000Z</published>
    <updated>2025-03-04T08:54:30.889Z</updated>
    
    <content type="html"><![CDATA[<p>前言：在早期C&#x2F;C++中auto关键字的作用是：一个存储类型指示符，使用auto修饰的变量，存储类型为自动存储期，从变量声明处生命周期开始，出变量所在代码块生命周期结束，并且<strong>全局变量不能用auto修饰</strong>。但是局部变量的生命周期本来就是进入作用域生命周期开始，出作用域生命周期结束。<strong>导致用auto修饰局部变量和不使用auto修饰没有任何区别</strong>，处于一个尴尬地步。</p><span id="more"></span><h1 id="一、auto"><a href="#一、auto" class="headerlink" title="一、auto"></a>一、auto</h1><h2 id="1-1-C-11"><a href="#1-1-C-11" class="headerlink" title="1.1 C++11"></a>1.1 C++11</h2><p>&emsp;C++11中，标准委员会赋予了auto全新的作用：<strong>auto做为类型占位符</strong>，<strong>auto声明的变量数据类型由编译器在编译时推导而得，所以使用auto声明变量时必须对其进行初始化</strong>，在编译阶段编译器根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，<strong>编译器在编译阶段会将auto替换为变量实际的类型</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 因为x为int类型，所以等同于 int y = x;</span></span><br><span class="line"><span class="keyword">auto</span> a = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 因为a为char类型，所以等同于 char a = &#x27;a&#x27;;</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">1</span>; <span class="comment">// 因为b为int类型，所以等同于 int b = 1;</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="number">3.14</span>; <span class="comment">// 因为c为double类型，所以等同于 double c = 3.14;</span></span><br><span class="line"><span class="comment">// auto d; 错误，无法推导d是什么类型，导致不能分配内存空间</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;y：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y：<span class="type">int</span></span><br><span class="line">a：<span class="type">char</span></span><br><span class="line">b：<span class="type">int</span></span><br><span class="line">c：<span class="type">double</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:使用auto对多个变量推导时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器按第一个变量类型进行推导，然后用推导出来的类型定义其他变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>, b = <span class="number">20</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>, y = <span class="number">3.14</span>; <span class="comment">// 错误，第一个变量x类型为int,但y为double</span></span><br></pre></td></tr></table></figure><h3 id="1-1-1-推导规则"><a href="#1-1-1-推导规则" class="headerlink" title="1.1.1 推导规则"></a>1.1.1 推导规则</h3><p><strong>规则1:</strong>  auto声明变量时没有使用引用或指针，则推导出来类型会忽略引用、const 限定符和 volatile 限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">2025</span>;</span><br><span class="line"><span class="keyword">auto</span> n1 = i;   <span class="comment">// auto声明变量时没有使用引用或指针，推导会忽略const限定符，auto推导类型为int，n1类型为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n2 = i;  <span class="comment">// auto声明变量时使用引用，auto推导类型为const int，n2类型为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> *n3 = &amp;i; <span class="comment">// auto声明变量时使用指针，auto推导类型为const int，n3类型为const int*</span></span><br><span class="line"><span class="keyword">auto</span> n4 = n2;  <span class="comment">// auto声明变量时没有使用引用或指针，推导会忽略n2类型的引用、const限定符，auto推导类型为int，n4类型为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n5 = n2; <span class="comment">// auto声明变量时使用引用，auto推导类型为const int，n5类型为const int&amp;</span></span><br></pre></td></tr></table></figure><p><strong>规则2:</strong> auto推导指针类型时，<code>auto</code>与<code>auto*</code>没有任何区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = &amp;i; <span class="comment">// auto推导类型为const int*，a类型为const int*</span></span><br><span class="line"><span class="keyword">auto</span>* b = &amp;i; <span class="comment">// auto推导类型为const int，b类型为const int*</span></span><br></pre></td></tr></table></figure><p><strong>规则3:</strong> auto推导目标对象是数组或函数时，会被推导为对应指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = arr; <span class="comment">// auto推导类型为int * </span></span><br><span class="line"><span class="keyword">auto</span> b = fun; <span class="comment">// auto推导类型为void (*)()</span></span><br></pre></td></tr></table></figure><p><strong>规则4:</strong> auto推导列表表达式</p><p><font color=red >注意：下面规则适用于C++ 17</font></p><ul><li>直接使用列表初始化，列表中必须为单元素，否则编译错误，auto推导类型为该元素类型</li><li>用等号加列表初始化，列表中可以包含多个类型相同的元素，auto推导类型为<code>std::initializer_list&lt;T&gt;</code>，其中T为元素类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a1&#123;<span class="number">3</span>&#125;; <span class="comment">// auto推导类型为int</span></span><br><span class="line"><span class="keyword">auto</span> a2&#123;<span class="number">1</span>, <span class="number">3</span>&#125;; <span class="comment">// 编译错误,不是单个元素</span></span><br><span class="line"><span class="keyword">auto</span> a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// auto推导类型为std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> a4 = &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;; <span class="comment">// 编译错误，列表内元素类型不同</span></span><br></pre></td></tr></table></figure><p><strong>规则5:</strong> auto结合万能引用推导<br>如果推导对象是一个左值，将被推导为引用类型。如果推导对象是一个右值，将被推导为右值引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2025</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;x = a;   <span class="comment">// a为左值，x推导为左值引用，即int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y = <span class="number">2024</span>; <span class="comment">// 2024为右值，y推导为右值引用，即int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-auto不能使用的场景"><a href="#1-1-2-auto不能使用的场景" class="headerlink" title="1.1.2 auto不能使用的场景"></a>1.1.2 auto不能使用的场景</h3><h4 id="1-1-2-1-auto-不能做为函数形参"><a href="#1-1-2-1-auto-不能做为函数形参" class="headerlink" title="1.1.2.1 auto 不能做为函数形参"></a>1.1.2.1 auto 不能做为函数形参</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> <span class="comment">// 错误，auto不能做函数形参，编译器不知道如何为形参分配空间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-2-auto-不能声明数组"><a href="#1-1-2-2-auto-不能声明数组" class="headerlink" title="1.1.2.2 auto 不能声明数组"></a>1.1.2.2 auto 不能声明数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="1-2-C-14"><a href="#1-2-C-14" class="headerlink" title="1.2 C++ 14"></a>1.2 C++ 14</h2><h3 id="1-2-1-函数返回值类型推导"><a href="#1-2-1-函数返回值类型推导" class="headerlink" title="1.2.1 函数返回值类型推导"></a>1.2.1 函数返回值类型推导</h3><p>C++ 14支持使用auto对函数返回值类型进行推导，但要确保所有的返回值类型是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> <span class="comment">// 正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">double</span> i,<span class="type">double</span> j)</span> <span class="comment">// 错误，0为int类型，i+j为double类型，返回值类型不相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0.0</span> || j &lt; <span class="number">0.0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-lambda"><a href="#1-2-2-lambda" class="headerlink" title="1.2.2 lambda"></a>1.2.2 lambda</h3><p>C++14支持在lambda中使用auto作为形参以及返回值类型推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) <span class="comment">// lambda中使用auto对函数形参类型推导</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret1 = <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// ret1 = 3</span></span><br><span class="line"><span class="keyword">auto</span> ret2 = <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">// ret2 = 3.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> &amp;x) -&gt;<span class="keyword">auto</span>&amp; <span class="comment">// lambda可以使用auto推导返回值类型，或者auto&amp;返回引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;x:&quot;</span> &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span>&amp; ref = <span class="built_in">f</span>(x);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;ref:&quot;</span> &lt;&lt; &amp;ref &lt;&lt; endl; <span class="comment">// &amp;x 与 &amp;ref有相同地址</span></span><br></pre></td></tr></table></figure><h2 id="1-3-C-17"><a href="#1-3-C-17" class="headerlink" title="1.3 C++ 17"></a>1.3 C++ 17</h2><h3 id="1-3-1-非类型模版参数"><a href="#1-3-1-非类型模版参数" class="headerlink" title="1.3.1 非类型模版参数"></a>1.3.1 非类型模版参数</h3><p>C++ 17支持auto作为非类型模版参数的占位符，但推导出来的类型必须是符合非类型模版参数类型要求的，否则编译会错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="number">1</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="number">3.14</span>&gt;(); <span class="comment">// 错误，浮点类型不能作为非类型模版参数</span></span><br></pre></td></tr></table></figure><p><strong>说明：对于类型复杂的容器、迭代器、lambda等，auto 可以简化代码，使其更加简洁易读。如果滥用auto，可能会导致类型不明确，使代码失去可读性。</strong></p><h1 id="二、decltype"><a href="#二、decltype" class="headerlink" title="二、decltype"></a>二、decltype</h1><h2 id="2-1-C-11"><a href="#2-1-C-11" class="headerlink" title="2.1 C++11"></a>2.1 C++11</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在C++11以前，C++标准提供<code>typeid</code>运算符来查询变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个<code>type_info</code>的对象，typeid查询变量对应type_info。RTTI会导致运行时效率降低，且在泛型编程中，我们更需要编译时就确定类型，RTTI无法满足这样的要求。编译时类型推导的出现正是为了泛型编程，在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导。C++11提供<code>decltype</code>关键字，它在<strong>编译时</strong>推导表达式的类型，而无需计算该表达式。这对于泛型编程、模板编程以及复杂类型的推导特别有用。</p><p>语法：<strong>decltype( expression )</strong><br>作用：返回expression参数类型</p><h3 id="2-1-1-推导规则"><a href="#2-1-1-推导规则" class="headerlink" title="2.1.1 推导规则"></a>2.1.1 推导规则</h3><ol><li>如果 expression 参数是未加括号到标识符或类成员访问，则 decltype(expression) 推导是 <code>T</code>。如果不存在此类实体或 expression 参数命名一组重载函数，则编译器将生成错误消息。</li><li>如果 expression 参数是对一个函数或一个重载运算符函数的调用，则 decltype(expression) 推导是函数的返回类型</li><li>如果 expression 参数是将亡值，则 decltype(expression) 推导是<code>T&amp;&amp;</code>类型。 如果 expression 参数是左值，则 decltype(expression) 推导是<code>T&amp;</code></li><li>除去上面情况，则 decltype(expression) 推导是<code>T</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var; </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">fx</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">double</span> x; &#125;;</span><br><span class="line"><span class="type">const</span> A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fx</span>());<span class="comment">// 匹配规则2，推导为 const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(var);<span class="comment">// 匹配规则1，推导为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(a-&gt;x);<span class="comment">// 匹配规则1推导为 double</span></span><br><span class="line"><span class="keyword">decltype</span>((a-&gt;x)); <span class="comment">// 内部括号导致语句作为表达式而不是成员访问计算。匹配规则3，a-&gt;x是左值，并且a被const修饰，推导为const double&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *j;</span><br><span class="line"><span class="type">int</span> n[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i=<span class="number">0</span>); <span class="comment">// i=0不是标识符，不匹配规则1，i=0后返回i，i为左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">0</span>,i); <span class="comment">// 逗号表达式返回最右边参数，i为左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(n[<span class="number">5</span>]);<span class="comment">// 返回数组第六个元素（左值），左值匹配规则3，推导为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(i)); <span class="comment">// 将i转化为将亡值，匹配规则3，推导为int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(i++); <span class="comment">// i++为右值，匹配规则4，推导为int</span></span><br><span class="line"><span class="keyword">decltype</span>(++i); <span class="comment">// ++i为左值，匹配规则3，推导为int&amp;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-CV限定符推导"><a href="#2-1-2-CV限定符推导" class="headerlink" title="2.1.2 CV限定符推导"></a>2.1.2 CV限定符推导</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; CV 限定符（CV-qualifiers）指的是 const 和 volatile 关键字。它们用于限定变量、对象、类型，使得编译器对这些对象的处理方式有所不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通常情况下decltype( expression )推导的类型会同步expression的CV限定符。</span></span><br><span class="line"><span class="comment">   但如果expression是未加括号的成员变量时，父对象表达式的CV限定符会被忽略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i); <span class="comment">// 推导为const int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> A* obj= <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// 使用const修饰</span></span><br><span class="line"><span class="keyword">decltype</span>(obj-&gt;x); <span class="comment">// 匹配规则1，推导为int,const属性会忽略</span></span><br><span class="line"><span class="keyword">decltype</span>((obj-&gt;x)); <span class="comment">// 匹配规则3,推导为const int&amp;, const属性不会被忽略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-3-示例"><a href="#2-1-3-示例" class="headerlink" title="2.1.3 示例"></a>2.1.3 示例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在日常中我们经常会用求和函数，如果指定了函数形参类型则不够通用，下面使用模版实现一个通用求和函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11并不支持auto占位的函数返回类型进行推导，需要结合后置返回类型上的decltype说明符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14支持auto占位的函数返回类型进行推导，代码可简写为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个示例又会让人产生疑问，C++14中decltype的作用似乎又被auto取代了，但并不是，使用auto占位的函数返回类型推导时，如果期望返回类型是引用，但auto占位只能返回值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列代码在C++14 中测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">return_ref</span><span class="params">(T&amp; x)</span> <span class="comment">// 根据上文auto推导规则1，auto会删除引用限定符，推导为T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; -&gt; <span class="keyword">decltype</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">return_ref</span><span class="params">(T&amp; x)</span> <span class="comment">// 根据decltype推导规则3，x为左值，推导为T&amp;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-C-14"><a href="#2-2-C-14" class="headerlink" title="2.2 C++ 14"></a>2.2 C++ 14</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在C++14中，支持使用<code>decltype(auto)</code> 来进行类型推导，它实质是将表达式代入到<code>auto</code>然后再用<code>decltype</code>规则进行推导。注意<code>decltype(auto)</code>必须单独声明，不能结合指针、引用以及CV限定符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a1 = i;           <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a2 = i; <span class="comment">// 即decltype(i),推导类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a3 = (i);           <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a4 = (i); <span class="comment">// 即decltype((i)),推导类型为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a5 = <span class="built_in">f</span>();           <span class="comment">// auto会删除引用，推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a6 = <span class="built_in">f</span>(); <span class="comment">// 即decltype(f()),根据decltype推导规则2和3，推导类型为int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a7 = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 推导类型为 initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a8=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;; <span class="comment">// 编译错误，&#123;1,2&#125;不是表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *a9 = &amp;i; <span class="comment">// 推导类型为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) *a10 = &amp;i; <span class="comment">// 编译错误,decltype(auto)必须单独声明</span></span><br></pre></td></tr></table></figure><p>在2.1.3示例中如果使用auto占位函数返回类型进行推导，如果期望返回值是引用需要结合后置返回类型上的decltype说明符，有了<code>decltype(auto)</code>后代码可简写为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">return_ref</span><span class="params">(T &amp;x)</span> <span class="comment">// 返回类型为T&amp;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-C-17"><a href="#2-3-C-17" class="headerlink" title="2.3 C++ 17"></a>2.3 C++ 17</h2><p>C++ 17支持<code>decltype(auto)</code>作为非类型模版参数的占位符，但推导出来的类型必须是符合非类型模版参数类型要求的，否则编译会错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>) N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>&lt;x&gt;(); <span class="comment">// 编译错误，x不是常量</span></span><br><span class="line"><span class="built_in">f</span>&lt;y&gt;(); <span class="comment">// 正确，使用const修饰，y具有常属性</span></span><br><span class="line"><span class="built_in">f</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;(); <span class="comment">// 正确, &#x27;a&#x27;为常量</span></span><br></pre></td></tr></table></figure><h1 id="三、函数返回类型后置-C-11"><a href="#三、函数返回类型后置-C-11" class="headerlink" title="三、函数返回类型后置(C++ 11)"></a>三、函数返回类型后置(C++ 11)</h1><p><strong>C++ 11</strong>支持函数返回类型后置，使用<code>auto</code>在返回类型位置进行占位，表示“返回类型将会稍后引出或指定”，<code>-&gt;</code>后才是真正返回类型。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun</span><span class="params">(arg...)</span> -&gt; ret_type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-配合函数模版"><a href="#3-1-配合函数模版" class="headerlink" title="3.1 配合函数模版"></a>3.1 配合函数模版</h2><p>在C++ 11以前，如果有下面这个函数模版，那么函数返回类型应该写什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">??? <span class="built_in">sum</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能一开始就想到使用<code>decltype</code>去推导x+y的类型，写出下面代码，但是会编译错误。因为编译器在解析返回类型时还没有解析到参数部分，对x和y类型一无所知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x+y)</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码则可以编译通过，先将<code>nullptr</code>转换为T1和T2类型指针，然后解引用求和，<code>decltype</code>类型推导时不会真正计算表达式，所以这里求和不会有问题。不过这种写法不易懂且代码不美观。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">decltype</span>(*<span class="built_in">static_cast</span>&lt;T1 *&gt;(<span class="literal">nullptr</span>) + *<span class="built_in">static_cast</span>&lt;T2 *&gt;(<span class="literal">nullptr</span>)) <span class="built_in">sum</span>(T1 x, T2 y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++11中我们可以使用下面代码解决上面问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-返回复杂类型"><a href="#3-2-返回复杂类型" class="headerlink" title="3.2 返回复杂类型"></a>3.2 返回复杂类型</h2><p>当要返回复杂类型，例如返回函数指针类型时，使用函数返回类型后置写法比较简洁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1，编译错误</span></span><br><span class="line"><span class="built_in">int</span>(*)(<span class="type">int</span>) <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2，正确</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*ft)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ft <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3，正确</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">()</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考了谢丙堃 &lt;&lt;现代C++语言核心特性解析&gt;&gt;，在此先表示感谢，如涉及版权问题，版权所有为原作者。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：在早期C&amp;#x2F;C++中auto关键字的作用是：一个存储类型指示符，使用auto修饰的变量，存储类型为自动存储期，从变量声明处生命周期开始，出变量所在代码块生命周期结束，并且&lt;strong&gt;全局变量不能用auto修饰&lt;/strong&gt;。但是局部变量的生命周期本来就是进入作用域生命周期开始，出作用域生命周期结束。&lt;strong&gt;导致用auto修饰局部变量和不使用auto修饰没有任何区别&lt;/strong&gt;，处于一个尴尬地步。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
    <category term="C++ 14" scheme="https://blog.kjlcloud.com/tags/C-14/"/>
    
    <category term="C++ 17" scheme="https://blog.kjlcloud.com/tags/C-17/"/>
    
  </entry>
  
  <entry>
    <title>C++ 强制转换运算符</title>
    <link href="https://blog.kjlcloud.com/2024/03/23/C-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://blog.kjlcloud.com/2024/03/23/C-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2024-03-23T04:00:19.000Z</published>
    <updated>2025-03-04T08:54:19.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、static-cast"><a href="#一、static-cast" class="headerlink" title="一、static_cast"></a>一、static_cast</h1><p><code>static_cast</code> 在编译时进行类型转换，在转换时会进行一些类型检查以确保转换是相对安全的，<strong>但不包括运行时类型检查</strong>。<code>static_cast</code> 无法强制转换掉 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 或 <strong><code>__unaligned</code></strong> 特性。 </p><p>语法：仅根据表达式中存在的类型，将 expression 转换为 type 类型。</p><p><code>static_cast &lt;type&gt; ( expression )</code></p><span id="more"></span><p><strong>应用场景</strong></p><ul><li>可用于执行任何隐式转换，包括标准转换和用户定义的转换。</li><li>整数值与枚举类型之间转换， 如果整型值不在枚举值的范围内，生成的枚举值是不确定的。</li><li>将任何指针类型显式转换为 <code>void*</code>类型 ，将<code>void*</code>转换为目标类型指针，0转换为任何指针类型。</li><li>类继承情况下的向上类型转换和向下类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 隐式转换：例如数值类型转换，但程序员需要确保目标类型不会越界 */</span>  </span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i = <span class="number">65</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">int</span> x = <span class="number">650</span>;</span><br><span class="line">ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(i);    <span class="comment">// int to char, ch -&gt; &#x27;A&#x27;</span></span><br><span class="line">j = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(f);  <span class="comment">// float to int, j -&gt; 2</span></span><br><span class="line">ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);   <span class="comment">// char范围为 -128-127,x为650,越界，ch存的是错误的值 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">integer</span> &#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">integer</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">            : _x(x)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;integer()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 用户定义的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator string()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(_x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">integer <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>;   <span class="comment">// integer()</span></span><br><span class="line">string str = obj; <span class="comment">// operator string()</span></span><br><span class="line">obj = <span class="number">20</span>;         <span class="comment">// integer()</span></span><br><span class="line">string str2 = <span class="built_in">static_cast</span>&lt;string&gt;(obj); <span class="comment">// operator string()</span></span><br><span class="line">obj = <span class="built_in">static_cast</span>&lt;integer&gt;(<span class="number">30</span>); <span class="comment">// integer()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数与枚举类型转换 */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Color color = Color::GREEN;</span><br><span class="line"><span class="type">int</span> colorValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(color); <span class="comment">// 将枚举类型转换为整数，colorValue=1</span></span><br><span class="line"><span class="type">int</span> intValue = <span class="number">2</span>; </span><br><span class="line">Color enumColor = <span class="built_in">static_cast</span>&lt;Color&gt;(intValue); <span class="comment">// 将整数转换为枚举类型, enumColor=Color::BLUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将任何指针类型显式转换为 `void*`类型 ，将`void*`转换为目标类型指针 */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">65</span>;</span><br><span class="line"><span class="type">void</span> *pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span> *&gt;(&amp;i);</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(pv); <span class="comment">// *pc为 &#x27;A&#x27;</span></span><br><span class="line"><span class="type">int</span>* pi = <span class="built_in">static_cast</span>(<span class="type">int</span> *)(<span class="literal">nullptr</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">向上与向下类型转换,向下类型转换是不安全的，它在编译时进行类型检查，而不会进行运行时的安全性检查。</span></span><br><span class="line"><span class="comment">如果基类指针并非完整指向派生类对象，向下类型转换可能带来灾难。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Derived class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// Upcasting</span></span><br><span class="line">basePtr-&gt;<span class="built_in">display</span>(); <span class="comment">// Accessing Base class member</span></span><br><span class="line"><span class="comment">// basePtr-&gt;show();  // Error: Base class pointer cannot access Derived class member</span></span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* DerivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr); <span class="comment">// Downcasting</span></span><br></pre></td></tr></table></figure><h1 id="二、dynamic-cast"><a href="#二、dynamic-cast" class="headerlink" title="二、dynamic_cast"></a>二、dynamic_cast</h1><p><code>dynamic_cast</code> 用于<strong>具有虚函数的基类</strong>与派生类之间指针与引用的转换。编译器会运行时进行类型检查，如果转换是合法的，则转换成功并返回指向目标类型的指针或引用；如果转换不合法，则返回空指针（对指针类型）或抛出 <code>std::bad_cast</code> 异常（对引用类型）。</p><p>语法：将 expression 转换为 type 类型。</p><p><code>dynamic_cast &lt;type&gt; ( expression )</code></p><p><strong>应用场景</strong></p><ul><li>向上类型转换（更推荐使用static_cast）</li><li>向下类型转换</li><li>横向类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向下类型转换 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base *basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived *derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived *&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    derivedPtr-&gt;<span class="built_in">show</span>(); <span class="comment">// 输出：Derived class</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed to cast&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base &amp;baseRef = derivedObj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived &amp;derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived &amp;&gt;(baseRef);</span><br><span class="line">    derivedRef.<span class="built_in">show</span>(); <span class="comment">// 输出：Derived class</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_cast) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Can&#x27;t cast to Derived&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=left><img src="向上类型转换1.png" style="zoom:50%;" /></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">多继承向上类型转换,指向 D 类型对象的指针可以安全地强制转换为 B 或 C。 但是，如果 D 强制转换为指向 A 对象的指针，会产生 A 的哪个实例？ 这将导致不明确的强制转换错误。 若要解决此问题，可以执行两个明确的强制转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D *pd = <span class="keyword">new</span> D;</span><br><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pd);   <span class="comment">// C4540, ambiguous cast fails at runtime</span></span><br><span class="line">B *pb = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(pd);   <span class="comment">// first cast to B</span></span><br><span class="line">A *pa2 = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pb);   <span class="comment">// ok: unambiguous</span></span><br></pre></td></tr></table></figure><div align=left><img src="向上类型转换2.png" style="zoom:50%;" /></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在给定 E 类型对象和指向 D 子对象的指针的情况下，若要从 D 子对象导航到最左侧的 A 子对象，可以进行三次转换。 可以执行从 D 指针到 E 指针的 dynamic_cast 转换，然后执行从 E 到 B 的转换（可以是 dynamic_cast，也可以是隐式转换），最后执行从 B 到  A 的隐式转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C, <span class="keyword">public</span> D &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D *dPtr = <span class="keyword">new</span> <span class="built_in">E</span>();</span><br><span class="line">E *pe = <span class="built_in">dynamic_cast</span>&lt;E *&gt;(dPtr);</span><br><span class="line">B *pb = pe;   <span class="comment">// upcast, implicit conversion</span></span><br><span class="line">A *pa = pb;   <span class="comment">// upcast, implicit conversion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">横向类型转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">D *dPtr = <span class="keyword">new</span> <span class="built_in">E</span>();</span><br><span class="line">B *pb = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(dPtr); <span class="comment">// 横向类型转换</span></span><br><span class="line">A* pa = pb;   <span class="comment">// upcast, implicit conversion</span></span><br></pre></td></tr></table></figure><h1 id="三、const-cast"><a href="#三、const-cast" class="headerlink" title="三、const_cast"></a>三、const_cast</h1><p>移除对象的 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 和 <strong><code>__unaligned</code></strong> 属性，如果一个对象本身就是<code>const</code>属性，使用<code>const_cast</code>，结果是C++标准未定义的。</p><p>语法：</p><p><code>const_cast &lt;type&gt; ( expression )</code></p><p><strong>应用场景</strong></p><ul><li>函数形参是<code>non-const</code>变量，并且函数不会对实参的值进行改动，但变量为<code>const</code></li><li>变量为<code>non-const</code>，使用一个<code>const</code>的指针(引用)来指向它，某个地方需要修改指针(引用)指向的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *num &lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pi_c = &amp;j;</span><br><span class="line"><span class="type">int</span> *pi = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(pi_c);</span><br><span class="line">*pi = <span class="number">1</span>; <span class="comment">// j为1</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri_c = j;</span><br><span class="line"><span class="type">int</span> &amp;ri = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(ri_c);</span><br><span class="line">ri = <span class="number">2</span>; <span class="comment">// j为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 警告：i本身为const,使用const_cast行为是未定义的 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pi_c = &amp;i;</span><br><span class="line"><span class="type">int</span> *pi = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(pi_c);</span><br><span class="line">*pi = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i:  &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;  adderss:  &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl; <span class="comment">// i:  10  adderss:  0x30c624598</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pi:  &quot;</span> &lt;&lt; *pi &lt;&lt; <span class="string">&quot;  adderss:  &quot;</span> &lt;&lt; pi &lt;&lt; endl; <span class="comment">// *pi:  1  adderss:  0x30c624598</span></span><br></pre></td></tr></table></figure><h1 id="四、reinterpret-cast"><a href="#四、reinterpret-cast" class="headerlink" title="四、reinterpret_cast"></a>四、reinterpret_cast</h1><p>允许将任何指针(引用)转换为任何其他指针(引用)类型。 也允许将任何整数类型转换为任何指针(引用)类型以及反向转换。<strong><code>reinterpret_cast</code></strong> 运算符无法强制转换掉 <strong><code>const</code></strong>、<strong><code>volatile</code></strong> 或 <strong><code>__unaligned</code></strong> 特性。滥用 <strong><code>reinterpret_cast</code></strong> 运算符可能很容易带来风险。</p><p>语法</p><p><code>reinterpret_cast &lt; type &gt; ( expression )</code></p><p><strong>应用场景</strong></p><ul><li>改变指针或引用的类型</li><li>将指针或引用转换为一个足够长度的整型</li><li>将整型转换为指针或引用类型</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、static-cast&quot;&gt;&lt;a href=&quot;#一、static-cast&quot; class=&quot;headerlink&quot; title=&quot;一、static_cast&quot;&gt;&lt;/a&gt;一、static_cast&lt;/h1&gt;&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt; 在编译时进行类型转换，在转换时会进行一些类型检查以确保转换是相对安全的，&lt;strong&gt;但不包括运行时类型检查&lt;/strong&gt;。&lt;code&gt;static_cast&lt;/code&gt; 无法强制转换掉 &lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;__unaligned&lt;/code&gt;&lt;/strong&gt; 特性。 &lt;/p&gt;
&lt;p&gt;语法：仅根据表达式中存在的类型，将 expression 转换为 type 类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static_cast &amp;lt;type&amp;gt; ( expression )&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
    <category term="运算符" scheme="https://blog.kjlcloud.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++ lambda</title>
    <link href="https://blog.kjlcloud.com/2023/12/07/C-lambda/"/>
    <id>https://blog.kjlcloud.com/2023/12/07/C-lambda/</id>
    <published>2023-12-07T02:23:29.000Z</published>
    <updated>2025-03-04T08:54:35.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、lambda是什么"><a href="#一、lambda是什么" class="headerlink" title="一、lambda是什么"></a>一、lambda是什么</h1><p>在 C++ 11 及更高版本中，Lambda 表达式（通常称为 Lambda）用来定义匿名函数对象，用来作为参数传递给算法或者作为匿名函数进行调用，使得代码更加灵活简洁。</p><span id="more"></span><h1 id="二、lambda语法"><a href="#二、lambda语法" class="headerlink" title="二、lambda语法"></a>二、lambda语法</h1><p>lambda语法组成：</p><p><code>[capture-list] (parameters) mutable -&gt; return-type &#123; statement &#125;</code></p><img src="lambda语法.png" alt="lambda语法"/><h2 id="2-1-capture-list"><a href="#2-1-capture-list" class="headerlink" title="2.1 capture-list"></a>2.1 capture-list</h2><p><strong>capture-list</strong>可以把上下文变量以值或引用的方式捕获，在<strong>statement</strong>中直接使用，若<strong>capture-list</strong>为空，则不捕获任何变量。</p><ul><li><p>[var] :   表示值传递方式捕捉变量</p></li><li><p>[&#x3D;]  :    表示值传递方式捕获所有父作用域中的变量，包括this </p></li><li><p>[&amp;var] : 表示引用传递捕捉变量var</p></li><li><p>[&amp;] :      表示引用传递捕捉所有父作用域中的变量，包括this</p></li><li><p>[this] :  表示值传递方式捕捉当前的this指针</p></li></ul><p>说明:<br> a. 父作用域指包含lambda函数的语句块<br> b. 语法上捕捉列表可由多个捕捉项组成，并以逗号分割<br> c. 捕捉列表不允许变量重复捕获<br> d. 引用捕获可用于修改外部变量，而值捕获却不能实现此操作（<strong>mutable</strong> 允许修改副本，而不能修改原始变量）<br> e. 在块作用域以外的lambda捕捉列表必须为空<br> f. 引用捕获引入生存期依赖项，而值捕获却没有生存期依赖项<br> g. lambda表达式之间不能相互赋值，哪怕看起来类型一样，因为生成的lambda类名不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> fun = [x]&#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，块作用域以外的lambda捕捉列表必须为空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值来捕获某个变量</span></span><br><span class="line">  <span class="keyword">auto</span> func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值来捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按引用来捕获某个变量</span></span><br><span class="line">  <span class="keyword">auto</span> func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func3</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按引用来捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func4</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 混合捕获</span></span><br><span class="line">  <span class="keyword">auto</span> func5 = [&amp;,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func5</span>();</span><br><span class="line">  <span class="keyword">auto</span> func6 = [=,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">func6</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> func6 = [&amp;,&amp;b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，&amp;已经引用捕捉作用域所有变量，不能重复对b变量进行引用捕捉</span></span><br><span class="line">  <span class="keyword">auto</span> func7 = [=,b] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;; <span class="comment">// 错误，与上类似</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> func8 = [=] &#123; </span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 错误，按值捕获不能修改</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> func8 = [=] <span class="keyword">mutable</span>&#123; </span><br><span class="line">    a = <span class="number">10</span>; <span class="comment">// 正确，但是a只是外部a的值拷贝，对a对修改并不影响外部a变量</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-parameters"><a href="#2-2-parameters" class="headerlink" title="2.2 parameters"></a>2.2 parameters</h2><p>参数列表是可选的，它在大多数方面类似于函数的参数列表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun1 = [] (<span class="type">int</span> first, <span class="type">int</span> second)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun2 = []&#123; std::cout &lt;&lt; <span class="string">&quot;Hello Worl&quot;</span> &lt;&lt; std::endl;&#125;;</span><br></pre></td></tr></table></figure><p>在 C++14 中，如果参数类型是泛型，则可以使用 <strong><code>auto</code></strong> 关键字作为类型说明符。 此关键字将告知编译器将函数调用运算符创建为模板。 参数列表中的每个 <strong><code>auto</code></strong> 实例等效于一个不同的类型参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;</span><br><span class="line">  <span class="keyword">auto</span> ret = x + y;</span><br><span class="line">  std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">func1</span>(a,b);</span><br></pre></td></tr></table></figure><h2 id="2-3-mutable"><a href="#2-3-mutable" class="headerlink" title="2.3 mutable"></a>2.3 mutable</h2><p><strong>mutable</strong>为可选</p><p>通常Lambda 的函数调用运算符是 const-by-value，但对 <strong><code>mutable</code></strong> 关键字的使用可将其取消。它不产生 mutable 数据成员。 利用 <strong><code>mutable</code></strong> 规范，Lambda 表达式的主体可以修改通过<strong>值捕获的变量</strong>。</p><h2 id="2-4-return-type"><a href="#2-4-return-type" class="headerlink" title="2.4 return-type"></a>2.4 return-type</h2><p><strong>return-type</strong>为可选的情况</p><ul><li><strong>statement</strong>仅一个返回语句，编译器将从返回表达式的类型推导返回类型</li><li><strong>statement</strong>没有返回值，编译器会将返回类型推导为 <strong>void</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i; &#125;; <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []&#123; <span class="keyword">return</span>&#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// ERROR: return type is void, deducing</span></span><br><span class="line">                                  <span class="comment">// return type from braced-init-list isn&#x27;t valid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = []-&gt;vector&lt;<span class="type">int</span>&gt;&#123; <span class="keyword">return</span>&#123; <span class="number">1</span>, <span class="number">2</span>&#125;; &#125;; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="2-5-statement"><a href="#2-5-statement" class="headerlink" title="2.5 statement"></a>2.5 statement</h2><p><strong>statement</strong>是一个复合语句。 它可以包含普通函数或成员函数体中允许的任何内容。 普通函数和 lambda 表达式的<strong>statement</strong>均可访问以下变量类型：</p><ul><li>从封闭范围捕获变量，如前所述</li><li>参数</li><li>本地声明变量</li><li>类数据成员（在类内部声明并且捕获 <strong><code>this</code></strong> 时）</li><li>具有静态存储持续时间的任何变量（例如，全局变量）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* 可以在lambda 表达式体中使用具有静态持续存储时间的变量 */</span></span><br><span class="line">        <span class="keyword">auto</span> f = []&#123;</span><br><span class="line">                i = <span class="number">3</span>; <span class="comment">// 访问的就是全局变量i</span></span><br><span class="line">                j = <span class="number">4</span>; <span class="comment">// 访问的就是静态全局变量j</span></span><br><span class="line">                std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">                std::cout &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line">  std::cout &lt;&lt; j &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line">        </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、lambda与函数对象"><a href="#三、lambda与函数对象" class="headerlink" title="三、lambda与函数对象"></a>三、lambda与函数对象</h1><p>​在<strong>lambda</strong>出现之前，编写代码有时候需要用到函数指针或函数对象。它们各有利弊，例如：函数指针具有最低的语法开销，但不保持范围内的状态，函数对象可保持状态，但需要类定义的语法开销。</p><p>​lambda 结合了函数指针和函数对象的优点并避免其缺点。 与函数对象一样，lambda 是灵活的并且可以保持状态，但与函数对象不同之处在于其简洁的语法不需要显式类定义。 使用 lambda，可以编写出比等效的函数对象代码更简洁、更不容易出错的代码。</p><h1 id="四、lambda表达式示例"><a href="#四、lambda表达式示例" class="headerlink" title="四、lambda表达式示例"></a>四、lambda表达式示例</h1><h2 id="4-1-编译器对lambda处理"><a href="#4-1-编译器对lambda处理" class="headerlink" title="4.1 编译器对lambda处理"></a>4.1 编译器对lambda处理</h2><p>C++ 编译器将在声明而非调用 lambda 表达式时，将表达式绑定到捕获的变量。 以下示例显示一个通过值捕获局部变量 <code>i</code> 并通过引用捕获局部变量 <code>j</code> 的 lambda 表达式。 由于 lambda 表达式通过值捕获 <code>i</code>，因此在程序后面部分中重新指派 <code>i</code> 不影响该表达式的结果。 但是，由于 lambda 表达式通过引用捕获 <code>j</code>，因此重新指派 <code>j</code> 会影响该表达式的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> f = [i, &amp;j] &#123; <span class="keyword">return</span> i + j; &#125;;</span><br><span class="line"></span><br><span class="line">   i = <span class="number">22</span>;</span><br><span class="line">   j = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 输出 47</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-lambda调用"><a href="#4-2-lambda调用" class="headerlink" title="4.2 lambda调用"></a>4.2 lambda调用</h2><p>可以立即调用 lambda 表达式，也可以将lambda作为参数传递给函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = [] (<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;(<span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 立即调用</span></span><br><span class="line">   cout &lt;&lt; n &lt;&lt; endl; <span class="comment">// 输出: 9</span></span><br><span class="line">  </span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; numbers&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;</span><br><span class="line">   <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::const_iterator result = <span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), </span><br><span class="line">                                                      numbers.<span class="built_in">end</span>(),</span><br><span class="line">                                                      [](<span class="type">int</span> n) &#123; </span><br><span class="line">                                                      <span class="built_in">return</span> (n % <span class="number">2</span>) == <span class="number">0</span>; &#125;); <span class="comment">// 作为函数参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出: The first even number in the list is 8.</span></span><br><span class="line">    <span class="keyword">if</span> (result != numbers.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The first even number in the list is &quot;</span> &lt;&lt; *result &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The list contains no even numbers.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-嵌套lambda"><a href="#4-3-嵌套lambda" class="headerlink" title="4.3 嵌套lambda"></a>4.3 嵌套lambda</h2><p>可以将 lambda 表达式嵌套在另一个中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> timestwoplusthree = [](<span class="type">int</span> x) &#123; </span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> y) &#123; </span><br><span class="line">          <span class="keyword">return</span> y * <span class="number">2</span>; </span><br><span class="line">        &#125;(x) + <span class="number">3</span>; </span><br><span class="line">    &#125;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; timestwoplusthree &lt;&lt; endl;  <span class="comment">// 输出: 13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、lambda底层实现"><a href="#五、lambda底层实现" class="headerlink" title="五、lambda底层实现"></a>五、lambda底层实现</h1><p>lambda表达式本质是编译器将其翻译成一个类，并重载 operator()来实现。</p><p>lambda的各个部分和类的各个部分对应关系:</p><ul><li>capture-list &lt;-&gt;  类中private成员</li><li>parameters &lt;-&gt; 类中operator()成员函数的形参列表</li><li>mutable &lt;-&gt; 类成员函数 operator() 的const属性 (只有在捕获列表捕获的参数不含有引用捕获的情况下才会生效)</li><li>return-type &lt;-&gt; 类成员函数 operator() 的返回类型</li><li>statement &lt;-&gt; 类成员函数 operator() 的函数体</li></ul><p>说明：编译器生成的lambda类型一般为<code>lambda_ + uuid</code> ，确保类名是唯一的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Date = std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  std::string name;</span><br><span class="line">  Date birthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Person&gt; peoples&#123;&#123;<span class="string">&quot;Marie Curie&quot;</span>, <span class="string">&quot;1867-11-7&quot;</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;Albert Einstein&quot;</span>, <span class="string">&quot;1879-3-14&quot;</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;Johann Carl Friedrich Gauß&quot;</span>, <span class="string">&quot;1777-4-30&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPeopleNoLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 按照姓名排序</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ByName</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::<span class="built_in">sort</span>(peoples.<span class="built_in">begin</span>(), peoples.<span class="built_in">end</span>(), ByName&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortPeopleWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(peoples.<span class="built_in">begin</span>(), peoples.<span class="built_in">end</span>(), [](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译器会将lambda转化为 */</span></span><br><span class="line">[](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_1</span> <span class="comment">/* 不要在意名字 */</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    a.name &lt; b.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __lambda_1() = <span class="keyword">delete</span>; <span class="comment">// 没有默认构造函数</span></span><br><span class="line">  __lambda_1&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __lambda_1&amp;) = <span class="keyword">delete</span>; <span class="comment">// 不能赋值</span></span><br><span class="line">&#125;;</span><br><span class="line">__lambda_1(); <span class="comment">// 对象实例编译器自动创建的，所以不会报错</span></span><br></pre></td></tr></table></figure><h2 id="5-1-变量捕获"><a href="#5-1-变量捕获" class="headerlink" title="5.1 变量捕获"></a>5.1 变量捕获</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传值捕获</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [=] &#123;</span><br><span class="line">  <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译器会把上面的lambda表达式代码转为：*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span> i, <span class="type">int</span> j): __i(i), __j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> __i;</span><br><span class="line">  <span class="type">int</span> __j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">__lambda2 <span class="title">f</span><span class="params">(i,j)</span></span>;</span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用捕获：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;] &#123;</span><br><span class="line">  <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br><span class="line">lambda 表达式会转为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__lambda_2</span> &#123;</span><br><span class="line">  __lambda_2(<span class="type">int</span>&amp; i, <span class="type">int</span>&amp; j): __i(i), __j(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="comment">// 没有const修饰</span></span><br><span class="line">    <span class="keyword">return</span> __i == __j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span>&amp; __i;</span><br><span class="line">  <span class="type">int</span>&amp; __j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">__lambda2 <span class="title">f</span><span class="params">(i,j)</span></span>;</span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 捕获：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callAsync</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="comment">// 可以使用 X 类里的成员</span></span><br><span class="line">      std::<span class="built_in">print</span>(<span class="string">&quot;X::i=&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">编译器把 lambda 转为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__lambda_3</span> &#123;</span><br><span class="line">      __lambda_3(X* _this): __this(_this) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">print</span>(<span class="string">&quot;X::i=&#123;&#125;&quot;</span>, __this-&gt;i);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      X* __this;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">callAsync</span>(__lambda_3(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i&#123;<span class="number">42</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、lambda是什么&quot;&gt;&lt;a href=&quot;#一、lambda是什么&quot; class=&quot;headerlink&quot; title=&quot;一、lambda是什么&quot;&gt;&lt;/a&gt;一、lambda是什么&lt;/h1&gt;&lt;p&gt;在 C++ 11 及更高版本中，Lambda 表达式（通常称为 Lambda）用来定义匿名函数对象，用来作为参数传递给算法或者作为匿名函数进行调用，使得代码更加灵活简洁。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++ 列表初始化</title>
    <link href="https://blog.kjlcloud.com/2023/11/15/C-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://blog.kjlcloud.com/2023/11/15/C-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2023-11-15T00:14:00.000Z</published>
    <updated>2025-03-04T08:54:16.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、列表初始化"><a href="#一、列表初始化" class="headerlink" title="一、列表初始化"></a>一、列表初始化</h1><h2 id="1-1-出现原因"><a href="#1-1-出现原因" class="headerlink" title="1.1 出现原因"></a>1.1 出现原因</h2><p>在<strong>C++98&#x2F;03</strong> 中的对象初始化方法有很多种方法，这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组的初始化</span></span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">基于POD(plain old data)类型,这里的先调用构造函数传入参数1构造一个A类型匿名对象，然后调用拷贝构造函数传入匿名对象参数构造对象a1,不过编译器会进行优化，实际只调用一次构造函数。</span></span><br><span class="line"><span class="comment">说明：当构造函数被explicit修饰，或者拷贝构造函数为private时，a1会失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; a1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于STL中容器不能想数组那样进行初始化，只能一个一个插入</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="1-2-统一的初始化"><a href="#1-2-统一的初始化" class="headerlink" title="1.2 统一的初始化"></a>1.2 统一的初始化</h2><p>C++11标准引入了<strong>列表初始化</strong>，它使用大括号{}对任意类型对象进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置类型初始化</span></span><br><span class="line"><span class="type">int</span> i1&#123;<span class="number">10</span>&#125;  &lt;=&gt; <span class="type">int</span> i0 = &#123;<span class="number">10</span>&#125; &lt;=&gt; <span class="type">int</span> i2 =&#123;<span class="number">10</span>&#125; &lt;=&gt; <span class="type">int</span> i3 =(<span class="number">10</span>) &lt;=&gt; <span class="type">int</span> i4 = <span class="built_in">int</span>(<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt;=&gt; <span class="type">int</span> arr2[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="type">int</span> arr3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态数组，在C++98/03中不支持</span></span><br><span class="line"><span class="type">int</span>* arr4 = <span class="keyword">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL容器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt;=&gt;  vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-自定义类型初始化"><a href="#1-2-1-自定义类型初始化" class="headerlink" title="1.2.1 自定义类型初始化"></a>1.2.1 自定义类型初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Point</span>(Point &amp;obj) : _x(obj._x), _y(obj._y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p1&#123;<span class="number">1</span>,<span class="number">2</span>&#125; &lt;=&gt; Point <span class="built_in">p2</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 直接调用构造函数</span></span><br><span class="line">Point p2 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">// 先调用构造函数，再调用拷贝构造，编译器可能会优化为只调用一次构造函数  </span></span><br></pre></td></tr></table></figure><h2 id="1-3-initializer-list"><a href="#1-3-initializer-list" class="headerlink" title="1.3 initializer-list"></a>1.3 initializer-list</h2><p><code>std::initialzer-list</code>是C++11引入的轻量级类模板，只提供begin、end以及size成员函数。编译器将{ }内的数据存放到<code>std::array</code>中，并构建<code>initializer_list</code> 对象引用这个<code>array</code>对象中的元素，但并不包含它们，拷贝一个 <code>initializer_list</code> 对象会生成另一个引用相同底层元素的对象，而不是创建它们的新副本，即浅拷贝。</p><p>C++11起，STL容器之所以能够支持列表初始化原因在于每个容器都提供了一个形参为<code>initializer_list</code>的构造函数。编译器会先构造一个<code>initializer_list</code>对象，然后调用对应容器中形参为<code>initializer_list</code>的构造函数。这个构造函数的逻辑非常简单，它们只需要调用<code>initializer_list</code>对象的begin和end 函数，循环对本对象进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vector&lt;Point&gt; v2&#123;p1,p2&#125; &lt;=&gt; vector&lt;Point&gt; v3&#123;<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">2</span>)&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：自定义数据类型如果需要实现该功能，需要自己实现参数为<code>initializer-list</code> 的构造函数</strong></p><h3 id="1-3-1-initializer-list其它用途"><a href="#1-3-1-initializer-list其它用途" class="headerlink" title="1.3.1 initializer-list其它用途"></a>1.3.1 initializer-list其它用途</h3><p><code>initializer-list</code>不仅可以用于自定义类型的列表初始化，也可以用于传递相同类型数据的集合，例如作为函数的形参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(&#123;&#125;);<span class="comment">//传递一个空集</span></span><br><span class="line"><span class="built_in">print</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);<span class="comment">//传递int类型的集合</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><h3 id="1-4-1-Narrowing-conversions-缩窄转换"><a href="#1-4-1-Narrowing-conversions-缩窄转换" class="headerlink" title="1.4.1 Narrowing conversions(缩窄转换)"></a>1.4.1 Narrowing conversions(缩窄转换)</h3><p>在 C++ 中，缩窄转换是一种不安全的类型转换，因为目标类型可能无法保存源类型的所有值。缩窄转换是在编写代码中稍不留意就会出现，而且它的出现并不一定会引发错误，甚至有可能连警告都没有，所以有时候容易被人们忽略，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2025</span>;</span><br><span class="line"><span class="type">char</span> c = x; <span class="comment">// 2015 超过了char类型范围，会导致溢出，c的值不可预测</span></span><br></pre></td></tr></table></figure><p>C++标准规定下列情况属于缩窄转换：</p><ul><li>从浮点类型转换整数类型</li><li>从long double转换到double或float，或从double转换 到float，除非转换的值是<code>constexpr</code>并且在目标类型的范围内</li><li>从整数类型转换到浮点类型，除非转换的值是<code>constexpr</code>并且在目标类型的范围内</li><li>从整数类型转换为另一种整数类型，该整数类型不能表示原始类型的所有值，除非转换的值是 constexpr 并且其值可以精确存储在目标类型中</li></ul><p><strong>使用列表初始化，编译器对于缩窄转换会报编译错误(MSVC、clang)或警告(GCC)。</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i&#123;<span class="number">3.14</span>&#125;; <span class="comment">// 存在缩窄转换</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-列表初始化的优先级"><a href="#1-4-2-列表初始化的优先级" class="headerlink" title="1.4.2 列表初始化的优先级"></a>1.4.2 列表初始化的优先级</h3><p>列表初始化既可以支持普通的构造函数，也能够支持以<code>initializer_list</code>为形参的构造函数。如果这两种构造函数同时出现在同一个类里，<strong>以<code>initializer_list</code>为形参的构造函数优先级更高</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y) &#123; cout &lt;&lt; <span class="string">&quot;Point(int x = 0, int y = 0)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Point</span>(initializer_list&lt;<span class="type">int</span>&gt; l) &#123; cout &lt;&lt; <span class="string">&quot;Point(initializer_list&lt;int&gt; l)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 Point(int x = 0, int y = 0) 构造函数</span></span><br><span class="line">Point p2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 使用列表初始化，调用Point(initializer_list&lt;int&gt; l)构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、列表初始化&quot;&gt;&lt;a href=&quot;#一、列表初始化&quot; class=&quot;headerlink&quot; title=&quot;一、列表初始化&quot;&gt;&lt;/a&gt;一、列表初始化&lt;/h1&gt;&lt;h2 id=&quot;1-1-出现原因&quot;&gt;&lt;a href=&quot;#1-1-出现原因&quot; class=&quot;headerlink&quot; title=&quot;1.1 出现原因&quot;&gt;&lt;/a&gt;1.1 出现原因&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;C++98&amp;#x2F;03&lt;/strong&gt; 中的对象初始化方法有很多种方法，这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
    <category term="C++ 11" scheme="https://blog.kjlcloud.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>radosgw多站点</title>
    <link href="https://blog.kjlcloud.com/2023/09/10/radosgw%E5%A4%9A%E7%AB%99%E7%82%B9/"/>
    <id>https://blog.kjlcloud.com/2023/09/10/radosgw%E5%A4%9A%E7%AB%99%E7%82%B9/</id>
    <published>2023-09-10T12:28:52.000Z</published>
    <updated>2023-09-10T12:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-概念与术语"><a href="#1-1-概念与术语" class="headerlink" title="1.1 概念与术语"></a>1.1 概念与术语</h2><p><strong>radosgw多站点</strong>指的是在多个地理位置或数据中心之间进行数据复制和同步，用于实现负载均衡、灾备恢复以及满足数据在特定地理位置存储要求。</p><ul><li><p><strong>zone</strong>:<br>  多站点中最小的配置单元，通俗指在同一地域内，电力和网络互相独立的物理区域。每个 zone 都有一个或多个 ceph-radosgw 实例。</p></li><li><p><strong>zone group</strong>:</p><p>  由一个或多zone组成，包含一个master zone，其它zone称为secondary zone，zone group内的zone之间同步数据，以实现数据备份和灾难恢复。并且支持active-active与active-passive两种模式。</p></li><li><p><strong>realm</strong>:</p><p>  由一个或多zone group组成，包含一个master zone group,其它zone group称为secondary zone group。</p></li></ul><ul><li><p><strong>period</strong>：</p><p>  跟踪zone、zone group和realm的配置状态。</p></li></ul><span id="more"></span><p><strong>中英文对照表</strong></p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>zone</td><td>区域或站点</td></tr><tr><td>master zone</td><td>主区域或主站点</td></tr><tr><td>secondary zone</td><td>备区域或备站点</td></tr><tr><td>zone group</td><td>区域组</td></tr><tr><td>master zone group</td><td>主区域组</td></tr><tr><td>secondary zone group</td><td>备区域组</td></tr><tr><td>realm</td><td>域</td></tr></tbody></table><h2 id="1-2-演示环境说明"><a href="#1-2-演示环境说明" class="headerlink" title="1.2 演示环境说明"></a>1.2 演示环境说明</h2><div align=center><img src="rgw_multisite.png"></div><p>演示环境为单realm下的单zone group，zone group内有两个zone。<font color=red><strong>bingo-A为已存放数据的老集群，准备作为主站点，bingo-B为未存放数据的新集群，用来作为灾备的备站点</strong></font>。bingo-A与bingo-B的Ceph版本为12.2.x。</p><h1 id="二、主站点配置"><a href="#二、主站点配置" class="headerlink" title="二、主站点配置"></a>二、主站点配置</h1><h2 id="2-1-主站点环境查看"><a href="#2-1-主站点环境查看" class="headerlink" title="2.1 主站点环境查看"></a>2.1 主站点环境查看</h2><p>radosgw安装后会在Ceph集群创建一些带有<code>rgw</code>的名字的pool。如果上传过对象还会自动创建<code>default.rgw.buckets.index</code>和<code>default.rgw.buckets.data</code>这两个pool。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# ceph osd pool <span class="built_in">ls</span> | grep rgw</span><br><span class="line">.rgw.root</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br><span class="line">default.rgw.buckets.index</span><br><span class="line">default.rgw.buckets.data</span><br></pre></td></tr></table></figure><p>bingo-A已经存放了数据，为后续测试向bingo-B数据同步做铺垫。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# ceph <span class="built_in">df</span></span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE        AVAIL       RAW USED     %RAW USED </span><br><span class="line">    1.83TiB     1.81TiB      14.0GiB          0.75 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                          ID      USED        %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    .rgw.root                     157     1.09KiB         0        440GiB           4 </span><br><span class="line">    default.rgw.control           158          0B         0        440GiB           8 </span><br><span class="line">    default.rgw.meta              159        786B         0        440GiB           5 </span><br><span class="line">    default.rgw.log               160          0B         0        440GiB         175 </span><br><span class="line">    default.rgw.buckets.index     161          0B         0        440GiB          16 </span><br><span class="line">    default.rgw.buckets.data      162     15.3MiB         0        440GiB           5  <span class="comment"># 已存有数据</span></span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：配置主站点前如果<code>ceph.conf</code>中有<code>rgw_admin_entry</code>选项请先删掉。</strong></font></p><h2 id="2-2-创建域"><a href="#2-2-创建域" class="headerlink" title="2.2 创建域"></a>2.2 创建域</h2><p>radosgw多站点中，可能存在不同的zone group和zone。然而，它们必须在realm中协同工作。所有的radosgw从master zone group的master zone主机上的<code>ceph-radosgw</code>守护进程检索其配置。</p><h3 id="2-2-1创建前查看"><a href="#2-2-1创建前查看" class="headerlink" title="2.2.1创建前查看"></a>2.2.1创建前查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,   <span class="comment"># 可以看到当前没有realm</span></span><br><span class="line">    <span class="string">&quot;realms&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-创建"><a href="#2-2-2-创建" class="headerlink" title="2.2.2  创建"></a>2.2.2  创建</h3><p><code>radosgw-admin realm create --rgw-realm=&#123;realm-name&#125; [--default]</code></p><ul><li><p>参数说明：</p><p>  –default：设置该realm为默认realm。如果没有指定 <code>--default</code>，添加 zone-groups 和zone需要指定 <code>--rgw-realm 标志或 --realm-id</code> 标志，以便在添加 zone group 和 zone 时标识realm。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在创建了realm 后，radosgw-admin 将回显 realm 配置</span><br><span class="line">[root@node-10 ~]# radosgw-admin realm create --rgw-realm=gz --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-验证"><a href="#2-2-3-验证" class="headerlink" title="2.2.3 验证"></a>2.2.3 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-重命名默认区域组和区域"><a href="#2-3-重命名默认区域组和区域" class="headerlink" title="2.3 重命名默认区域组和区域"></a>2.3 重命名默认区域组和区域</h2><h3 id="2-3-1-重命名前查看"><a href="#2-3-1-重命名前查看" class="headerlink" title="2.3.1 重命名前查看"></a>2.3.1 重命名前查看</h3><p>通常情况下，radosgw启动后会自动创建一个名为<strong>default</strong>的zone group，并且会在该zone group下自动创建一个名为<strong>default</strong>的zone。可以通过下面命令查看验证。</p><p><code>radosgw-admin zonegroup list </code> ：查看所有的zone group</p><p><code>radosgw-admin zonegroup get --rgw-zonegroup=&#123;zone-group-name&#125;</code>：查看某个zone group详细信息</p><p><code>radosgw-admin zone list </code> ：查看所有的zone</p><p><code>radosgw-admin zone get --rgw-zone=&#123;zone-name&#125;</code>：查看某个zone详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get --rgw-zonegroup=default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone list</span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone get --rgw-zone=default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-重命名"><a href="#2-3-2-重命名" class="headerlink" title="2.3.2 重命名"></a>2.3.2 重命名</h3><p><code>radosgw-admin zonegroup rename --rgw-zonegroup &#123;zone-group-name&#125; --zonegroup-new-name=&#123;new-zone-group-name&#125;</code></p><p><code> radosgw-admin zone rename --rgw-zonegroup &#123;zone-group-name&#125; --rgw-zone &#123;zone name&#125; --zone-new-name=&#123;new-zone-name&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup rename --rgw-zonegroup default --zonegroup-new-name=bingo</span><br><span class="line">[root@node-10 ~]# radosgw-admin zone rename --rgw-zonegroup bingo --rgw-zone default --zone-new-name=bingo-A</span><br></pre></td></tr></table></figure><h3 id="2-3-3-验证"><a href="#2-3-3-验证" class="headerlink" title="2.3.3 验证"></a>2.3.3 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123; <span class="comment"># 如果还有名为default的zone group不用在意</span></span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;bingo&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get --rgw-zonegroup=bingo</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>, <span class="comment"># id 没有变</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>, <span class="comment"># zone group已改名</span></span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone list</span><br><span class="line">&#123; <span class="comment"># 如果还有名为default的zone不用在意</span></span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;bingo-A&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@node-10 ~]# radosgw-admin zone get --rgw-zone=bingo-A</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># id没有改变</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>, <span class="comment"># zone已改名</span></span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-设置主区域组和主区域"><a href="#2-4-设置主区域组和主区域" class="headerlink" title="2.4 设置主区域组和主区域"></a>2.4 设置主区域组和主区域</h2><h3 id="2-4-1-设置主区域组"><a href="#2-4-1-设置主区域组" class="headerlink" title="2.4.1 设置主区域组"></a>2.4.1 设置主区域组</h3><p><code>radosgw-admin zonegroup modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --endpoints=&#123;url&#125; --master --default</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup modify --rgw-realm=gz --rgw-zonegroup=bingo --endpoints=http://10.16.205.10:80 --master --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># master zone group</span></span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-设置主区域"><a href="#2-4-2-设置主区域" class="headerlink" title="2.4.2 设置主区域"></a>2.4.2 设置主区域</h3><p><code>radosgw-admin zone modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125; --master --default </code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-realm=gz --rgw-zonegroup=bingo --rgw-zone=bingo-A --endpoints=http://10.16.205.10:80 --master --default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-验证"><a href="#2-4-3-验证" class="headerlink" title="2.4.3 验证"></a>2.4.3 验证</h3><p><code>radosgw-admin zonegroup get [ --rgw-zonegroup=&#123;zone-group-name&#125; ]</code></p><p>说明：</p><ul><li>在2.4.1节设置主区域组的时候已将bingo设置为default zone group，以后zone group操作如果没有指定名字，则默认是bingo这个zone group。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-创建系统同步用户"><a href="#2-5-创建系统同步用户" class="headerlink" title="2.5 创建系统同步用户"></a>2.5 创建系统同步用户</h2><p>secondary zone必须向master zone获取realm和period用于数据同步，获取前需要进行身份验证，我们需要在master zone上创建一个系统级别用户用于身份验证。</p><h3 id="2-5-1-创建前查看"><a href="#2-5-1-创建前查看" class="headerlink" title="2.5.1 创建前查看"></a>2.5.1 创建前查看</h3><p><code>radosgw-admin user info --uid=&#123;user-name&#125;</code>：查看用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user info --uid=sync-user</span><br><span class="line">could not fetch user info: no user info saved <span class="comment"># 此用户名不存在，可以创建</span></span><br></pre></td></tr></table></figure><h3 id="2-5-2-创建"><a href="#2-5-2-创建" class="headerlink" title="2.5.2 创建"></a>2.5.2 创建</h3><p><code>radosgw-admin user create --uid=&quot;&#123;user-name&#125;&quot; --display-name=&quot;&#123;display-name&#125;&quot; --system</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user create --uid=<span class="string">&quot;sync-user&quot;</span> --display-name=<span class="string">&quot;Sync User&quot;</span> --system</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display_name&quot;</span>: <span class="string">&quot;Sync User&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;suspended&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;max_buckets&quot;</span>: 100,</span><br><span class="line">    <span class="string">&quot;auid&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;subusers&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;keys&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;swift_keys&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;caps&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;op_mask&quot;</span>: <span class="string">&quot;read, write, delete&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 系统级别用户</span></span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;placement_tags&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;bucket_quota&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;check_on_raw&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;max_size&quot;</span>: -1,</span><br><span class="line">        <span class="string">&quot;max_size_kb&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;max_objects&quot;</span>: 10000000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;rgw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-验证"><a href="#2-5-3-验证" class="headerlink" title="2.5.3 验证"></a>2.5.3 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin user info --uid=sync-user</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display_name&quot;</span>: <span class="string">&quot;Sync User&quot;</span>,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;suspended&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;max_buckets&quot;</span>: 100,</span><br><span class="line">    <span class="string">&quot;auid&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;subusers&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;keys&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: <span class="string">&quot;sync-user&quot;</span>,</span><br><span class="line">            <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;swift_keys&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;caps&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;op_mask&quot;</span>: <span class="string">&quot;read, write, delete&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 系统级别用户</span></span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;placement_tags&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;bucket_quota&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;check_on_raw&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;max_size&quot;</span>: -1,</span><br><span class="line">        <span class="string">&quot;max_size_kb&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;max_objects&quot;</span>: 10000000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;rgw&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-绑定域"><a href="#2-6-绑定域" class="headerlink" title="2.6 绑定域"></a>2.6 绑定域</h2><p>将zone和zone group与realm绑定。</p><h3 id="2-6-1-绑定前查看"><a href="#2-6-1-绑定前查看" class="headerlink" title="2.6.1 绑定前查看"></a>2.6.1 绑定前查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-绑定realm"><a href="#2-6-2-绑定realm" class="headerlink" title="2.6.2 绑定realm"></a>2.6.2 绑定realm</h3><p><code>radosgw-admin zone modify --rgw-realm=&#123;realm-name&#125; --rgw-zonegroup=&#123;zone-group-name&#125; --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125; --access-key=&#123;key&#125; --secret=&#123;key&#125; --master --default</code></p><p><strong>说明：<code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-realm=<span class="string">&quot;gz&quot;</span> --rgw-zonegroup=<span class="string">&quot;bingo&quot;</span> --rgw-zone=<span class="string">&quot;bingo-A&quot;</span> --endpoints=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti --master --default</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span> <span class="comment"># 与gz这个realm绑定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-3-验证"><a href="#2-6-3-验证" class="headerlink" title="2.6.3 验证"></a>2.6.3 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-应用变更"><a href="#2-7-应用变更" class="headerlink" title="2.7 应用变更"></a>2.7 应用变更</h2><p>应用变更period，同一个zone group的其它zone会接收新的配置变更。</p><h3 id="2-7-1-变更前查看"><a href="#2-7-1-变更前查看" class="headerlink" title="2.7.1 变更前查看"></a>2.7.1 变更前查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-2-变更"><a href="#2-7-2-变更" class="headerlink" title="2.7.2 变更"></a>2.7.2 变更</h3><p><code> radosgw-admin period update --commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2 <span class="comment"># epoch从1变为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-3-验证"><a href="#2-7-3-验证" class="headerlink" title="2.7.3 验证"></a>2.7.3 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2 <span class="comment"># epoch从1变为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-重启服务"><a href="#2-8-重启服务" class="headerlink" title="2.8 重启服务"></a>2.8 重启服务</h2><p>更新master zone主机上的<code>ceph.conf</code>配置文件，添加<code>rgw_zone</code>配置选项。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[client.radosgw]下添加配置:</span><br><span class="line">rgw<span class="built_in">_</span>zone=bingo-A</span><br></pre></td></tr></table></figure><p>重启radosgw服务</p><p><code> systemctl restart ceph-radosgw@radosgw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><h2 id="2-9-查看同步状态"><a href="#2-9-查看同步状态" class="headerlink" title="2.9 查看同步状态"></a>2.9 查看同步状态</h2><p><code>radosgw-admin sync status</code> ：查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-A为主站点</span></span><br></pre></td></tr></table></figure><h1 id="三、备站点配置"><a href="#三、备站点配置" class="headerlink" title="三、备站点配置"></a>三、备站点配置</h1><h2 id="3-1-备站点环境查看"><a href="#3-1-备站点环境查看" class="headerlink" title="3.1 备站点环境查看"></a>3.1 备站点环境查看</h2><p>通常情况下，radosgw启动后会自动创建一个名为<strong>default</strong>的zone group，并且会在该zone group下自动创建一个名为<strong>default</strong>的zone。可以通过下面命令查看验证。</p><p><code>radosgw-admin zonegroup list</code> ：查看所有的zone group</p><p><code>radosgw-admin zone list</code> ：查看所有的zone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;bd5c6fa4-695f-4017-8bc1-fd2fe5ee045f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;f01ddceb-92cb-4ffb-850f-099df6aecaab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;default&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>radosgw启动后会在集群中自动创建一些带有<code>rgw</code>名字的pool，<font color=red>本演示环境中bingo-B为全新集群，里面没存储任何数据。</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph osd pool <span class="built_in">ls</span> | grep rgw</span><br><span class="line">.rgw.root</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br></pre></td></tr></table></figure><p><font color=red>假设使用新安装的集群进行多站点配置，尚未使用默认<code>zone</code>及其<code>pool</code>来存储数据，那么可以把默认<code>zone</code>和<code>pool</code>删除。如果已存在数据将会丢失并不可恢复。</font></p><p>删除默认zone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone delete --rgw-zone=default</span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone list</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;default_info&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除radosgw自动创建的默认pool（务必确认rgw尚未存数据）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph osd pool <span class="built_in">ls</span> | grep -F default.rgw.</span><br><span class="line">default.rgw.control</span><br><span class="line">default.rgw.meta</span><br><span class="line">default.rgw.log</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.control default.rgw.control --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.control</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.meta default.rgw.meta --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.meta</span><br><span class="line">[root@ceph-single-cluster ~]# rados rmpool default.rgw.log default.rgw.log --yes-i-really-really-mean-it</span><br><span class="line">successfully deleted pool default.rgw.log</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：配置备站点前如果<code>ceph.conf</code>配置文件中有 <code>rgw_admin_entry</code>选项请先删掉此选项。</strong></font></p><h2 id="3-2-从主站点拉取域"><a href="#3-2-从主站点拉取域" class="headerlink" title="3.2 从主站点拉取域"></a>3.2 从主站点拉取域</h2><p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p><p>说明：</p><ul><li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti </span><br><span class="line">2023-09-10 19:04:56.407005 7f1b46286f80  1 error read_lastest_epoch .rgw.root:periods.2a11b308-6430-47d2-8059-76894abfb74c.latest_epoch <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:04:56.567897 7f1b46286f80  1 Set the period<span class="string">&#x27;s master zonegroup 89129545-7900-46a3-be71-943a85bba582 as the default</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;id&quot;: &quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;,</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;gz&quot;,</span></span><br><span class="line"><span class="string">    &quot;current_period&quot;: &quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;,</span></span><br><span class="line"><span class="string">    &quot;epoch&quot;: 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>设置<code>gz</code>为默认realm。</p><p><code>radosgw-admin realm default --rgw-realm=&#123;realm-name&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm default --rgw-realm=gz</span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm get-default</span><br><span class="line">default realm: 31a49490-d7f4-42c6-ad88-15493474a3d5</span><br></pre></td></tr></table></figure><h2 id="3-3-从主站点拉取-period"><a href="#3-3-从主站点拉取-period" class="headerlink" title="3.3 从主站点拉取 period"></a>3.3 从主站点拉取 period</h2><p><code>radosgw-admin period pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p><p>说明：<code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period  pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z  --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti </span><br><span class="line">2023-09-10 19:07:24.203099 7f084e32ff80  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-创建备区域"><a href="#3-4-创建备区域" class="headerlink" title="3.4 创建备区域"></a>3.4 创建备区域</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">radosgw-admin zone create --rgw-zonegroup=&#123;zone-group-name&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                          --rgw-zone=&#123;zone-name&#125; --endpoints=&#123;url&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                           --access-key=&#123;system-key&#125; --secret=&#123;secret&#125;<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>                           [--read-only]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>–read-only：默认所有zone都以<code>active-active</code>模式运行；即客户端可能会将数据写入任何zone，zone会将数据复制到 zone group 中的所有其他 zone。如果 second zone 不接受写操作，请指定 <code>--read-only</code> 标志，以<code>active-passive</code>模式运行。</li><li><font color=red >本次演示环境会将bingo-B zone设置为read-only。</font></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone create --rgw-zonegroup=bingo --rgw-zone=bingo-B --endpoints=http://10.3.23.136:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti --read-only</span><br><span class="line">2023-09-10 19:10:40.661862 7faea03c2f80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:10:40.661947 7faea03c2f80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可以忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;hostnames&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;hostnames_s3website&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tier_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from_all&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sync_from&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span> <span class="comment"># url为bingo-B的radosgw地址</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-应用变更"><a href="#3-5-应用变更" class="headerlink" title="3.5 应用变更"></a>3.5 应用变更</h2><p>应用变更period，其他zone会接收新的配置。</p><p><code>radosgw-admin period update --commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">2023-09-10 19:13:52.621606 7fb130a12f80  1 Cannot find zone <span class="built_in">id</span>=3b06b85f-8266-4e44-91ee-e0b334f619c5 (name=bingo-B), switching to <span class="built_in">local</span> zonegroup configuration <span class="comment"># 该信息可忽略</span></span><br><span class="line">Sending period to new master zone 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;e3f5f0c1-1ede-4ce5-ae07-d48367b4a28b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-重启服务"><a href="#3-6-重启服务" class="headerlink" title="3.6 重启服务"></a>3.6 重启服务</h2><p>更新备站点主机上的<code>ceph.conf</code>配置文件，添加<code>rgw_zone</code>配置选项。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[client.radosgw]下添加配置:</span><br><span class="line">rgw<span class="built_in">_</span>zone=bingo-B</span><br></pre></td></tr></table></figure><p>重启radosgw服务</p><p><code> systemctl restart ceph-radosgw@radosgw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><h2 id="3-7-验证同步"><a href="#3-7-验证同步" class="headerlink" title="3.7 验证同步"></a>3.7 验证同步</h2><p><code>radosgw-admin sync status</code>：查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing</span><br><span class="line">                full <span class="built_in">sync</span>: 3/64 shards</span><br><span class="line">                full <span class="built_in">sync</span>: 2 entries to <span class="built_in">sync</span></span><br><span class="line">                incremental <span class="built_in">sync</span>: 61/64 shards</span><br><span class="line">                metadata is behind on 3 shards</span><br><span class="line">                behind shards: [28,44,61]</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 16/128 shards</span><br><span class="line">                        full <span class="built_in">sync</span>: 16 buckets to <span class="built_in">sync</span></span><br><span class="line">                        incremental <span class="built_in">sync</span>: 112/128 shards</span><br><span class="line">                        data is behind on 16 shards</span><br><span class="line">                        behind shards: [50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65] <span class="comment"># 数据同步中</span></span><br><span class="line"><span class="comment"># 数据同步时间与数据量大小有关，可以隔一段时间再查看同步是否完成 </span></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-B为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span> <span class="comment"># 数据同步完成</span></span><br></pre></td></tr></table></figure><p>查看pool中是否有从<code>bingo-A master zone</code>同步过来的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# ceph <span class="built_in">df</span></span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE       AVAIL      RAW USED     %RAW USED </span><br><span class="line">    240GiB     239GiB       502MiB          0.20 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME                          ID      USED        %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    .rgw.root                     96      5.20KiB         0       75.8GiB          19 </span><br><span class="line">    bingo-B.rgw.control           100          0B         0       75.8GiB           8 </span><br><span class="line">    bingo-B.rgw.meta              101     1.12KiB         0       75.8GiB           7 </span><br><span class="line">    bingo-B.rgw.log               102     7.87KiB         0       75.8GiB         565 </span><br><span class="line">    default.rgw.meta              103          0B         0       75.8GiB           0 </span><br><span class="line">    bingo-B.rgw.buckets.index     104          0B         0       75.8GiB          16 </span><br><span class="line">    bingo-B.rgw.buckets.data      105     15.3MiB      0.02       75.8GiB           5 <span class="comment"># 数据通过过来了</span></span><br></pre></td></tr></table></figure><h1 id="四、故障切换和灾难恢复"><a href="#四、故障切换和灾难恢复" class="headerlink" title="四、故障切换和灾难恢复"></a>四、故障切换和灾难恢复</h1><h2 id="4-1-故障切换"><a href="#4-1-故障切换" class="headerlink" title="4.1 故障切换"></a>4.1 故障切换</h2><p>模拟<code>bingo-A master zone</code>故障，切换到<code>bingo-B secondary zone</code>。</p><h3 id="4-1-1-模拟主站点故障"><a href="#4-1-1-模拟主站点故障" class="headerlink" title="4.1.1 模拟主站点故障"></a>4.1.1 模拟主站点故障</h3><p>可将<code>bingo-A</code>的radosgw服务停止来模拟发生了故障。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl stop ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><h3 id="4-1-2-切换到备站点"><a href="#4-1-2-切换到备站点" class="headerlink" title="4.1.2 切换到备站点"></a>4.1.2 切换到备站点</h3><p>在<code>bingo-B</code>上查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">2023-09-10 19:19:25.833927 7f02e814ff80  0 meta <span class="built_in">sync</span>: ERROR: failed to fetch mdlog info</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># 可以发现同步异常</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                failed to fetch <span class="built_in">local</span> <span class="built_in">sync</span> status: (5) Input/output error</span><br><span class="line">2023-09-10 19:19:25.835667 7f02e814ff80  0 data <span class="built_in">sync</span>: ERROR: failed to fetch datalog info</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        failed to retrieve <span class="built_in">sync</span> info: (5) Input/output error</span><br></pre></td></tr></table></figure><p>将<code>bingo-B</code> secondary zone设置为master和default zone。</p><p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default [ --read-only=false ]</code></p><p>说明：</p><ul><li>由于<code>bingo-B</code>zone为read-only，现在设置其为master zone需要将read-only取消，客户端才能写数据。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --master --default --read-only=<span class="literal">false</span></span><br><span class="line">2023-09-10 19:20:21.908757 7f746122ff80  0 NOTICE: overriding master zone: 2dfd246d-bf16-4053-93e4-1f78570f775b </span><br><span class="line">2023-09-10 19:20:21.909132 7f746122ff80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可以忽略</span></span><br><span class="line">2023-09-10 19:20:21.909158 7f746122ff80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可以忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证<code>bingo-B</code>是否为master zone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>, <span class="comment"># bingo-B为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>, <span class="comment"># 客户端可以写入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用变更。</p><p><code>radosgw-admin period update --commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;2a11b308-6430-47d2-8059-76894abfb74c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-B</code>上重新启动radosgw服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><p>查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-B为主站点了</span></span><br><span class="line">2023-09-10 19:25:56.038789 7fefb3febf80  0 data <span class="built_in">sync</span>: ERROR: failed to fetch datalog info <span class="comment"># bingo-A故障了</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        failed to retrieve <span class="built_in">sync</span> info: (5) Input/output error</span><br></pre></td></tr></table></figure><h2 id="4-2-灾难恢复"><a href="#4-2-灾难恢复" class="headerlink" title="4.2 灾难恢复"></a>4.2 灾难恢复</h2><p>假设<code>bingo-A</code>恢复正常了，现在重新将master zone切换到<code>bingo-A</code>。</p><h3 id="4-2-1-主站点恢复"><a href="#4-2-1-主站点恢复" class="headerlink" title="4.2.1 主站点恢复"></a>4.2.1 主站点恢复</h3><p>将之前模拟故障的<code>bingo-A</code>的radosgw服务重新启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl status ceph-radosgw@radosgw</span><br><span class="line">○ ceph-radosgw@radosgw.service - Ceph rados gateway</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/ceph-radosgw@.service; enabled; vendor preset: disabled)</span><br><span class="line">     Active: inactive (dead) since 2023-09-10 19:27:01 CST; 11min ago</span><br><span class="line">    Process: 204125 ExecStart=/usr/bin/radosgw -f --cluster <span class="variable">$&#123;CLUSTER&#125;</span> --name client.radosgw --setuser ceph --setgroup ceph (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 204125 (code=exited, status=0/SUCCESS)</span><br><span class="line">[root@node-10 ~]# systemctl start ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# systemctl status ceph-radosgw@radosgw</span><br><span class="line">● ceph-radosgw@radosgw.service - Ceph rados gateway</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/ceph-radosgw@.service; enabled; vendor preset: disabled)</span><br><span class="line">     Active: active (running) since Sun 2023-09-10 19:27:08 CST; 30s ago</span><br><span class="line">   Main PID: 267097 (radosgw)</span><br><span class="line">      Tasks: 593</span><br><span class="line">     Memory: 51.9M</span><br><span class="line">     CGroup: /system.slice/system-ceph\x2dradosgw.slice/ceph-radosgw@radosgw.service</span><br><span class="line">             └─ 267097 /usr/bin/radosgw -f --cluster ceph --name client.radosgw --setuser ceph --setgroup ceph</span><br></pre></td></tr></table></figure><p>查看当前<code>bingo-A</code>同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-A现在为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>在<code>bingo-A</code>上拉取realm</p><p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p><p>说明：</p><ul><li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin realm pull --url=http://10.3.23.136:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti</span><br><span class="line">2023-09-10 19:31:52.430554 7fe3e6f4e080  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-A</code>的radosgw上将<code>bingo-A</code>重新设为master和default zone。</p><p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zone modify --rgw-zone=bingo-A --master --default</span><br><span class="line">2023-09-10 19:32:19.697172 7fcb30974080  0 NOTICE: overriding master zone: 3b06b85f-8266-4e44-91ee-e0b334f619c5</span><br><span class="line">2023-09-10 19:32:19.698813 7fcb30974080  0 failed reading obj info from .rgw.root:zone_info.3b06b85f-8266-4e44-91ee-e0b334f619c5: (2) No such file or directory <span class="comment"># 该错误信息可忽略</span></span><br><span class="line">2023-09-10 19:32:19.698831 7fcb30974080  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=3b06b85f-8266-4e44-91ee-e0b334f619c5 name=bingo-B <span class="comment"># 该警告信息可忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;default.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;default.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;default.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;default.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;default.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;default.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;default.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;default.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-A</code>上应用更新。</p><p><code>radosgw-admin period update --commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># bingo-A为master zone</span></span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-A</code>上重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><p>查看<code>bingo-A</code>同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># bingo-A变为主站点</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-设置备站点"><a href="#4-2-2-设置备站点" class="headerlink" title="4.2.2 设置备站点"></a>4.2.2 设置备站点</h3><p>在<code>bingo-B</code>上查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master) <span class="comment"># 可以看到bingo-B现在还是master zone，需要拉取最新的realm</span></span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>在<code>bingo-B</code>上拉取realm</p><p><code>radosgw-admin realm pull --url=&#123;url-to-master-zone-gateway&#125; --access-key=&#123;access-key&#125; --secret=&#123;secret&#125;</code></p><p>说明：</p><ul><li><code>access-key</code>和<code>secret</code>为2.5节创建的系统用户。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin realm pull --url=http://10.16.205.10:80 --access-key=WB55YP5G6WSB36PQLM2Z --secret=aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti</span><br><span class="line">2023-09-10 19:41:25.065698 7f21fb0d7f80  1 found existing latest_epoch 1 &gt;= given epoch 1, returning r=-17</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;current_period&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># bingo-A为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>, <span class="comment"># bingo-B现在还不是只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>我们之前规划中<code>bingo-B</code>为read-only，所以现在需要将<code>bingo-B</code>状态设置为read-only。</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --read-only</span><br><span class="line">2023-09-10 19:42:50.451069 7f3042436f80  0 failed reading obj info from .rgw.root:zone_info.2dfd246d-bf16-4053-93e4-1f78570f775b: (2) No such file or directory <span class="comment"># 该错误信息可忽略</span></span><br><span class="line">2023-09-10 19:42:50.451088 7f3042436f80  0 WARNING: could not <span class="built_in">read</span> zone params <span class="keyword">for</span> zone <span class="built_in">id</span>=2dfd246d-bf16-4053-93e4-1f78570f775b name=bingo-A <span class="comment"># 该警告信息可忽略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;placement_pools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;key&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">            <span class="string">&quot;val&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;index_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.index&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;data_extra_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.buckets.non-ec&quot;</span>,</span><br><span class="line">                <span class="string">&quot;index_type&quot;</span>: 0,</span><br><span class="line">                <span class="string">&quot;compression&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;metadata_heap&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tier_config&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证<code>bingo-B</code>是否为read-only</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-B</code>上应用变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">Sending period to new master zone 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 2,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>bingo-B</code>上重启服务</p><p><code> systemctl restart ceph-radosgw@radosgw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><p>查看<code>bingo-B</code>同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># bingo-B变为备站点</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h1 id="五、解除主备站点同步"><a href="#五、解除主备站点同步" class="headerlink" title="五、解除主备站点同步"></a>五、解除主备站点同步</h1><p>当<code>bingo-A和bingo-B</code>两个zone不需要同步时，解除之间的同步关系。</p><h2 id="5-1-主站点移除备站点"><a href="#5-1-主站点移除备站点" class="headerlink" title="5.1 主站点移除备站点"></a>5.1 主站点移除备站点</h2><h3 id="5-1-1-移除备站点"><a href="#5-1-1-移除备站点" class="headerlink" title="5.1.1 移除备站点"></a>5.1.1 移除备站点</h3><p>移除前查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>移除<code>bingo-B</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin zonegroup remove --rgw-zonegroup=bingo --rgw-zone=bingo-B</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-应用变更"><a href="#5-1-2-应用变更" class="headerlink" title="5.1.2 应用变更"></a>5.1.2 应用变更</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 3,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;44ae139b-9ebf-47e3-a387-c65bafefdbd5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;placement_targets&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;tags&quot;</span>: []</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;default_placement&quot;</span>: <span class="string">&quot;default-placement&quot;</span>,</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-重启服务"><a href="#5-1-3-重启服务" class="headerlink" title="5.1.3 重启服务"></a>5.1.3 重启服务</h3><p><code> systemctl restart ceph-radosgw@radosgw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><h3 id="5-1-4-验证"><a href="#5-1-4-验证" class="headerlink" title="5.1.4 验证"></a>5.1.4 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@node-10 ~]# systemctl restart ceph-radosgw@radosgw</span><br><span class="line">[root@node-10 ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A) <span class="comment"># bingo-B同步关系已经移除</span></span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line">[root@node-10 ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.16.205.10:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-备站点移除主站点"><a href="#5-2-备站点移除主站点" class="headerlink" title="5.2 备站点移除主站点"></a>5.2 备站点移除主站点</h2><h3 id="5-2-1-移除主站点"><a href="#5-2-1-移除主站点" class="headerlink" title="5.2.1 移除主站点"></a>5.2.1 移除主站点</h3><p>移除前查看同步状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> syncing <span class="comment"># 在主站点移除备站点后，bingo-B没有机会更新同步信息</span></span><br><span class="line">                full <span class="built_in">sync</span>: 0/64 shards</span><br><span class="line">                incremental <span class="built_in">sync</span>: 64/64 shards</span><br><span class="line">                metadata is caught up with master</span><br><span class="line">      data <span class="built_in">sync</span> <span class="built_in">source</span>: 2dfd246d-bf16-4053-93e4-1f78570f775b (bingo-A)</span><br><span class="line">                        syncing</span><br><span class="line">                        full <span class="built_in">sync</span>: 0/128 shards</span><br><span class="line">                        incremental <span class="built_in">sync</span>: 128/128 shards</span><br><span class="line">                        data is caught up with <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>移除<code>bingo-A</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup remove --rgw-zonegroup=bingo --rgw-zone=bingo-A</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.16.205.10:80&quot;</span> <span class="comment"># zone group 还指向bingo-A的radosgw地址</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;2dfd246d-bf16-4053-93e4-1f78570f775b&quot;</span>, <span class="comment"># master zone还指向bingo-A</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;true&quot;</span>, <span class="comment"># 只读</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-设置主区域"><a href="#5-2-2-设置主区域" class="headerlink" title="5.2.2 设置主区域"></a>5.2.2 设置主区域</h3><p><code>radosgw-admin zone modify --rgw-zone=&#123;zone-name&#125; --master --default [ --read-only=false ]</code></p><p>说明：</p><ul><li>–read-only：可选，由于<code>bingo-B</code>在规划中是read-only，现在<code>bingo-B</code>变为master zone，客户端需要写数据，要取消read-only状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zone modify --rgw-zone=bingo-B --master --default --read-only=<span class="literal">false</span></span><br><span class="line">2023-09-10 20:03:22.646446 7f2c932a9f80  0 NOTICE: overriding master zone: 2dfd246d-bf16-4053-93e4-1f78570f775b</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">    <span class="string">&quot;domain_root&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;control_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.control&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:gc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lc_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:lc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;intent_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:intent&quot;</span>,</span><br><span class="line">    <span class="string">&quot;usage_log_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:usage&quot;</span>,</span><br><span class="line">    <span class="string">&quot;reshard_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.log:reshard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_keys_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.keys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_email_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.email&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_swift_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.swift&quot;</span>,</span><br><span class="line">    <span class="string">&quot;user_uid_pool&quot;</span>: <span class="string">&quot;bingo-B.rgw.meta:users.uid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;system_key&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;access_key&quot;</span>: <span class="string">&quot;WB55YP5G6WSB36PQLM2Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;secret_key&quot;</span>: <span class="string">&quot;aXyw6Ck6MV85OZaC3bgwaMYB3pI7Dr4i9ogyBIti&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新zone group的url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup modify --rgw-realm=gz --rgw-zonegroup=bingo --endpoints=http://10.3.23.136:80 --master --default</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span> <span class="comment"># zone group的url已经更新</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>, <span class="comment"># bingo-B为master zone</span></span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-3-应用变更"><a href="#5-2-3-应用变更" class="headerlink" title="5.2.3 应用变更"></a>5.2.3 应用变更</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin period update --commit</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;8f69cdf6-13af-476a-9647-6a174ea3bcc9&quot;</span>,</span><br><span class="line">    <span class="string">&quot;epoch&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;predecessor_uuid&quot;</span>: <span class="string">&quot;d45e8a76-c27f-4ecc-b381-7504feafbddb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sync_status&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;period_map&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;8f69cdf6-13af-476a-9647-6a174ea3bcc9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;zonegroups&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                            <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">                        <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;master_zonegroup&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_name&quot;</span>: <span class="string">&quot;gz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;realm_epoch&quot;</span>: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-4-重启服务"><a href="#5-2-4-重启服务" class="headerlink" title="5.2.4 重启服务"></a>5.2.4 重启服务</h3><p>重启radosgw服务</p><p><code> systemctl restart ceph-radosgw@radosgw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# systemctl restart ceph-radosgw@radosgw</span><br></pre></td></tr></table></figure><h3 id="5-2-5-验证"><a href="#5-2-5-验证" class="headerlink" title="5.2.5 验证"></a>5.2.5 验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@ceph-single-cluster ~]# radosgw-admin <span class="built_in">sync</span> status</span><br><span class="line">          realm 31a49490-d7f4-42c6-ad88-15493474a3d5 (gz)</span><br><span class="line">      zonegroup 89129545-7900-46a3-be71-943a85bba582 (bingo)</span><br><span class="line">           zone 3b06b85f-8266-4e44-91ee-e0b334f619c5 (bingo-B)</span><br><span class="line">  metadata <span class="built_in">sync</span> no <span class="built_in">sync</span> (zone is master)</span><br><span class="line"></span><br><span class="line">[root@ceph-single-cluster ~]# radosgw-admin zonegroup get</span><br><span class="line">&#123; <span class="comment"># 回显内容有删减</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;89129545-7900-46a3-be71-943a85bba582&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;api_name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;is_master&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;master_zone&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zones&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="string">&quot;3b06b85f-8266-4e44-91ee-e0b334f619c5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bingo-B&quot;</span>,</span><br><span class="line">            <span class="string">&quot;endpoints&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;http://10.3.23.136:80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;log_meta&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;log_data&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bucket_index_max_shards&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;read_only&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;realm_id&quot;</span>: <span class="string">&quot;31a49490-d7f4-42c6-ad88-15493474a3d5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-概念与术语&quot;&gt;&lt;a href=&quot;#1-1-概念与术语&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念与术语&quot;&gt;&lt;/a&gt;1.1 概念与术语&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;radosgw多站点&lt;/strong&gt;指的是在多个地理位置或数据中心之间进行数据复制和同步，用于实现负载均衡、灾备恢复以及满足数据在特定地理位置存储要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;zone&lt;/strong&gt;:&lt;br&gt;  多站点中最小的配置单元，通俗指在同一地域内，电力和网络互相独立的物理区域。每个 zone 都有一个或多个 ceph-radosgw 实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;zone group&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;  由一个或多zone组成，包含一个master zone，其它zone称为secondary zone，zone group内的zone之间同步数据，以实现数据备份和灾难恢复。并且支持active-active与active-passive两种模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;realm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;  由一个或多zone group组成，包含一个master zone group,其它zone group称为secondary zone group。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;period&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;  跟踪zone、zone group和realm的配置状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Ceph" scheme="https://blog.kjlcloud.com/categories/Ceph/"/>
    
    
    <category term="radosgw" scheme="https://blog.kjlcloud.com/tags/radosgw/"/>
    
  </entry>
  
  <entry>
    <title>C++ 动态内存分配</title>
    <link href="https://blog.kjlcloud.com/2022/08/15/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://blog.kjlcloud.com/2022/08/15/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2022-08-15T04:50:30.000Z</published>
    <updated>2025-03-04T08:57:37.652Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、new-delete"><a href="#一、new-delete" class="headerlink" title="一、new&#x2F;delete"></a>一、new&#x2F;delete</h1><h2 id="1-1-为什么需要new-delete"><a href="#1-1-为什么需要new-delete" class="headerlink" title="1.1 为什么需要new&#x2F;delete"></a>1.1 为什么需要new&#x2F;delete</h2><p>&emsp;C语言中通过<code>malloc/free</code>等函数实现动态内存管理，为什么C++中还引入<code>new/delete</code>对动态内存管理？原因在于：<code>malloc/free</code>等函数不能满足对自定义类型的对象管理要求，对象在创建时要自动调用构造函数，对象在销毁前要自动调用析构函数，由于<code>malloc/free</code>是库函数而不是运算符，编译器不能把调用构造函数和析构函数的任务强加给它们。因为C++需要一个能够完成动态内存分配和初始化工作的运算符<code>new</code>，以及一个能够完成资源释放和释放内存工作的运算符<code>delete</code>。</p><p><strong>注意：<code>new/delete</code>是运算符，而不是函数</strong></p><span id="more"></span><h2 id="1-2-new-delete对内置类型处理"><a href="#1-2-new-delete对内置类型处理" class="headerlink" title="1.2 new&#x2F;delete对内置类型处理"></a>1.2 new&#x2F;delete对内置类型处理</h2><p>&emsp;new&#x2F;delete对内置类型处理与malloc&#x2F;free对内置类型处理没有本质区别，只是用法不一样。new直接返回目标类型的指针，不需要显式类型转换，而malloc返回void*，必须显式地转换为目标类型后使用</p><p>用法：<br><code>类型名* 指针变量名 = new 类型名;    delete 指针变量名;</code><br><code>类型名* 指针变量名 = new 类型名[元素个数];    delete[] 指针变量名;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态开辟1个大小为int的内存空间</span></span><br><span class="line"><span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">5</span>); <span class="comment">// 动态开辟5个大小为int的连续内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p3 = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 动态开辟1个大小为int的内存空间</span></span><br><span class="line"><span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态开辟5个大小为int的连续内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p1); <span class="comment">// 释放起始地址为p1的动态开辟内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p2);  <span class="comment">// 释放起始地址为p2的动态开辟内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p3; <span class="comment">// 释放单个元素内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p4; <span class="comment">// 释放连续的申请的动态内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc与new对内置类型都没有初始化，但可以<code>int* p3 = new int(1); </code>将对应空间值初始化为1</p><h2 id="1-3-new-delete对自定义类型处理"><a href="#1-3-new-delete对自定义类型处理" class="headerlink" title="1.3 new&#x2F;delete对自定义类型处理"></a>1.3 new&#x2F;delete对自定义类型处理</h2><p>&emsp; malloc&#x2F;free对自定义类型只会开辟&#x2F;销毁空间，并不会调用构造函数&#x2F;析构函数。new先开辟空间然后调用构造函数初始化，delete先调用析构函数释放资源然后销毁空间<br><img src="https://i-blog.csdnimg.cn/blog_migrate/db7bbb57bb33950dbded1e17f4383c96.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line"><span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line"><span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> capacity = <span class="number">5</span>)</span><br><span class="line">:_size(<span class="number">0</span>)</span><br><span class="line">,_capacity(capacity)</span><br><span class="line">&#123;</span><br><span class="line">_data = <span class="keyword">new</span><span class="built_in">ElemType</span>(capacity);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _data;</span><br><span class="line">_data = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSeq</span><span class="params">(<span class="type">int</span> capacity = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_data = <span class="keyword">new</span><span class="built_in">ElemType</span>(capacity);</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">_capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestorySeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> _data;</span><br><span class="line">_data = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SeqList* s1 = (SeqList*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SeqList));</span><br><span class="line">s1-&gt;<span class="built_in">InitSeq</span>(); </span><br><span class="line"><span class="comment">// 业务处理</span></span><br><span class="line">s1-&gt;<span class="built_in">DestorySeq</span>();</span><br><span class="line"><span class="built_in">free</span>(s1);</span><br><span class="line"></span><br><span class="line">SeqList* s2 = <span class="keyword">new</span> SeqList; <span class="comment">// SeqList* s2 = new SeqList(10); 调用有参构造函数</span></span><br><span class="line"><span class="comment">// 业务处理</span></span><br><span class="line"><span class="keyword">delete</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure><p>&emsp;使用malloc为自定义类型分配空间需要手动调用InitSeq函数初始化，业务处理后需要调用DestorySeq函数进行资源释放然后free释放空间，比较麻烦且容易忘记初始化及释放资源。使用new&#x2F;delete会自动调用构造函数&#x2F;析构函数帮我们进行处理</p><h1 id="二、new-delete-实现原理"><a href="#二、new-delete-实现原理" class="headerlink" title="二、new&#x2F;delete 实现原理"></a>二、new&#x2F;delete 实现原理</h1><p>&emsp; <code>new</code>运算符底层是调用<code> operator new</code>函数与<code>构造函数</code>实现的，<code>delete</code>运算符底层是调用<code>析构函数</code>与<code> operator delete</code>函数实现的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/de3cebb1291984fae5026806ccacc15d.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-1-operator-new函数"><a href="#2-1-operator-new函数" class="headerlink" title="2.1 operator new函数"></a>2.1 operator new函数</h2><p>operator new为库函数，源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try to allocate size bytes</span></span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// report no memory</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">_RAISE(nomem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现operator new函数申请空间还是调用malloc函数实现的，申请成功返回地址，申请空间失败会抛出异常。<strong>可以发现之所以用operator new而不是直接用malloc主要是对于申请失败时抛出异常</strong></p><h2 id="2-2-operator-delete函数"><a href="#2-2-operator-delete函数" class="headerlink" title="2.2 operator delete函数"></a>2.2 operator delete函数</h2><p>operator delete为库函数，源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtMemBlockHeader* pHead;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pUserData == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_mlock(_HEAP_LOCK); <span class="comment">/* block other threads */</span></span><br><span class="line">__TRY</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get a pointer to memory block header */</span></span><br><span class="line">pHead = <span class="built_in">pHdr</span>(pUserData);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* verify block type */</span></span><br><span class="line">_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line"></span><br><span class="line">_free_dbg(pUserData, pHead-&gt;nBlockUse);</span><br><span class="line"></span><br><span class="line">__FINALLY</span><br><span class="line">_munlock(_HEAP_LOCK); <span class="comment">/* release other threads */</span></span><br><span class="line">__END_TRY_FINALLY</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator delete 通过调用free来释放空间的。</p><h2 id="2-3-new-delete对内置类型实现原理"><a href="#2-3-new-delete对内置类型实现原理" class="headerlink" title="2.3 new&#x2F;delete对内置类型实现原理"></a>2.3 new&#x2F;delete对内置类型实现原理</h2><p>&emsp;如果申请的是内置类型的空间，new和malloc，delete和free基本类似。<strong>只是new在申请空间失败时会抛异常，malloc会返回NULL</strong></p><h2 id="2-4-new-delete对自定义类型实现原理"><a href="#2-4-new-delete对自定义类型实现原理" class="headerlink" title="2.4 new&#x2F;delete对自定义类型实现原理"></a>2.4 new&#x2F;delete对自定义类型实现原理</h2><p>new:<br>● 先调用operator new函数为对象动态内存分配空间<br>● 然后调用构造函数对对象初始化</p><p>delete:<br>●  先调用析构函数释放资源<br>●  然后调用operator delete函数释放对象的空间</p><p>new [N]:<br>● 先调用operator new[ ]函数对对象动态内存分配空间 (operator new[ ]函数内调用operator new函数实现对N个对象空间分配)<br>●  然后调用N次构造函数对对象初始化</p><p>delete[ ]：<br>●  先调用N次析构函数，对N个对象释放资源<br>●  然后调用operator delete[ ]函数释放空间(operator delete[ ]函数内调用operator delete函数实现对N个对象空间释放)</p><h2 id="2-5-operator-new与operator-delete-函数重载"><a href="#2-5-operator-new与operator-delete-函数重载" class="headerlink" title="2.5 operator new与operator delete 函数重载"></a>2.5 operator new与operator delete 函数重载</h2><p>&emsp;有些情况下希望动态内存空间不是来源于堆而是来源内存池，以提高效率。可以在类中对operator new与operator delete函数重载。类中对象申请&#x2F;释放的是内存池空间，类外还是从堆中申请&#x2F;释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> ListNode* _next;</span><br><span class="line"> ListNode* _prev;</span><br><span class="line"> <span class="type">int</span> _data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="type">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"> p = <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;memory pool allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">deallocate</span>((ListNode*)p, <span class="number">1</span>);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;memory pool deallocate&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三、placement-new"><a href="#三、placement-new" class="headerlink" title="三、placement-new"></a>三、placement-new</h1><p>&emsp; <strong>placement-new：在一块已分配的内存空间上调用构造函数初始化对象或对象数组</strong></p><p>用法：<br><code>new (place_address) type</code><br><code>new (place_address) type(initializer-list)</code><br><code>new (place_address) type[元素个数]</code></p><p>placement-new主要应用场景是配合内存池使用：使用一块较大的动态内存分配空间，用来构造不同类型的对象或对象数组。</p><p><strong>注意：placement-new构造的对象或对象数组要显式调用它们的析构函数进行资源释放，不要使用delete。因为构造起来的对象或对象数组大小并不一定等于原来申请空间大小，使用delete会造成内存泄漏或在之后释放原来申请空间出现运行时错误</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 4  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line"><span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line"><span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> capacity = <span class="number">5</span>)</span><br><span class="line">:_size(<span class="number">0</span>)</span><br><span class="line">,_capacity(capacity)</span><br><span class="line">&#123;</span><br><span class="line">_data = <span class="keyword">new</span><span class="built_in">ElemType</span>(capacity);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _data;</span><br><span class="line">_data = <span class="literal">nullptr</span>;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">SeqList* s1 = (SeqList*)<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(SeqList)); <span class="comment">// 动态内存申请大小为SeqList的空间</span></span><br><span class="line"><span class="keyword">new</span>(s1)SeqList; <span class="comment">// 调用SeqList的默认构造函数对起始地址为s1的对象初始化</span></span><br><span class="line"></span><br><span class="line">s1-&gt;~<span class="built_in">SeqList</span>(); <span class="comment">// 调用析构函数资源释放</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(s1)</span></span>; <span class="comment">// 释放动态内存分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、C-C-动态内存分配对比"><a href="#四、C-C-动态内存分配对比" class="headerlink" title="四、C&#x2F;C++ 动态内存分配对比"></a>四、C&#x2F;C++ 动态内存分配对比</h1><p>&emsp;C语言中使用<code>malloc/free</code>等函数进行动态内存分配，C++中使用<code>new/delete</code>运算符进行动态内存分配.</p><p>相同点：<br>● 都是从堆上分配空间，需要手动释放空间</p><p>不同点：<br>● malloc和free是函数，new和delete是运算符<br>● 对于自定义类型，malloc&#x2F;free不会调用构造函数&#x2F;析构函数，new会调用构造函数&#x2F;析构函数<br>● malloc申请空间时，需要手动计算空间大小，new只需给类型名<br>● malloc的返回值为void*, 在使用时必须强转，new返回的是类型指针<br>● malloc申请空间失败返回NULL，new申请抛出异常</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、new-delete&quot;&gt;&lt;a href=&quot;#一、new-delete&quot; class=&quot;headerlink&quot; title=&quot;一、new&amp;#x2F;delete&quot;&gt;&lt;/a&gt;一、new&amp;#x2F;delete&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么需要new-delete&quot;&gt;&lt;a href=&quot;#1-1-为什么需要new-delete&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么需要new&amp;#x2F;delete&quot;&gt;&lt;/a&gt;1.1 为什么需要new&amp;#x2F;delete&lt;/h2&gt;&lt;p&gt;&amp;emsp;C语言中通过&lt;code&gt;malloc/free&lt;/code&gt;等函数实现动态内存管理，为什么C++中还引入&lt;code&gt;new/delete&lt;/code&gt;对动态内存管理？原因在于：&lt;code&gt;malloc/free&lt;/code&gt;等函数不能满足对自定义类型的对象管理要求，对象在创建时要自动调用构造函数，对象在销毁前要自动调用析构函数，由于&lt;code&gt;malloc/free&lt;/code&gt;是库函数而不是运算符，编译器不能把调用构造函数和析构函数的任务强加给它们。因为C++需要一个能够完成动态内存分配和初始化工作的运算符&lt;code&gt;new&lt;/code&gt;，以及一个能够完成资源释放和释放内存工作的运算符&lt;code&gt;delete&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;code&gt;new/delete&lt;/code&gt;是运算符，而不是函数&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 类与对象（三）</title>
    <link href="https://blog.kjlcloud.com/2022/08/14/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://blog.kjlcloud.com/2022/08/14/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-08-14T03:50:56.000Z</published>
    <updated>2022-08-14T03:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、深度刨析构造函数"><a href="#一、深度刨析构造函数" class="headerlink" title="一、深度刨析构造函数"></a>一、深度刨析构造函数</h1><h2 id="1-1-编译器对构造函数的优化"><a href="#1-1-编译器对构造函数的优化" class="headerlink" title="1.1 编译器对构造函数的优化"></a>1.1 编译器对构造函数的优化</h2><p>&emsp;<strong>比较新的C++编译器在一行语句里面，若存在连续的构造函数（拷贝构造函数）调用，编译器对其优化为一次调用。注意：C++标准并没有规定必须要进行优化</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/ce31e632225d131eb3f89045ccee8df7.png#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><p>下面测试用例的编译器进行了优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">test</span><span class="params">(Person obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">Person p2 = <span class="built_in">test</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure><p>下面测试用例不是连续的构造函数（拷贝构造函数）调用，编译器不能优化<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ed6bd1c9d012659a732537254cb5d8bc.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">test</span><span class="params">(Person obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">p2 = <span class="built_in">test</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">赋值运算符重载</span><br></pre></td></tr></table></figure><h2 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h2><h3 id="1-2-1-什么是初始化列表"><a href="#1-2-1-什么是初始化列表" class="headerlink" title="1.2.1 什么是初始化列表"></a>1.2.1 什么是初始化列表</h3><p>&emsp;如果问大家类的对象是在什么时候定义初始化的，大家都能回答上来，是在调用构造函数（拷贝构造函数）时初始化的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p1; <span class="comment">// 调用默认构造函数对p1初始化</span></span><br><span class="line">Person p2 = p1; <span class="comment">// 调用拷贝构造函数对p2初始化   </span></span><br></pre></td></tr></table></figure><p>&emsp;那么对象的成员变量在什么时候定义初始化呢，我们一般习惯认为在构造函数（拷贝构造函数）体内初始化成员变量，然而这种想法是错误的，这只是对成员变量赋值而不是初始化。<strong>成员变量真正的初始化是在初始化列表进行的。初始化列表位于形参列表之后，函数体{ }之前，这也说明初始化列表进行的工作发生在函数体内任何代码执行之前</strong>。</p><h3 id="1-2-2-初始化列表定义"><a href="#1-2-2-初始化列表定义" class="headerlink" title="1.2.2 初始化列表定义"></a>1.2.2 初始化列表定义</h3><p>初始化列表定义语法：<strong>以冒号开始，每个成员变量初始化由变量名+括号，括号内是初始值，成员变量间用逗号隔开</strong></p><p>● 没有显式定义在初始化列表中成员变量，编译器对内置类型初始化为随机值，自定义类型调用其默认构造函数<br>● 每个成员变量在初始化列表中只能出现一次（初始化只能一次）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">: _year(year)</span><br><span class="line">, _month(month)</span><br><span class="line">, _day(day)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; obj)</span><br><span class="line">: _year(obj._year)</span><br><span class="line">, _month(obj._month)</span><br><span class="line">, _day(obj._day)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-必须使用初始化列表场景"><a href="#1-2-3-必须使用初始化列表场景" class="headerlink" title="1.2.3 必须使用初始化列表场景"></a>1.2.3 必须使用初始化列表场景</h3><p><strong>成员变量为以下情况，成员变量必须放在初始化列表中进行初始化：</strong><br>● 成员变量为引用（引用必须在定义时初始化）<br>● 成员变量为const(C++中const变量必须在定义时初始化)<br>● 成员变量为自定义类型且没有默认构造函数（不显式在初始化列表中定义，编译器会自动调用其默认构造函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">_x = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>&amp; _a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> _b;</span><br><span class="line">A _c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span>&amp; a, <span class="type">int</span> b, <span class="type">int</span> c)</span><br><span class="line">:_a(a)</span><br><span class="line">,_b(b)</span><br><span class="line">,_c(c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-推荐使用初始化列表场景"><a href="#1-2-4-推荐使用初始化列表场景" class="headerlink" title="1.2.4 推荐使用初始化列表场景"></a>1.2.4 推荐使用初始化列表场景</h3><p>&emsp;<strong>成员变量类型为自定义类型推荐使用初始化列表</strong>，<strong>如果不使用初始化列表</strong>：编译器调用成员变量的默认构造函数，并在函数体内调用赋值运算符重载进行赋值，<strong>开销2次</strong>。<strong>使用初始化列表</strong>：在初始化列表中调用成员变量的构造函数，函数体内不需要赋值，<strong>开销1次</strong></p><p><strong>测试：不使用初始化列表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_x = obj._x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_x = obj._x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">A _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day,<span class="type">const</span> A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">_a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2020</span>, <span class="number">01</span>, <span class="number">02</span>, a)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用类A构造函数</span><br><span class="line">调用类A构造函数</span><br><span class="line">调用类A赋值运算符重载</span><br></pre></td></tr></table></figure><p><strong>测试：使用初始化列表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_x = x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_x = obj._x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_x = obj._x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用类A赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">A _a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day,<span class="type">const</span> A&amp; a)</span><br><span class="line">: _a(a)</span><br><span class="line">&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2020</span>, <span class="number">01</span>, <span class="number">02</span>, a)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用类A构造函数</span><br><span class="line">调用类A拷贝构造函数</span><br></pre></td></tr></table></figure><h3 id="1-2-5-成员变量的初始化顺序"><a href="#1-2-5-成员变量的初始化顺序" class="headerlink" title="1.2.5 成员变量的初始化顺序"></a>1.2.5 成员变量的初始化顺序</h3><p>&emsp;<strong>成员变量的初始化顺序由类中成员变量声明次序决定，与其在初始化列表中的先后次序无关。所以推荐初始化列表中成员变量次序与类中声明次序一致</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> val)</span><br><span class="line">: _y(val)</span><br><span class="line">, _x(_y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; _y = &quot;</span> &lt;&lt; _y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_x = <span class="number">-858993460</span> _y = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>&emsp;在初始化列表中_y的次序在_x前，如果成员变量初始化次序由初始化列表中次序决定，先将形参val值初始化给_y,然后将_y值初始化给_x，所以_x&#x3D;_y&#x3D;val。但观察输出结果发现_x为随机值，_y&#x3D;val,因为类中_x声明次序在_y前面，所以先将_y的值初始化给_x,此时_y为随机值,所以_x也为随机值,然后将val值初始化给_y</p><h1 id="二、static"><a href="#二、static" class="headerlink" title="二、static"></a>二、static</h1><p>&emsp;<strong>类中用static修饰的成员变量称为静态成员变量，用static修饰的成员函数称为静态成员函数</strong></p><h2 id="2-1-静态成员变量"><a href="#2-1-静态成员变量" class="headerlink" title="2.1 静态成员变量"></a>2.1 静态成员变量</h2><p>● 静态成员变量为类中所有对象共享，对象中不存储静态成员变量<br>● 静态成员变量必须在类外定义并初始化且不需要加static关键字<br>● 静态成员变量可用对象或类名访问,前提是静态成员变量控制权限为public</p><p>下面程序为统计创建出多少个类对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _sCount; <span class="comment">// 静态成员变量的声明，为了测试对象或类访问变量，控制权限给的public，一般不建议给public</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">++_sCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">++_sCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; A::_sCount &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过类名访问</span></span><br><span class="line">A a1;</span><br><span class="line">A a2;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; a<span class="number">3.</span>_sCount &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过对象访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已创建：<span class="number">0</span>个对象</span><br><span class="line">已创建：<span class="number">3</span>个对象</span><br></pre></td></tr></table></figure><h2 id="2-2-静态成员函数"><a href="#2-2-静态成员函数" class="headerlink" title="2.2 静态成员函数"></a>2.2 静态成员函数</h2><p>● 静态成员函数没有隐藏的this形参，不能访问任何非静态成员变量<br>● 静态成员函数和类的普通成员函数一样，也有public、protected、private3种访问级别，也可以具有返回值<br>● 静态成员函数可用对象或类名访问,前提是静态成员函数控制权限为public<br>●  静态成员函数内不能调用非静态成员函数(静态成员函数没有隐藏this形参)<br>● 非静态成员函数内可以调用静态成员函数（非静态成员函数有隐藏this形参）</p><p>上面统计创建出多少个类对象的程序，_sCount给的public控制权限封装性不好，程序修改为_sCount控制权限为private,通过静态成员函数去访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _sCount; <span class="comment">// 静态成员变量的声明，为了测试对象或类访问变量，控制权限给的public，一般不建议给public</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">++_sCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">++_sCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetACount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> _sCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; A::<span class="built_in">GetACount</span>() &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过类名访问</span></span><br><span class="line">A a1;</span><br><span class="line">A a2;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;已创建：&quot;</span> &lt;&lt; a<span class="number">3.</span><span class="built_in">GetACount</span>() &lt;&lt; <span class="string">&quot;个对象&quot;</span> &lt;&lt; endl; <span class="comment">// 通过对象访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已创建：<span class="number">0</span>个对象</span><br><span class="line">已创建：<span class="number">3</span>个对象</span><br></pre></td></tr></table></figure><h1 id="三、C-11-成员变量初始化新玩法"><a href="#三、C-11-成员变量初始化新玩法" class="headerlink" title="三、C++11 成员变量初始化新玩法"></a>三、C++11 成员变量初始化新玩法</h1><p>&emsp;<strong>C++11 之前令人诟病的是编译器生成的默认构造函数对于类型为内置类型成员变量不进行初始化处理</strong>，若需对内置类型成员变量初始化需要手动定义构造函数，在构造函数的初始化列表对成员变量初始化(构造函数体内对成员变量赋值)。<strong>C++11 引入非静态成员变量在类中声明时给缺省值的玩法，当在构造函数中没有显式对成员变量初始化（赋值）则用缺省值初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _sCount; </span><br><span class="line"><span class="type">int</span> _x = <span class="number">1</span>; <span class="comment">// 在声明时给缺省值</span></span><br><span class="line"><span class="type">int</span> _y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_sCout = &quot;</span> &lt;&lt; _sCount &lt;&lt; <span class="string">&quot; _x = &quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot; _y = &quot;</span> &lt;&lt; _y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_sCount = <span class="number">0</span>; <span class="comment">// 静态成员变量必须在类外定义并初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">Print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_sCout = <span class="number">0</span> _x = <span class="number">1</span> _y = <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="四、友元"><a href="#四、友元" class="headerlink" title="四、友元"></a>四、友元</h1><p>&emsp;<strong>友元可以让函数突破类的封装性，能访问任何控制权限（public、protected、private）的成员，在某些场景下提供了便利，但破坏了封装性，一般不推荐使用</strong></p><h2 id="4-1-友元函数"><a href="#4-1-友元函数" class="headerlink" title="4.1 友元函数"></a>4.1 友元函数</h2><p>&emsp;我们可以用<code>&lt;&lt;</code>运算符配合<code>cout</code>打印内置类型变量，但如果要打印自定义类型，需要对<code>&lt;&lt;</code>进行运算符重载。当重载为成员函数时会带来问题，因为非静态成员函数默认第一个形参为隐藏this指针，调用时编译器会将左操作数地址传给隐藏的形参this指针，this指针类型为 <code>类名* const</code> ,而左操作数<code>cout</code>对象类型为<code>ostream</code>，类型不匹配，只能通过函数名，或交换左右操作数位置方式调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">_x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; _x &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; a &lt;&lt; endl; 错误，左操作数地址类型为ostream* ， 隐藏形参this类型为 A*</span></span><br><span class="line">a.<span class="keyword">operator</span>&lt;&lt;(cout); <span class="comment">// 正确</span></span><br><span class="line">a &lt;&lt; cout; <span class="comment">// 正确，调用时将左操作数地址传给隐藏形参this,右操作数传给形参out</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;由于运算符重载为非静态成员函数都有隐藏this形参，而<code>&lt;&lt;</code>运算符左操作数为<code>cout</code>。类型不匹配，只能将运算符重载为全局函数，但由于成员变量访问权限为<code>非public</code>，类外不能访问成员变量。这种场景可以使用友元函数，<strong>友元函数：能访问任何控制权限（public、protected、private）的成员，它是定义在类外部的普通函数，不属于任何类，但需要在对应类里面进行函数声明，声明时需要加friend关键字</strong></p><p>● 友元函数可以在类里面任何地方声明，不受类访问限定符限制<br>● 一个函数可以是多个类的友元函数<br>● 友元函数不能用const修饰，因为没有this指针</p><p><code>友元函数写法一：在类中声明友元函数，类外定义友元函数</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, A&amp; obj); <span class="comment">// 在类中声明友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">_x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,A&amp; obj) <span class="comment">// 友元函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; obj._x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_x = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>友元函数写法二：在类中声明并定义友元函数</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,A&amp; obj) <span class="comment">// 友元函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;_x = &quot;</span> &lt;&lt; obj._x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">_x = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2-友元类"><a href="#4-2-友元类" class="headerlink" title="4.2 友元类"></a>4.2 友元类</h2><p>&emsp; 类A是类B的友元，则称类A为类B的友元类。友元类所有成员函数可以访问另一个类的任何控制权限（public、protected、private）的成员</p><p>● 友元关系是单向的(A是B的友元类，A可以访问B，但B不能访问A的非public的成员)<br>● 友元关系不能传递(A是B的友元，B是C的友元，不能说明A是C的友元)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>; <span class="comment">// 声明类A是类B的友元类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_b = &quot;</span> &lt;&lt; b._b &lt;&lt; endl; <span class="comment">// 可以访问类B的任何权限的成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五、内部类"><a href="#五、内部类" class="headerlink" title="五、内部类"></a>五、内部类</h1><p>&emsp;<strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。内部类只是定义在外部类里面，它不属于外部类，不能通过外部类的对象去访问内部类。</strong></p><p>● 内部类就是外部类的友元类,外部类不是内部类的友元类<br>● 外部类可以使用访问限定符public、protected、private限定内部类<br>● 内部类可以直接访问外部类的静态成员，不需要用外部类的对象&#x2F;类名<br>● 内部类只是定义在外部类里面而已，并不占用外部类的空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _sCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(A&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _sCount &lt;&lt; endl; <span class="comment">// 直接访问外部类静态成员变量</span></span><br><span class="line">cout &lt;&lt; obj._a &lt;&lt; endl; <span class="comment">// 通过对象访问成员变量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::B b; <span class="comment">// 正确，类B访问权限为public，通过作用域限定符::访问类A中的类B并初始化对象b</span></span><br><span class="line"><span class="comment">// A::C c 错误，类C访问权限为private </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、深度刨析构造函数&quot;&gt;&lt;a href=&quot;#一、深度刨析构造函数&quot; class=&quot;headerlink&quot; title=&quot;一、深度刨析构造函数&quot;&gt;&lt;/a&gt;一、深度刨析构造函数&lt;/h1&gt;&lt;h2 id=&quot;1-1-编译器对构造函数的优化&quot;&gt;&lt;a href=&quot;#1-1-编译器对构造函数的优化&quot; class=&quot;headerlink&quot; title=&quot;1.1 编译器对构造函数的优化&quot;&gt;&lt;/a&gt;1.1 编译器对构造函数的优化&lt;/h2&gt;&lt;p&gt;&amp;emsp;&lt;strong&gt;比较新的C++编译器在一行语句里面，若存在连续的构造函数（拷贝构造函数）调用，编译器对其优化为一次调用。注意：C++标准并没有规定必须要进行优化&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://i-blog.csdnimg.cn/blog_migrate/ce31e632225d131eb3f89045ccee8df7.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 类与对象（二）</title>
    <link href="https://blog.kjlcloud.com/2022/08/11/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.kjlcloud.com/2022/08/11/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-08-11T15:45:31.000Z</published>
    <updated>2022-08-11T15:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>前言：C++编译器默认在类中生成六个特殊的成员函数，如果在类中显式定义相对应的成员函数，编译器则不会生成对应成员函数</strong></p><h1 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h1><h2 id="1-1-什么是构造函数"><a href="#1-1-什么是构造函数" class="headerlink" title="1.1 什么是构造函数"></a>1.1 什么是构造函数</h2><p>&emsp;根据经验，不少难以察觉的程序错误都是由于变量没有正确初始化导致的，而初始化工作很容易被人遗忘。<strong>C++中引入构造函数的概念，构造函数是一个特殊的成员函数，函数名与类名相同,实例化对象时由编译器自动调用构造函数，保证对象中的成员变量都被正确初始化。构造函数在对象的生命周期内只调用一次。注意：构造函数的作用是初始化对象，而不是为对象分配内存空间。</strong></p><p>&emsp;构造函数不显式定义时由编译器自动生成，当显式定义构造函数时，编译器不会自动生成。构造函数的<strong>函数名必要与类名一致</strong>，并且<strong>没有返回值</strong>（void也不行)。</p><span id="more"></span><h2 id="1-2-构造函数特性"><a href="#1-2-构造函数特性" class="headerlink" title="1.2 构造函数特性"></a>1.2 构造函数特性</h2><h3 id="1-2-1-构造函数支持函数重载"><a href="#1-2-1-构造函数支持函数重载" class="headerlink" title="1.2.1 构造函数支持函数重载"></a>1.2.1 构造函数支持函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age) <span class="comment">// 带参数的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name,name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-实例化对象时编译器自动调用对应的构造函数"><a href="#1-2-2-实例化对象时编译器自动调用对应的构造函数" class="headerlink" title="1.2.2 实例化对象时编译器自动调用对应的构造函数"></a>1.2.2 实例化对象时编译器自动调用对应的构造函数</h3><p><strong>对象生命周期内只会调用一次构造函数，编译器在实例化对象时根据传入参数个数选择匹配的构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age) <span class="comment">// 带参数的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name,name);</span><br><span class="line">_age = age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用带参数的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1; <span class="comment">// 调用无参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用无参构造函数</span><br><span class="line">调用带参数的构造函数</span><br></pre></td></tr></table></figure><p>说明：实例化对象调用无参构造函数不能这种方式写<code>Person p1();</code>因为编译器会认为这个是函数声明，Person是函数返回类型，p1为函数名。只能这样方式写<code>Person p1;</code>才调用无参构造函数，虽然看起来语法有些奇怪</p><h3 id="1-2-3-默认构造函数"><a href="#1-2-3-默认构造函数" class="headerlink" title="1.2.3 默认构造函数"></a>1.2.3 默认构造函数</h3><p><strong>构造函数的形参列表为空称为默认构造函数，默认构造函数有3种，一个类中默认构造函数只能有一个，推荐使用全缺省的默认构造函数</strong></p><p>1.类中没有显式定义构造函数，则C++编译器会自动生成一个无参的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1; <span class="comment">// 调用编译器生成的默认构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在类中显式定义一个无参构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() <span class="comment">// 无参的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1; <span class="comment">// 调用显式定义的默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在类中定义一个全缺省的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1; <span class="comment">// 调用显式全缺省的默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-编译器生成的默认构造函数的功能"><a href="#1-3-编译器生成的默认构造函数的功能" class="headerlink" title="1.3 编译器生成的默认构造函数的功能"></a>1.3 编译器生成的默认构造函数的功能</h2><p>&emsp;在类中不显式定义构造函数，编译器生成默认构造函数。<strong>这个构造函数对于对象中内置类型成员变量不做任何初始化，如果成员变量为自定义类型则调用它的默认构造函数</strong></p><p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是类A的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">A ob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是类A的构造函数</span><br><span class="line">年龄：<span class="number">-858993460</span></span><br></pre></td></tr></table></figure><p>编译器生成Person类的默认构造函数对于内置类型成员变量没有任何处理，所以_age打印出来是随机值，ob为自定义类型，所以调用了ob对应的默认构造函数</p><h2 id="1-4-explicit关键字"><a href="#1-4-explicit关键字" class="headerlink" title="1.4 explicit关键字"></a>1.4 explicit关键字</h2><p>&emsp;<strong>使用<code>explicit</code>关键字修饰的构造函数将禁止隐式类型转换，只能以显式的方式进行类型转换</strong>。<code>explicit</code>只能在类内部使用，即构造函数的声明与定义分离，只能在声明前面加<code>explicit</code>修饰。</p><h3 id="1-4-1-隐式类型转换"><a href="#1-4-1-隐式类型转换" class="headerlink" title="1.4.1 隐式类型转换"></a>1.4.1 隐式类型转换</h3><p>c++支持隐式类型转换，即根据类型A变量的值创建一个类型B的临时变量，并将该临时变量赋值给某个类型B变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _a = a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = &#123;<span class="number">3</span>&#125;; <span class="comment">// 隐式类型转换</span></span><br><span class="line">    A b = <span class="number">4</span>;   <span class="comment">// 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5c762a283064d976d49c02a2baccae0.png" alt="在这里插入图片描述"></p><h3 id="1-4-2-禁止构造函数隐式类型转换"><a href="#1-4-2-禁止构造函数隐式类型转换" class="headerlink" title="1.4.2 禁止构造函数隐式类型转换"></a>1.4.2 禁止构造函数隐式类型转换</h3><p>例1： 构造函数只有单个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _a = a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; obj) </span><br><span class="line">        &#123;</span><br><span class="line">            _a = obj._a;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = &#123;<span class="number">3</span>&#125;; <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A b = <span class="number">4</span>;   <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A c = (A)<span class="number">3</span>; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line">    A D = (A)&#123;<span class="number">4</span>&#125;; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例2： 构造函数有多个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> : _a(a), _b(b) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 错误，不能隐式类型转换</span></span><br><span class="line">    A b = (A)&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 正确，强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、析构函数"><a href="#二、析构函数" class="headerlink" title="二、析构函数"></a>二、析构函数</h1><p>&emsp;根据经验，动态申请的内存空间在使用结束后往往忘记释放，造成内存泄漏的问题。<strong>C++中引入析构函数的概念，析构函数是一个特殊的成员函数，函数名在类名基础上加前缀<code>~</code>。对象生命周期结束时，C++编译器自动调用析构函数。注意：对象销毁工作是由编译器完成的，析构函数作用是在对象销毁前完成某些资源清理</strong></p><p>&emsp;析构函数不显式定义时由编译器自动生成，当显式定义构造函数时，编译器不会自动生成。析构函数的<strong>函数名在类名前加上字符 ~</strong>，并且<strong>没有返回值</strong>（void也不行)，<strong>没有形参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="type">int</span> ElemType; <span class="comment">//元素类型重定义，以后元素类型发生改变只用改这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initSize 10  <span class="comment">// 顺序表初始化大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ElemType* _data; <span class="comment">//动态内存分配存放元素的数组</span></span><br><span class="line"><span class="type">size_t</span> _size; <span class="comment">//已存放元素个数</span></span><br><span class="line"><span class="type">size_t</span> _capacity; <span class="comment">//数组容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">_data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * initSize);</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">_capacity = initSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SeqList</span>() <span class="comment">// 析构函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(_data); <span class="comment">// 释放动态内存分配的空间</span></span><br><span class="line">_data = <span class="literal">nullptr</span>;</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1-编译器生成的析构函数的功能"><a href="#2-1-编译器生成的析构函数的功能" class="headerlink" title="2.1 编译器生成的析构函数的功能"></a>2.1 编译器生成的析构函数的功能</h2><p>&emsp;<strong>在类中不显式定义析构函数，编译器自动生成析构函数。这个构造函数对于对象中内置类型成员变量不做处理，如果成员变量为自定义类型则调用它的析构函数</strong></p><p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是类A的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">A ob;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是类A的析构函数</span><br></pre></td></tr></table></figure><h1 id="三、拷贝构造函数"><a href="#三、拷贝构造函数" class="headerlink" title="三、拷贝构造函数"></a>三、拷贝构造函数</h1><p>&emsp;在生活中我们有时候会想，如果能够复制一个一模一样的自己那该多好。可以替我学习、替我工作。当然这只是人的幻想罢了，但在C++中可以梦想成真。<strong>C++中引入了拷贝构造函数的概念，用一个已存在的对象创建新对象时，由编译器自动调用拷贝构造函数，创建的新对象与已存在对象一模一样</strong></p><p>&emsp;<strong>拷贝构造函数不显式定义时由编译器自动生成，当显式定义拷贝构造函数时，编译器不会自动生成。 拷贝构造函数是构造函数的重载，它与构造函数外表唯一区别是拷贝构造函数只有一个形参，形参必须为引用，并推荐用const修饰</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用拷贝构造函数，推荐写法</span></span><br><span class="line">Person p3 = p1; <span class="comment">// 调用拷贝构造函数，不推荐写法</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">3.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="3-1-拷贝构造函数特性"><a href="#3-1-拷贝构造函数特性" class="headerlink" title="3.1 拷贝构造函数特性"></a>3.1 拷贝构造函数特性</h2><h3 id="3-1-1-显式定义拷贝构造函数时必须显式定义默认构造函数"><a href="#3-1-1-显式定义拷贝构造函数时必须显式定义默认构造函数" class="headerlink" title="3.1.1 显式定义拷贝构造函数时必须显式定义默认构造函数"></a>3.1.1 显式定义拷贝构造函数时必须显式定义默认构造函数</h3><p>&emsp;<strong>拷贝构造函数是构造函数的重载，当显式定义拷贝构造函数时，编译器不会生成默认构造函数，此时需要显式定义默认构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1; <span class="comment">// 错误，没有默认构造函数可以调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-2-拷贝构造函数形参必须为引用原因"><a href="#3-1-2-拷贝构造函数形参必须为引用原因" class="headerlink" title="3.1.2 拷贝构造函数形参必须为引用原因"></a>3.1.2 拷贝构造函数形参必须为引用原因</h2><p><strong>下面这段代码拷贝构造函数的形参不是引用，会出现死循环递归调用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span>  Person obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj._name);</span><br><span class="line">_age = obj._age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 错误，变成死循环</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2f6544bdd817c85f8cae9be41dad0afa.png#pic_center" alt="在这里插入图片描述"><br><strong>还有一种不推荐的写法，因为引用的本质是指针，所以拷贝构造函数形参可以是指针类型，只是这种写法可读性、清晰性不高，并且调用时需要传对象地址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>) <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person* obj) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, obj-&gt;_name);</span><br><span class="line">_age = obj-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(&amp;p1)</span></span>; <span class="comment">// 使用指针方法调用拷贝构造函数</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="3-2-编译器生成的拷贝构造函数的功能"><a href="#3-2-编译器生成的拷贝构造函数的功能" class="headerlink" title="3.2 编译器生成的拷贝构造函数的功能"></a>3.2 编译器生成的拷贝构造函数的功能</h2><p><strong>&emsp;在类中不显式定义拷贝构造函数，编译器自动生成拷贝构造函数。这个拷贝构造函数对于对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的拷贝构造函数</strong></p><p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是类A的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是类A的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">A ob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;王某某&quot;</span>, <span class="type">int</span> age = <span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是类A的构造函数</span><br><span class="line">这是类A的拷贝构造函数</span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure><h1 id="四、运算符重载"><a href="#四、运算符重载" class="headerlink" title="四、运算符重载"></a>四、运算符重载</h1><p>&emsp;C++为了增强代码的可读性引入了运算符重载概念，<strong>运算符重载是一个特殊的函数</strong>。通过关键字<code>operator</code>加上运算符来表示函数名，函数的返回值类型及参数列表与普通函数类似。<strong>重载的运算符并不会改变它们做为内置运算符的使用方法。</strong></p><p>● 不能重载C++语言不支持的运算符，比如 @<br>● 不要试图改变重载运算符的语义，要与内置语义保存一致。例如将++运算符重载后执行递减操作，损害代码的可读性、正确性</p><h2 id="4-1-运算符重载的两种形式"><a href="#4-1-运算符重载的两种形式" class="headerlink" title="4.1 运算符重载的两种形式"></a>4.1 运算符重载的两种形式</h2><p>&emsp;<strong>运算符重载有两种形式，一种运算符被重载为类的成员函数，另一种重载为全局函数。推荐被重载为类的成员函数。运算符重载为成员函数比重载为全局函数而言函数的形参看起来少一个参数，对于成员函数编译器会将左操作数的地址隐式传给形参this指针</strong></p><h3 id="4-1-1-重载为类的成员函数"><a href="#4-1-1-重载为类的成员函数" class="headerlink" title="4.1.1 重载为类的成员函数"></a>4.1.1 重载为类的成员函数</h3><p>&emsp;<strong>运算符的左操作数为类的对象时，建议运算符重载为类的成员函数，因为C++编译器给每个“非静态的成员函数“增加了一个隐藏的this指针形参，并会将左操作数（即类对象）的地址做为实参传给形参this指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&lt;(Date&amp; obj) <span class="comment">// 重载&lt; 运算符，用来比较两个日期类型对象的大小</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &lt; obj._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_year == obj._year &amp;&amp; _month &lt; obj._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == obj._year &amp;&amp; _month == obj._month &amp;&amp; _day &lt; obj._day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-重载为全局函数"><a href="#4-1-2-重载为全局函数" class="headerlink" title="4.1.2 重载为全局函数"></a>4.1.2 重载为全局函数</h3><p>&emsp;<strong>运算符的左操作数不是类的对象时，运算符重载为全局函数。假设重载为成员函数，编译器会将左操作数地址传给隐藏的形参this指针，this指针类型为 <code>类名* </code> ,与<code>&amp;左操作数</code>类型不匹配</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; obj._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-运算符重载调用"><a href="#4-2-运算符重载调用" class="headerlink" title="4.2 运算符重载调用"></a>4.2 运算符重载调用</h2><p>&emsp;<strong>运算符重载是一种特殊的函数，在与普通函数相比，函数调用有些不同。不仅支持正常的函数名+()方式调用，又支持通过运算符方式调用。推荐使用运算符方式调用，提高代码可读性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; obj._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; obj._day &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">cout &lt;&lt; d1; <span class="comment">// 运算符方式调用， &lt;&lt; 为运算符  cout为左操作数  d1为右操作数</span></span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout,d1); <span class="comment">// 通过函数名方式调用，operator&lt;&lt; 为函数名， cout、d1为形参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-不能重载的运算符"><a href="#4-3-不能重载的运算符" class="headerlink" title="4.3 不能重载的运算符"></a>4.3 不能重载的运算符</h2><p>&emsp;C++运算符集合中，5种运算符不运行重载，为：<code>.* 、:: 、?: 、sizeof 、.</code></p><h2 id="4-4-重载-和"><a href="#4-4-重载-和" class="headerlink" title="4.4 重载++和- -"></a>4.4 重载++和- -</h2><p>&emsp;两个运算符分为前置版本与后置版本，运算符重载是一种特殊的函数，函数名由关键字<code>operator</code>+运算符组成，那问题来了，<code>operator++</code>是重载的前置++还是后置++，<code>operator--</code>是重载的前置- -还是后置- -。<strong>为了解决这个问题，C++标准规定：当重载前置版本的++或- -时，函数形参为空，当重载后置版本的++或- -时，函数需要定义一个int类型的形参作为标志进行区分</strong></p><p><font color=#0000FF >说明：对于自定义类型，尤其是对象所占内存空间比较大时，前置版本比后置版本效率高很多</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>+=(<span class="type">int</span> day); <span class="comment">// 日期+=天数</span></span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>++(); <span class="comment">// ++日期</span></span><br><span class="line"></span><br><span class="line">Date <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// 日期++ ,后置++为了跟前置++区分，增加一下int类型参数占位，构成函数重载</span></span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>-=(<span class="type">int</span> day); <span class="comment">// 日期-=天数</span></span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>--(); <span class="comment">// --日期</span></span><br><span class="line"></span><br><span class="line">Date <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">// 日期-- ,后置--为了跟前置--区分，增加一下int类型参数占位，构成函数重载</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> -= -day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_day += day;</span><br><span class="line"><span class="keyword">while</span> (_day &gt; <span class="built_in">GetMonthDay</span>(_year, _month)) <span class="comment">// 当day大于该月天数时</span></span><br><span class="line">&#123;</span><br><span class="line">_day -= <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">_month++;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">_year++;</span><br><span class="line">_month = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>-=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> += -day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_day -= day;</span><br><span class="line"><span class="keyword">while</span> (_day &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_month--;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_year--;</span><br><span class="line">_month = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line">_day += <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">++d1; <span class="comment">// 前置++</span></span><br><span class="line">d1++; <span class="comment">// 后置++</span></span><br><span class="line">d<span class="number">1.</span><span class="keyword">operator</span>++(); <span class="comment">// 通过函数名方式调用，没有传入实参，调用前置++</span></span><br><span class="line">d<span class="number">1.</span><span class="keyword">operator</span>++(<span class="number">1</span>); <span class="comment">// 通过函数名方式调用，传入int类型实参，调用后置++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-赋值运算符重载"><a href="#4-5-赋值运算符重载" class="headerlink" title="4.5 赋值运算符重载"></a>4.5 赋值运算符重载</h2><p>&emsp;<strong>对已存在的类对象进行赋值拷贝时，会调用赋值运算符重载。赋值运算符重载不显式定义时由编译器自动生成，当显式定义赋值运算符重载，编译器不生成。</strong></p><p><strong>注意：赋值运算符只能重载为类的成员函数，而不能将其重载为类的非成员函数。因为当重载为类的非成员函数时并不属于该类，编译器一看，类内并没有一个以本类或本类的引用为参数的赋值运算符重载函数，所以会自动提供一个。为了避免这样的二义性，C++强制规定，赋值运算符重载函数只能定义为类的成员函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; obj);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date Date::<span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_year = obj._year;</span><br><span class="line">_month = obj._month;</span><br><span class="line">_day = obj._day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">Date d2;</span><br><span class="line">d2 = d1; <span class="comment">// d2对象已经存在，调用赋值运算符重载将d1的值拷贝给d2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-1-编译器生成的赋值运算符重载功能"><a href="#4-5-1-编译器生成的赋值运算符重载功能" class="headerlink" title="4.5.1 编译器生成的赋值运算符重载功能"></a>4.5.1 编译器生成的赋值运算符重载功能</h3><p><strong>&emsp;在类中不显式定义赋值运算符重载，编译器自动生成赋值运算符重载。编译器生成的赋值运算符重载对于对象中内置类型成员变量按字节拷贝（浅拷贝），如果成员变量为自定义类型则调用它的赋值运算符重载</strong></p><p><strong>内置类型：C++语法已经定义好的类型，例如 int、char、double等<br>自定义类型：用class、struct、union关键字自己定义的类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B <span class="keyword">operator</span>=(B&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">_x = obj._x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类B的赋值运算符重载&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> y = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">_y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A b;</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类B的赋值运算符重载</span><br></pre></td></tr></table></figure><h2 id="4-6-取地址运算符重载与const-取地址运算符重载"><a href="#4-6-取地址运算符重载与const-取地址运算符重载" class="headerlink" title="4.6 取地址运算符重载与const 取地址运算符重载"></a>4.6 取地址运算符重载与const 取地址运算符重载</h2><p>&emsp;<strong>取地址运算符重载与const 取地址运算符重载不显式定义时由编译器自动生成，当显式定义时，编译器不会自动生成。只有需要对取地址做特殊处理时才显式定义，一般用编译器自动生成的即可</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Date* <span class="keyword">operator</span>&amp;();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Date* <span class="keyword">operator</span>&amp;()<span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> Date* Date::<span class="keyword">operator</span>&amp;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">const</span> Date* Date::<span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;strong&gt;前言：C++编译器默认在类中生成六个特殊的成员函数，如果在类中显式定义相对应的成员函数，编译器则不会生成对应成员函数&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、构造函数&quot;&gt;&lt;a href=&quot;#一、构造函数&quot; class=&quot;headerlink&quot; title=&quot;一、构造函数&quot;&gt;&lt;/a&gt;一、构造函数&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是构造函数&quot;&gt;&lt;a href=&quot;#1-1-什么是构造函数&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是构造函数&quot;&gt;&lt;/a&gt;1.1 什么是构造函数&lt;/h2&gt;&lt;p&gt;&amp;emsp;根据经验，不少难以察觉的程序错误都是由于变量没有正确初始化导致的，而初始化工作很容易被人遗忘。&lt;strong&gt;C++中引入构造函数的概念，构造函数是一个特殊的成员函数，函数名与类名相同,实例化对象时由编译器自动调用构造函数，保证对象中的成员变量都被正确初始化。构造函数在对象的生命周期内只调用一次。注意：构造函数的作用是初始化对象，而不是为对象分配内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;构造函数不显式定义时由编译器自动生成，当显式定义构造函数时，编译器不会自动生成。构造函数的&lt;strong&gt;函数名必要与类名一致&lt;/strong&gt;，并且&lt;strong&gt;没有返回值&lt;/strong&gt;（void也不行)。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 类与对象（一）</title>
    <link href="https://blog.kjlcloud.com/2022/08/11/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.kjlcloud.com/2022/08/11/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-08-11T02:01:06.000Z</published>
    <updated>2022-08-11T02:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、面向过程与面向对象编程"><a href="#一、面向过程与面向对象编程" class="headerlink" title="一、面向过程与面向对象编程"></a>一、面向过程与面向对象编程</h1><p>&emsp;我们经常听别人谈起C语言是面向过程的编程语言，而C++是面向对象的编程语言。但是你让他具体说下什么是面向过程、什么是面向对象可能他很难说清楚。今天鄙人拙见谈谈什么是面向过程、什么是面向对象的看法。不管是面向什么都要把程序写出来，那程序是什么？计算机编程领域的祖师爷尼古拉斯•威茨曾经说过<code>程序=数据结构+算法</code>， <strong>所以程序的本质：为了解决某个问题，选择合适的数据结构和算法进行若干步骤的求解</strong>。对于一个问题求解的思路有很多种，<strong>我认为面向过程与面向对象编程的区别就是对问题分析求解的思想不同</strong>。</p><span id="more"></span><p>&emsp;<strong>面向过程编程：将一个大问题分而治之划分成若干个小问题</strong>。每个小问题需要做某些操作并对数据进行某些处理，所以我们定义函数来解决这些小问题，并在函数里面对数据进行处理。<strong>我们会发现在面向过程的思想一直围绕解决若干个小问题，每个小问题对数据操作处理不一样。所以数据与函数是分开定义的，不能很好的结合在一起</strong>。所以在C语言中数据定义在结构体中，在函数中操作数据。对每个小问题通过不同函数来解决，最终合并起来解决整个大问题，所以我们常常听说面向过程编程就是面向函数编程。</p><p>&emsp;<strong>面向对象编程</strong>：道教中有句名言：道生一，一生二，二生三，三生万物。说明万物相互之间是有联系的。面向对象思想采纳了道教的观点，认为不管是看待世界还是看待问题，都是由具有行为的各种对象组成的，<strong>不同类型对象之间互相有着联系</strong>。<strong>每个对象具有某种属性和行为</strong>。例如人是一个对象，那人的名字、年龄、身高、体重等都为人这个对象的属性。人可以做好事情，比如吃饭、喝水、学习、睡觉等都为人这个对象的行为。<strong>我们发现面向对象思想将属性和行为做为一个不可分割的整体，即数据和处理数据的函数不可分割看待。</strong> 人这个对象可以有很多个，例如：张三、李四、王五。<strong>每一个具体对象都有这些相同的属性和行为所以抽象出类这个概念。即类是描述对象属性和行为的，是一个抽象的概论，而对象是类的实例化，是有生命的。</strong></p><p>&emsp;上面是我认为的什么是面向过程，什么是面向对象，<strong>总结一句话就是看待问题、解决问题的思想不同。</strong> 我们不能说哪一种好哪一种不好，每个人可以根据自身对问题看法选择。<strong>本人不认同C语言就一定是面向过程的编程语言，C++就一定是面向对象的编程语言的说法。只能说C语言之父丹尼斯·里奇在语言设计时偏向于面向过程的思想。C++之父本贾尼在语言设计时偏向于面向对象的思想。导致语言层面对不同思想支持力度不同</strong>。如果有人问C语言一定不能面向对象编程或C++一定不能面向过程编程那一定是个刚入门的学习者。</p><p>&emsp;<strong>另外说明的是，C++的设计思想是面向对象的，但是C++是站在C语言的肩膀上的，对C语言进行了兼容，所以我认为C++是基于面向对象的，而不是像Java一样全面向对象的</strong>。</p><h1 id="二、C-对C语言struct的兼容"><a href="#二、C-对C语言struct的兼容" class="headerlink" title="二、C++对C语言struct的兼容"></a>二、C++对C语言struct的兼容</h1><p>上文中说过C++是站在C语言的肩膀上的，对C语言进行了兼容，所以用C语言写的结构体在C++中可以正常运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">struct</span> Person* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> p1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> p2;</span><br><span class="line"><span class="built_in">strcpy</span>(p<span class="number">2.</span>name, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">p<span class="number">2.</span>age = <span class="number">19</span>;</span><br><span class="line"><span class="built_in">Print</span>(&amp;p1);</span><br><span class="line"><span class="built_in">Print</span>(&amp;p2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">19</span></span><br></pre></td></tr></table></figure><p><strong>C++中<code>struct</code>的本质就是<code>class</code>,所以可以在<code>struct</code>中定义函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, _name, _age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> p1 = &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>&#125;;</span><br><span class="line">Person p2;</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>);</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">19</span></span><br></pre></td></tr></table></figure><p><strong>C++中<code>struct</code>与<code>class</code>的唯一区别在下文中有讲解</strong></p><h1 id="三、类的定义"><a href="#三、类的定义" class="headerlink" title="三、类的定义"></a>三、类的定义</h1><p>&emsp;C++面向对象的思想，认为对象由属性和行为组成，不能分割看待，并将属性和行为相同的对象抽象出类这个概念。属性和行为都在类里面。在类中定义的属性称为成员变量，类中定义的行为称为成员方法。</p><p>语法：<code>class</code>为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类型</span><br><span class="line">&#123;</span><br><span class="line">属性（成员变量）</span><br><span class="line">行为（成员方法）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>根据是否在类中定义成员方法将类的定义分为两种</strong></p><h2 id="3-1-成员方法的定义在类里面"><a href="#3-1-成员方法的定义在类里面" class="headerlink" title="3.1 成员方法的定义在类里面"></a>3.1 成员方法的定义在类里面</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-成员方法的定义不在类里面"><a href="#3-2-成员方法的定义不在类里面" class="headerlink" title="3.2 成员方法的定义不在类里面"></a>3.2 成员方法的定义不在类里面</h2><p><strong>在项目中推荐这种方式定义类，日常测试时则可以任选一种</strong><br><code>Person.h 头文件</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span>; <span class="comment">// 只在类中声明成员方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Person.cpp 源文件</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> <span class="comment">// 成员方法的定义 Person为类型 :: 为作用域限定符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在成员方法的定义时，需要用<code>类型+作用域限定符</code>指明是哪一个作用域里面函数，因为一个类相当于一个作用域</strong></p><h1 id="四、类的封装性"><a href="#四、类的封装性" class="headerlink" title="四、类的封装性"></a>四、类的封装性</h1><p>&emsp;面向对象思想中，对象由属性和行为构成。并且不同类型对象之间相关联系。对象之间相互联系并不代表说我一定要把我这个对象的所有细节对你展开。例如：我这个对象实现了吃饭这个行为，另外一个对象实现了开车这个行为。假设存在开车需要先吃饭的联系，你只要开车之前先吃饭就行，不用管这个对象到底如何吃饭的、吃了什么。<strong>在面向对象思想中引入封装性这个概念，即隐藏对象实现的具体细节，只对外提供调用接口</strong>。封装是通过<code>访问限定符</code>实现的</p><h2 id="4-1-访问限定符"><a href="#4-1-访问限定符" class="headerlink" title="4.1 访问限定符"></a>4.1 访问限定符</h2><p><strong>访问限定符有三种：public、protected、private 三种类型</strong></p><ol><li>public修饰的成员在类外可以直接被访问</li><li>protected和private修饰的成员在类外不能直接被访问(protected与private的区别在于继承时有所不同)</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li>访问限定符是基于类而不是基于对象的，同一个类的所有对象可以互相访问</li><li><strong>class的默认访问权限为private，struct为public(因为struct要兼容C)</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> <span class="comment">// 同一个类的所有对象可以互相访问，所以可以访问p的私有成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p._name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p._age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1, p2;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 正确，因为成员方法Init访问限定符为public， 类外面可以访问</span></span><br><span class="line">p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 正确，因为成员方法Init访问限定符为public， 类外面可以访问</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print1</span>(); <span class="comment">// 正确，因为成员方法Print1访问限定符为public， 类外面可以访问</span></span><br><span class="line">p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 错误，因为成员变量_age访问限定符为private， 类外面不可以访问</span></span><br><span class="line"></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print2</span>(p2); <span class="comment">// 正确，因为成员方法Print2访问限定符为public，类外面可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-struct与class区别"><a href="#4-2-struct与class区别" class="headerlink" title="4.2 struct与class区别"></a>4.2 struct与class区别</h2><p><strong><code>struct</code>与<code>class</code>都是定义类的关键字，唯一的区别class的默认访问权限与继承方式为private，struct为public(因为struct要兼容C)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名：%s 年龄：%d\n&quot;</span>, _name, _age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 正确，因为成员方法Init访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 正确，因为成员方法Print访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line">p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 正确，因为成员变量_age访问限定符没有明确定义，所以默认为public， 类外面可以访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>); <span class="comment">// 错误，因为成员方法Init访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 错误，因为成员方法Print访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line">p<span class="number">1.</span>_age = <span class="number">10</span>; <span class="comment">// 错误，因为成员变量_age访问限定符没有明确定义，所以默认为private， 类外面不可以访问</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、对象"><a href="#五、对象" class="headerlink" title="五、对象"></a>五、对象</h1><p><strong>用类创建对象的过程，称为类的实例化</strong></p><p>●类是描述对象属性和行为的，是一个抽象的概论，而对象是类的具体实现是有生命的。类是不占内存空间的，而实例化出的对象是占内存空间的。可以把类当作建筑物图纸，对象是根据设计图具体建出来的房子<br>●一个类可以实例化出多个对象,每个对象占用不同内存空间</p><h2 id="5-1-对象的大小"><a href="#5-1-对象的大小" class="headerlink" title="5.1 对象的大小"></a>5.1 对象的大小</h2><p>&emsp;对象所占内存空间的大小计算关键看对象里面存放了什么。对象是类的实例化，类由成员变量和成员方法组成。每个对象的属性不同，比如我叫张三，你叫李四。但是行为都是相同的，大家都要吃饭、睡觉等。<strong>每个对象中有没有存放相同成员方法成为计算对象大小关键</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/edb7b7559122540d66bdad794360826d.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;每个对象中成员变量是不同的，但是调用相同的成员函数（传入隐藏的this参数区分不同对象），如果按照此种方式一存储，当一个类创建多个对象时，每个对象中都会保存一份相同代码，浪费空间，<strong>所以采用方式二存储：一个对象的所占内存空间大小，是该对象中所有”非静态成员变量”所占空间大小之和（有虚函数时还有加上虚函数表指针大小）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;<strong>空类（类中没有成员变量）实例化出来的对象大小为1字节</strong>。因为空类比较特殊，实例化出来的对象没有存储任何东西，但是为了表示这个对象，编译器给了空类的对象一个字节来唯一标识</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout&lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>&emsp;大家会觉得Person类实例化出来对象大小为14字节，因为_name为10字节，_age为4字节加起来就14字节，但结果是16字节。<strong>因为对象中成员变量也要进行内存对齐</strong>， <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tqbDE2Ny9hcnRpY2xlL2RldGFpbHMvMTIzNTM4NzIw">关于内存对齐可参考这篇链接链接<i class="fa fa-external-link-alt"></i></span></p><p><font color=#0000FF ><strong>结论：<br>● 一个对象的所占内存空间大小，是该对象中所有“非静态成员变量所占空间大小之和（有虚函数时还有加上虚函数表指针大小）”<br>● 空类（类中没有成员变量）实例化出来的对象大小为1字节<br>● 对象中成员变量也要进行内存对齐</strong></font></p><h1 id="六、this指针"><a href="#六、this指针" class="headerlink" title="六、this指针"></a>六、this指针</h1><h2 id="6-1-什么是this指针"><a href="#6-1-什么是this指针" class="headerlink" title="6.1 什么是this指针"></a>6.1 什么是this指针</h2><p>&emsp;回答什么是this指针前先看下面这份代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">Person p2;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名：张三 年龄：<span class="number">18</span></span><br><span class="line">姓名：李四 年龄：<span class="number">20</span></span><br></pre></td></tr></table></figure><p>&emsp;Person类中有Init与Print两个成员方法，成员方法中没有关于不同对象的区分，那当p1调用Init函数时，该函数是如何知道应该设置p1对象，而不是设置p2对象呢？同理p2调用Print函数时，该函数是如何知道应该打印p2对象的属性，而不是打印p1对象的属性呢？</p><p>&emsp;<strong>C++中引入this指针解决该问题，即：C++编译器给每个“非静态的成员方法“增加了一个隐藏的指针参数，让该指针指向当前对象(运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> <span class="comment">//等同于 void Init(Person* const this, const char* name, int age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name); <span class="comment">// 等同于 strcpy(this-&gt;_name, name); </span></span><br><span class="line">_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">//等同于 void Print(Person* const this)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl; <span class="comment">// 等同于cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;_age &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">Person p2;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 等同于 p1.Init(&amp;p1,&quot;张三&quot;, 18);</span></span><br><span class="line">p<span class="number">2.</span><span class="built_in">Init</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>); <span class="comment">// 等同于 p2.Init(&amp;p2,&quot;李四&quot;, 20);</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 等同于p1.Print(&amp;p1);</span></span><br><span class="line">p<span class="number">2.</span><span class="built_in">Print</span>(); <span class="comment">// 等同于p2.Print(&amp;p2);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-this指针的特性"><a href="#6-2-this指针的特性" class="headerlink" title="6.2 this指针的特性"></a>6.2 this指针的特性</h2><h3 id="6-2-1-成员方法不能显性定义this指针或调用时传入对象地址"><a href="#6-2-1-成员方法不能显性定义this指针或调用时传入对象地址" class="headerlink" title="6.2.1 成员方法不能显性定义this指针或调用时传入对象地址"></a>6.2.1 成员方法不能显性定义this指针或调用时传入对象地址</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，编译器会隐式定义this指针作为函数第一个形参，不能手动定义this指针做为形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(Person* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name); </span><br><span class="line">_age = age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">Init</span>(&amp;p1,<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>); <span class="comment">// 错误，编译器自动会传入对象地址，不能手动传入</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-this指针不可修改"><a href="#6-2-2-this指针不可修改" class="headerlink" title="6.2.2 this指针不可修改"></a>6.2.2 this指针不可修改</h3><p>this指针类型为：<code>类名* const this</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span> = <span class="literal">nullptr</span>; <span class="comment">// 错误，this指针不可以修改</span></span><br><span class="line"><span class="built_in">strcpy</span>(_name, name); <span class="comment">// 等同于 strcpy(this-&gt;_name, name); </span></span><br><span class="line">_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-3-成员方法的形参不要与成员变量同名"><a href="#6-2-3-成员方法的形参不要与成员变量同名" class="headerlink" title="6.2.3 成员方法的形参不要与成员变量同名"></a>6.2.3 成员方法的形参不要与成员变量同名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">错误，成员方法的形参和成员变量同名，局部变量优先级更高，下面name和age都认为是形参的name和age</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(name, name); </span><br><span class="line">age = age; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一般建议成员变量名前面加下划线或在成员变量名后面加下划线，与成员方法中的形参做为区别</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name); <span class="comment">// _name不是形参名，则编译器认为_name是成员变量，自动会加上this-&gt;,即 strcpy(this-&gt;_name,name);</span></span><br><span class="line">_age = age;  <span class="comment">// 等同于 this-&gt;_age = age;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>下面这种写法不推荐</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于成员方法的形参和成员变量同名，局部变量优先级更高，为了避免下面name和age都认为是形参的name和age</span></span><br><span class="line"><span class="comment">我们用作用域限定符，指明哪个name、age是成员变量的name、age。但是不推荐这种写法，代码可读性、逻辑性较差</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(Person::name, name); <span class="comment">// Person::name 表示name是Person作用域中的name，因为一个类就是一个作用域</span></span><br><span class="line">Person::age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-3-可以在非静态成员方法内显式使用this指针"><a href="#6-2-3-可以在非静态成员方法内显式使用this指针" class="headerlink" title="6.2.3 可以在非静态成员方法内显式使用this指针"></a>6.2.3 可以在非静态成员方法内显式使用this指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在非静态成员方法内可以显性使用this指针，不过没有太大意义，因为编译器默认会用this指针访问成员变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_name, name);</span><br><span class="line"><span class="keyword">this</span>-&gt;_age = age; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-3-this指针存放在哪里"><a href="#6-3-this指针存放在哪里" class="headerlink" title="6.3 this指针存放在哪里"></a>6.3 this指针存放在哪里</h2><p>&emsp;this指针本质上其实是一个成员方法的形参，是对象调用成员方法时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。<strong>因为this指针是形参，this指针存放在调用成员方法的栈中，但是部分编译器将this指针存放在寄存器中</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d7a16e59ef8afe91372d10273977a294.png#pic_center" alt="在这里插入图片描述"></p><h1 id="七、-const-修饰类的成员函数"><a href="#七、-const-修饰类的成员函数" class="headerlink" title="七、 const 修饰类的成员函数"></a>七、 const 修饰类的成员函数</h1><p>&emsp;类的成员函数的隐藏形参this指针类型为：<code>类名* const this</code>,<strong>表示this指针本身不能改变，但是this指针指向的对象可以改变，即对象的成员变量可以改变</strong>。有些时候成员变量不需要改变，为了防止误操作，<strong>可以在成员函数形参列表后面加上const，表示对隐藏形参this指针修饰，此时this指针类型为：<code>const 类名* const this</code>,表明不能对this指针指向的对象里面的成员变量进行修改。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> _name[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">_age = age; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// 使用const修饰</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、面向过程与面向对象编程&quot;&gt;&lt;a href=&quot;#一、面向过程与面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;一、面向过程与面向对象编程&quot;&gt;&lt;/a&gt;一、面向过程与面向对象编程&lt;/h1&gt;&lt;p&gt;&amp;emsp;我们经常听别人谈起C语言是面向过程的编程语言，而C++是面向对象的编程语言。但是你让他具体说下什么是面向过程、什么是面向对象可能他很难说清楚。今天鄙人拙见谈谈什么是面向过程、什么是面向对象的看法。不管是面向什么都要把程序写出来，那程序是什么？计算机编程领域的祖师爷尼古拉斯•威茨曾经说过&lt;code&gt;程序=数据结构+算法&lt;/code&gt;， &lt;strong&gt;所以程序的本质：为了解决某个问题，选择合适的数据结构和算法进行若干步骤的求解&lt;/strong&gt;。对于一个问题求解的思路有很多种，&lt;strong&gt;我认为面向过程与面向对象编程的区别就是对问题分析求解的思想不同&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="C plus plus" scheme="https://blog.kjlcloud.com/categories/C-plus-plus/"/>
    
    
  </entry>
  
</feed>
